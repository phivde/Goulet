%%% Copyright (C) 2018 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de contrôle et fonctions d'application}
\label{chap:application}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Utiliser la fonction \code{if} pour l’exécution conditionnelle
  d'expressions R.
\item Concevoir une boucle dans R.
\item Choisir entre les opérateurs \code{for}, \code{while} et
  \code{repeat} lors de la construction d'une boucle R.
\item Effectuer des sommaires sur des tableaux à l’aide de la fonction
  \code{apply}.
\item Réduire des vecteurs et des listes avec les fonctions
  \code{lapply}, \code{sapply} et \code{mapply}; comparer l'effet de
  ces fonctions.
\item Passer des valeurs à une fonction d'application via l’argument
  `\code{...}'.
\item Distinguer la construction \code{if ... else ...} de la fonction
  \code{ifelse}.
\end{objectifs}

Comme bien d'autres machines conçues par les humains, les ordinateurs
ont toujours été mis à contribution pour les tâches répétitives et
fastidieuses. Ce n'est donc pas pour rien que tous les langages de
programmation prévoient un ou plusieurs mécanismes pour répéter une
procédure un certain nombre de fois ou jusqu'à ce qu'une condition
soit remplie.

La répétition de procédures, la sortie forcée d'un programme ou le
choix entre diverses procédures sont réalisés à l'aide de commandes
spéciales appelées \emph{structures de contrôle}. Ce chapitre étudie
en premier lieu les structures de contrôle disponibles dans le langage
R.

Nous savons déjà que certains types de calculs répétitifs sont
automatiquement pris en charge par le langage R via une couche
d'abstraction que nous avons appelée l'arithmétique vectorielle
(\autoref{sec:bases:vecteurs:arithmetique}). Un autre large pan des
calculs répétitifs peut être réduit à quelques fonctions abstraites
dites d'\emph{application} (\emph{mapping}, un autre concept hérité du
\index{Lisp}Lisp). Les fonctions d'application masquent efficacement
les calculs répétitifs sur les dimensions des matrices et des
tableaux, ainsi que ceux sur les éléments d'un vecteur ou d'une liste.


\section{Exécution conditionnelle}
\label{sec:application:if}

Les premières structures de contrôle que nous étudions sont les
structures d'exécution conditionnelle. La plupart des programmes
doivent pouvoir effectuer des tests pour choisir entre deux actions
possibles ou plus. Par exemple, le programme pourrait s'arrêter avec
un message d'erreur si les arguments fournis par l'utilisateur ne sont
pas valides, effectuer des calculs différents selon la valeur d'un
argument, ou retourner un résultat prédéfini si un argument satisfait
certaines conditions.

La structure \Indexcode{if}\Indexcode{else}\code{if ... else ...}
permet d'exécuter une expression ou une autre selon qu'une condition
est vraie ou fausse. La clause alternative est optionnelle. Les
syntaxes des deux formulations sont les suivantes:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
else
    \meta{alternative}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{condition} est une expression dont le résultat est une
  valeur \code{TRUE} ou \code{FALSE} \emph{unique}. C'est une erreur
  fréquente de construire un test de telle sorte que \meta{condition}
  est un vecteur, ce qui n'a guère de sens. Les fonctions \icode{any},
  \icode{all} (\autoref{sec:internes:fonctions:tests}) et \icode{isTRUE}
  se révèlent utiles dans les clauses \code{if} pour réduire les
  vecteurs booléens à une valeur unique.
\item \meta{conséquence} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{TRUE}.
\item \meta{alternative} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{FALSE}.
\end{itemize}

\warningbox{Il tombe sous le sens que «vrai» est vrai, n'est-ce pas?
  Prenez donc garde de ne pas écrire des expressions qui reviennent à
  tester \verb|if (TRUE == TRUE)|. Oui, j'ai souvent rencontré
  de telles constructions!}

Pour choisir entre plus de deux possibilités, il est possible
d'emboiter des structures \code{if ... else ...} les unes dans les
autres.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition 1})
    \meta{conséquence 1}
else if (\meta{condition 2})
    \meta{conséquence 2}
else
    \meta{alternative}
\end{Verbatim}
\end{Schunk}

Au-delà de trois ou quatre possibilités, il vaut souvent mieux
utiliser la fonction \Icode{switch}. Sa syntaxe est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
switch(\meta{expression}, \meta{cas.1} = \meta{action.1},
                          \meta{cas.2} = \meta{action.2}, ...)
\end{Verbatim}
\end{Schunk}
La fonction évalue d'abord \meta{expression}. Si le résultat est une
valeur numérique $j$, alors \meta{action.$j$} est exécutée. Si le
résultat de \meta{expression} est l'une des chaines de caractères
\meta{cas.1}, \meta{cas.2}, \dots, alors c'est l'action correspondante
qui est exécutée.
<<echo=TRUE>>=
switch(2, 2 + 3, mean(1:10), 5:1)
switch("foo", foo = 2 + 3, bar = mean(1:10))
@

Enfin, la fonction \Icode{ifelse} --- une sorte de version vectorielle
de la structure \code{if ... else ...} --- permet de calculer des
valeurs selon les résultats d'un test sur un vecteur. Sa syntaxe est
la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
ifelse(\meta{test}, \meta{oui}, \meta{non})
\end{Verbatim}
\end{Schunk}
Les arguments \meta{test}, \meta{oui} et \meta{non} sont trois
vecteurs de la même longueur
\begin{itemize}
\item \meta{test} est un vecteur booléen.
\item \meta{oui} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{TRUE} dans \meta{test}.
\item \meta{non} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{FALSE} dans \meta{test}.
\end{itemize}
<<echo=TRUE>>=
x <- c(-2, 3, -1, 0, 5, 1)
ifelse(x < 0, -x, x)
@

Une fois que l'on a compris son fonctionnement, la fonction
\icode{ifelse} peut apparaitre comme un outil de choix dans notre
arsenal de fonctions R, en particulier pour la programmation de
fonctions mathématiques définies par branches. En réalité, cependant,
\code{ifelse} est très lente. Dans la plupart des cas, il vaut mieux
lui préférer des constructions moins élégantes, mais bien plus
rapides. En particulier, la rubrique d'aide de la fonction souligne
que la structure \code{if ... else ...} est beaucoup plus efficace si
\meta{test} est un vecteur de longueur $1$.


\section{Boucles itératives}
\label{sec:application:boucles}

Il existe deux grandes manières de répéter des calculs en
programmation: par \index{iteration@itération}itération ou par
\index{recursivite@récursivité}récursivité. Une procédure itérative
répète un bloc d'instructions, habituellement avec un léger changement
d'état, jusqu'à ce qu'un nombre de répétitions soit atteint ou qu'une
condition soit satisfaite. C'est ce que l'on appelle communément une
\emph{boucle} (\emph{loop}). Très intuitives, les boucles itératives
sont particulièrement utilisées en programmation impérative.

La procédure récursive, quant à elle, est caractérisée par le fait
qu'elle s'invoque elle-même jusqu'à ce qu'une condition d'arrêt soit
satisfaite. Moins intuitive, mais généralement jugée plus élégante,
elle est particulièrement répandue en programmation fonctionnelle et
en intelligence artificielle.\footnote{%
  Si l'on définit plus largement l'itération comme la répétition d'un
  bloc d'instructions, alors la récursivité n'est qu'une forme
  d'itération. Il est toutefois d'usage en informatique de distinguer
  les procédures itératives des procédures récursives comme je le
  fais ici.}

Nous reviendrons sur la récursivité à la
\autoref{sec:application:recursivite}. La présente section étudie les
structures de contrôles itératives de R. Elles sont de trois types: la
boucle à contrôle par dénombrement (boucle \code{for}), la boucle à
pré-condition «tant que» (boucle \code{while}) et la boucle à
condition d'arrêt (boucle \code{repeat}).

La boucle à dénombrement \Icode{for} sert pour répéter une procédure
un nombre prédéterminé de fois. La syntaxe de la boucle \code{for} est
la suivante, dans R:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
for (\meta{variable} in \meta{suite})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{variable} est un \emph{compteur} ou, plus spécifiquement,
  un \emph{itérateur} qui prend successivement les valeurs contenues
  dans \meta{suite}. La variable est habituellement --- mais pas
  nécessairement --- utilisée dans les calculs à l'intérieur de la
  boucle.
\item \meta{suite} est un vecteur de valeurs. À noter que \meta{suite}
  n'a pas à être composée de nombres consécutifs, ni même de nombres,
  en fait.
\item \meta{expression} est le contenu de la boucle à proprement
  parler. Comme d'habitude, si le contenu est constitué de plusieurs
  expressions, elles doivent être regroupées des accolades \verb={ }=.
\end{itemize}

La boucle à pré-condition \Icode{while} exécute une procédure tant
qu'une condition est satisfaite. La condition étant vérifiée avant
d'entrer dans la boucle, celle-ci peut ne jamais s'exécuter. La
syntaxe de la boucle \code{while} est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
while(\meta{condition})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{condition} est une expression dont le résultat est une
  valeur \code{TRUE} ou \code{FALSE} unique.
\item \meta{expression} est une expression ou un groupe d'expressions
  entre accolades \verb={ }= qui sont exécutées tant que
  \meta{condition} est \code{TRUE}.
\end{itemize}

Plusieurs langages de programmation comportent une structure itérative
à post-condition «tant que» (boucle \code{do ... while}) ou «jusqu'à
ce que» (boucle \code{do ... until}), voire les deux. Dans R, la
boucle à post-condition prend plutôt la forme d'une boucle à condition
d'arrêt \Icode{repeat}. La syntaxe de cette boucle est on ne peut plus
simple:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
repeat
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{expression} est l'expression ou le groupe d'expressions à
  répéter. En pratique, pour éviter que la boucle ne se répète indéfiniment,
  \meta{expression} est toujours un groupe d'expressions comportant un
  test d'arrêt.
\end{itemize}

Le test d'arrêt d'une boucle \icode{repeat} utilise habituellement la
commande \icode{break} (\autoref{sec:application:flux}) pour forcer la
sortie de la boucle. Puisque le test se trouve à l'intérieur de la
boucle --- généralement à ou vers la fin ---, une boucle \code{repeat}
est toujours exécutée au moins une fois.


\section{Contrôle du flux}
\label{sec:application:flux}

Les commandes de contrôle du flux permettent d'infléchir le
déroulement normal d'une boucle.

\begin{ttscript}{break}
\item[\Icode{break}] Force la sortie de la boucle courante. La
  commande \code{break} peut être utilisée dans les boucles
  \icode{for} ou \icode{while}, mais elle est presque indissociable de
  la boucle \icode{repeat}. Si l'on assemble les morceaux des sections
  précédentes, une boucle \icode{repeat} est généralement construite
  ainsi:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\[\]]
repeat
{
    \meta[expression]
    if (\meta[condition])
        break
}
\end{Verbatim}
\end{Schunk}
\item[\Icode{next}] Force le passage à la prochaine itération de la
  boucle \icode{for}, \icode{while} ou \icode{repeat}. Comme
  \icode{break}, la commande est généralement utilisée à l'intérieur
  d'une structure conditionnelle.
\end{ttscript}

Bien qu'elles ne soient pas à proprement parler des commandes de
contrôle de flux, les trois fonctions ci-dessous permettent néanmoins
de contrôler l'exécution d'une fonction.

\begin{ttscript}{warning}
\item[\Icode{return}] Force la sortie immédiate de la fonction et
  retourne l'objet en argument.
\item[\Icode{stop}] Force la sortie immédiate de la fonction avec le
  message d'erreur donné en argument.
\item[\Icode{warning}] Envoie le message d'avertissement donné en
  argument à R. L'effet dépend de la valeur de \code{options("warn")}.
  Par défaut, tous les avertissements sont affichés à la console après
  l'exécution de la fonction.
\end{ttscript}


\section{Récursivité}
\label{sec:application:recursivite}

En tant que langage de programmation fonctionnel, R admet tout
naturellement les procédures récursives. Lorsque la fonction récursive
s'invoque elle-même, nous pouvons remplacer le nom de la fonction par
\Icode{Recall}. Cela rend l'appel récursif indépendant du nom de la
fonction, ce qui peut s'avérer bien utile en cas de changement du nom
de la fonction.

Par exemple, nous pouvons réécrire ainsi la mise en œuvre récursive de
la fonction factorielle de la \autoref{fig:presentation:scheme_vs_s},
à la \autopageref{fig:presentation:scheme_vs_s}:
\begin{Schunk}
\begin{Sinput}
factorial <- function(n)
    if (n == 1) 1 else n * Recall(n - 1)
\end{Sinput}
\end{Schunk}

\warningbox{Le temps système requis pour la création des
  environnements lors de chaque appel de fonction
  (\autoref{chap:implementation}) rend les fonctions récursives peu
  efficaces en R.}


\section{Syndrôme de la plaque à biscuits}
\label{sec:application:syndrome}

La suite de Fibonacci est une suite de nombres entiers très connue.
Les deux premiers termes de la suite sont $0$ et $1$ et tous les
autres sont la somme des deux termes précédents. Mathématiquement, les
valeurs de la suite de Fibonacci sont données par la fonction
\begin{align*}
  f(0) &= 0 \\
  f(1) &= 1 \\
  f(n) & = f(n - 1) + f(n - 2), \quad n \geq 2.
\end{align*}
Le quotient de deux termes successifs converge vers
$\phi = (1 + \sqrt{5})/2$, le nombre d'or\footnote{%
  On prête au nombre d'or toutes sortes de propriétés, certaines même
  d'ordre mystique. Il est en tout cas au cœur d'un des romans les
  plus vendus de tous les temps, \emph{Da~Vinci Code} (Dan Brown,
  2003).} %

Le calcul du $n${\ieme} terme de la suite de Fibonacci se prête tout
naturellement à une mise en œuvre récursive, tel qu'expliqué dans
\citet[chapitre~9]{Stephens:algorithms:2013}.

Nous nous penchons ici sur un problème légèrement différent: calculer
les $n$ premiers termes de la suite de Fibonacci. Il est plus simple
de procéder par itération pour résoudre ce problème. La fonction
\code{fibonacci0}, dont la définition se trouve à la
\autoref{fig:application:fibonacci0}, propose une première solution.

\begin{figure}
\begin{Schunk}
\begin{Verbatim}
fibonacci0 <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- c(0, 1)
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
\end{Verbatim}
\end{Schunk}
  \caption{Première version d'une fonction pour calculer les $n$
    premiers termes de la suite de Fibonacci}
  \label{fig:application:fibonacci0}
\end{figure}

Avant d'aller plus loin, quelques commentaires sur \code{fibonacci0}.
\begin{itemize}
\item La fonction n'étant valide que pour un argument \code{nterm}
  supérieur ou égal à $1$, elle affiche un message d'erreur si ce
  n'est pas le cas.
\item La fonction intercepte le cas trivial \code{nterm == 1} dès le
  départ.
\item Lors de sa création, l'objet \code{x} contient déjà le résultat
  du cas \code{nterm == 2}. La fonction devra donc éviter de faire
  d'autres calculs pour ce cas.
\item En créant la suite de la boucle \icode{for} avec
  \code{seq\_len}, la boucle ne s'exécute pas lorsque \code{nterm ==
    2} puisque le résultat \code{seq\_len(0)} est un vecteur vide.
\item La seule expression de la boucle \code{for} ajoute
  successivement un terme au vecteur \code{x}.
\end{itemize}

<<echo=FALSE>>=
fibonacci0 <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- c(0, 1)
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
@
<<echo=TRUE>>=
fibonacci0(1)
fibonacci0(2)
fibonacci0(5)
@

Bien que valide --- comme les exemples d'utilisation de la fonction le
démontrent --- la fonction \code{fibonacci0} souffre d'un gros défaut:
la taille de l'objet \code{x} doit constamment augmenter pour stocker
une nouvelle valeur de la suite de Fibonacci.

Tentons une analogie alimentaire pour cette manière de procéder. Pour
ranger des biscuits frais sortis du four, vous prenez un premier
biscuit et vous le rangez dans un plat ne pouvant contenir qu'un seul
biscuit. Arrivés au second biscuit, constatant que le contenant n'est
pas assez grand, vous sortez un plat pouvant contenir deux biscuits,
vous changez le premier biscuit de plat et vous y rangez aussi le
second biscuit. Arrivés au troisième biscuit, le petit manège
recommence, et ainsi de suite jusqu'à ce que le plateau de biscuits
soit épuisé. C'est ce que je nomme, non sans un sourire en coin, le
Syndrôme de la plaque à
biscuits{\texttrademark}\index{syndrome@Syndrôme de la plaque à
  biscuits}\index{biscuits|see{Syndrôme de la plaque à biscuits}}.

Le manège décrit ci-dessus se reproduit à l'identique dans la mémoire
de l'ordinateur, l'odeur des biscuits chauds en moins. En effet,
l'ordinateur doit constamment allouer de la nouvelle mémoire et
déplacer les termes déjà sauvegardés au fur et à mesure que le vecteur
\code{x} grandit. Vous aurez compris qu'une telle façon de faire est à
éviter absolument lorsque c'est possible --- et ça l'est la plupart du
temps.

Quand nous savons quelle sera la longueur finale d'un objet, comme
c'est le cas dans cet exemple, il vaut mieux créer un contenant vide
de la bonne longueur et le remplir par la suite. La fonction
\code{fibonacci} de la \autoref{fig:application:fibonacci} évite le
Syndrôme.

\begin{figure}
\begin{Schunk}
\begin{Verbatim}
fibonacci <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- numeric(nterm)  # création du contenant
    x[2] <- 1            # x[1] vaut déjà 0
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
\end{Verbatim}
\end{Schunk}
  \caption{Fonction pour calculer les $n$ premiers termes de la suite
    de Fibonacci ne souffrant pas du Syndrôme de la plaque à
    biscuits{\texttrademark}}
  \label{fig:application:fibonacci}
\end{figure}

<<echo=FALSE>>=
fibonacci <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- numeric(nterm)  # création du contenant
    x[2] <- 1            # x[1] vaut déjà 0
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
@
<<echo=TRUE>>=
fibonacci(1)
fibonacci(2)
fibonacci(5)
@

Avons-nous vraiment gagné en efficacité? Le code informatique de la
\autoref{sec:application:exemples} permet de vérifier que la seconde
fonction est de trois à cinq fois plus rapide que la première!


\section{Fonctions d'application}
\label{sec:application:application}

On retrouve les structures de boucles dans la grande majorité des
langages de programmation, du moins chez les descendants de
\index{Fortran}Fortran et \index{Algol}d'Algol. La mise en œuvre de
calculs répétitifs à l'aide de boucles constitue généralement
l'approche la plus simple et la plus intuitive, surtout pour les
personnes peu expérimentées en programmation.

En revanche, à moins que le code ne soit accompagné de commentaires
très complets, la programmation par boucles demande un certain effort
de décryptage pour les humains. De plus, elle s'insère assez mal dans
l'approche vectorielle mise de l'avant par le langage R. C'est ici
qu'entrent en jeu les fonctions d'\emph{application} (\emph{mapping}).
Celles-ci permettent de masquer, par une couche d'abstraction, les
boucles les plus usuelles dont la structure demeure toujours à peu de
choses près la même. De plus, elles se prêtent beaucoup plus
naturellement à la programmation vectorielle.

\subsection[Matrices et tableaux]{Fonction d'application pour les matrices et les tableaux}
\label{sec:application:application:apply}

Une matrice \code{x} contient le nombre de réclamations en assurance
dommages de trois entreprises pour les cinq dernières années.
<<echo=FALSE>>=
set.seed(1)
ncontracts <- 3
nyears <- 5
x <- matrix(rpois(ncontracts * nyears, rgamma(ncontracts, 1.5)),
            nrow = ncontracts)
@
<<echo=TRUE>>=
x
@

Une analyste souhaite connaitre le nombre total de réclamations par
entreprise, d'une part, et par année, d'autre part. Cela consiste à
calculer les sommes par ligne et par colonne de la matrice, dans
l'ordre. Or, aucun opérateur usuel de R ne permet d'effectuer
directement de tels calculs. Notre analyste pourrait s'en sortir en
écrivant des fonctions itératives pour effectuer les calculs.

<<echo=TRUE>>=
rowsum <- function(x)
{
    n <- nrow(x)
    res <- numeric(n)
    for (i in seq_len(n))
        res[i] <- sum(x[i, ])
    res
}
colsum <- function(x)
{
    n <- ncol(x)
    res <- numeric(n)
    for (j in seq_len(n))
        res[j] <- sum(x[, j])
    res
}
@
<<echo=TRUE>>=
rowsum(x)
colsum(x)
@

L'analyste devrait utiliser ce genre de procédure pour tout calcul de
sommaire par ligne ou par colonne d'une matrice. Pourtant, seule la
fonction de sommaire (\icode{sum} dans notre exemple) changerait d'une
fois à l'autre. En fait, ce que souhaite l'analyste, c'est pouvoir
facilement \emph{appliquer} une fonction quelconque sur l'une ou
l'autre des deux dimensions d'une matrice. C'est exactement ce que
permet de faire la fonction \icode{apply}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

La \capsule{https://youtu.be/12Uy8_SJQzA}{fonction \Icode{apply}}
s'utilise autant avec les matrices qu'avec les tableaux. Sa syntaxe
complète est la suivante:
\begin{Schunk}
\begin{Verbatim}
apply(X, MARGIN, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est une matrice ou un tableau.
\item \code{MARGIN} est un vecteur d'entiers contenant la ou les
  dimensions de la matrice ou du tableau sur lesquelles la fonction
  doit s'appliquer.
\item \code{FUN} est la fonction à appliquer sur la ou les dimensions.
  La fonction reçoit les sous-ensembles de \code{X} sans que ceux-ci
  ne soient nommés. Les règles habituelles d'évaluation d'un appel de
  fonction s'appliquent: les données constituent le premier argument
  de \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\item `\code{...}' contient des arguments supplémentaires à passer à
  \code{FUN}, séparés par des virgules.
\end{itemize}

Le quatrième argument de \code{apply} est l'argument formel spécial
`\icode{...}' dont nous avons traité à la
\autoref{sec:bases:fonctions:definition}. Il devient très utile, ici,
lorsque la fonction \code{FUN} prend plus d'un argument.

Pour illustrer, reprenons l'exemple précédent en supposant maintenant
que les entreprises n'ont pas toutes cinq années de données.
<<echo=FALSE>>=
x[1, c(4, 5)] <- NA
x[2, c(1, 2)] <- NA
x[3, 5] <- NA
@
<<echo=TRUE>>=
x
@

Si l'analyste a recours aux mêmes expressions que ci-dessus pour
calculer les sommaires par ligne et par colonne, elle obtiendra des
résultats sans grand intérêt puisque, comme on le sait, tout calcul
avec des données manquantes retourne la valeur \code{NA}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

Fort heureusement, la fonction \code{sum} possède un argument
\code{na.rm} qui indique de supprimer les données manquantes avant
d'effectuer la somme. L'analyste spécifie donc cet argument de la
fonction \code{sum} dans l'argument `\icode{...}' de \code{apply}.
<<echo=TRUE>>=
apply(x, 1, sum, na.rm = TRUE)
apply(x, 2, sum, na.rm = TRUE)
@

\tipbox{Les sommaires les plus usuels pour les matrices sont la somme
  et la moyenne, par ligne et par colonne. Les fonctions
  \icode{rowSums}, \icode{colSums}, \icode{rowMeans} et
  \icode{colMeans} permettent de calculer plus directement ces
  sommaires.}

Lorsque l'on applique une fonction à un tableau à plus de deux
dimensions, l'objet passé à la fonction peut s'avérer être une matrice
ou un tableau, selon le contenu de l'argument \code{MARGIN}. Par
exemple, si \code{X} est un tableau à trois dimensions et que la
longueur de \code{MARGIN} est $1$, on applique \code{FUN} sur les
«tranches» de \code{X} (des matrices). Si la longueur de \code{MARGIN}
est $2$, on applique plutôt \code{FUN} à des «carottes» tirées de
\code{X} (des vecteurs).

Nous allons illustrer ces propos à partir du tableau
$3 \times 4 \times 2$ ci-dessous.
<<echo=FALSE>>=
x <- array(sample(0:10, 24, rep = TRUE), c(3, 4, 2))
@
<<echo=TRUE>>=
x
@

Les expressions suivantes calculent, dans l'ordre:
\begin{enumerate}
\item les sommes des trois tranches horizontales (de l'avant vers
  l'arrière) dans le tableau;
\item les sommes des quatre tranches verticales (du haut vers le bas);
\item les sommes des deux tranches transversales (de la gauche vers la
  droite);
\item les sommes des douze carottes horizontales;
\item les sommes des huit carottes verticales.
\item les sommes des six carottes transversales;
\end{enumerate}
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
apply(x, 3, sum)
apply(x, c(1, 2), sum)
apply(x, c(2, 3), sum)
apply(x, c(1, 3), sum)
@

\tipbox{Truc mnémotechnique: la ou les dimensions figurant dans
  l'argument \code{MARGIN} sont celles retenues par le passage de
  \icode{apply}. En d'autres termes, les dimensions du résultat de
  \code{apply} sont \code{dim(X)[\code{MARGIN}]}.}

\subsection[Listes et vecteurs]{Fonctions d'application pour les listes et les vecteurs}
\label{sec:application:application:lapply}

Les idées de la sous-section précédente se transposent sans mal aux
listes et aux vecteurs. En effet, il n'y a pas d'arithmétique
vectorielle qui tienne pour les listes. Pour effectuer une opération
sur chaque élément d'une liste, il faut utiliser une procédure
itérative, procédure que R masque avec des fonctions d'application.

La fonction d'application de base pour les listes et les vecteurs est
\Icode{lapply}. Elle applique une fonction \code{FUN} à tous les
éléments d'un vecteur ou d'une liste \code{X} et retourne le résultat
sous forme de liste. La syntaxe de \code{lapply} est similaire à celle
de \icode{apply}, l'argument \code{MARGIN} en moins:
\begin{Schunk}
\begin{Verbatim}
lapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur ou une liste.
\item \code{FUN} est la fonction à appliquer à chacun des éléments de
  \code{X}. Ceux-ci ne sont pas nommés lorsqu'ils sont passés à la
  fonction. Les règles habituelles d'évaluation d'un appel de fonction
  s'appliquent: les données constituent le premier argument de
  \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\end{itemize}

Nous avons déjà rencontré la fonction \icode{sample} qui permet de
tirer un échantillon aléatoire parmi un ensemble de valeurs. Le
premier argument de \code{sample} est \code{x}, l'ensemble de valeurs.
Le second argument est \code{size}, la taille de l'échantillon. Les
expressions ci-dessous permettent de créer une liste formée de quatre
vecteurs aléatoires de taille $5$, $6$, $7$ et $8$; de calculer la
somme de chacun de ces vecteurs; de trier chacun des vecteurs.
<<echo=TRUE>>=
(x <- lapply(5:8, sample, x = 1:10))
lapply(x, sum)
lapply(x, sort)
@

Sœur siamoise de \code{lapply}, la fonction \Icode{sapply} retourne,
lorsque c'est possible, son résultat sous forme de vecteur ou de
matrice. Le résultat est donc \emph{simplifié} par rapport à celui de
\code{lapply}, d'où le nom de la fonction. La syntaxe en change pas:
\begin{Schunk}
\begin{Verbatim}
sapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item Si les résultats de l'application sont tous des vecteurs de
  longueur $1$, alors \code{sapply} retourne un vecteur.
\item Si les résultats de l'application sont des vecteurs de la même
  longueur supérieure à $a$, alors \code{sapply} retourne une
  matrice, remplie comme toujours par colonne.
\item Si les résultats de l'application sont des vecteurs de longueurs
  différentes, alors \code{sapply} est identique à \code{lapply}.
\end{itemize}
<<echo=TRUE>>=
(x <- lapply(rep(5, 3), sample, x = 1:10))
sapply(x, sum)
sapply(x, sort)
@

\tipbox{La fonction \icode{sapply} est souvent utile pour rendre
  vectorielle une fonction \code{f} qui ne le serait pas autrement. Il
  y a deux stratégies possibles: appliquer la fonction \code{f} à un
  vecteur avec \code{sapply}, ou modifier \code{f} pour y intégrer un
  appel à \code{sapply}.}

\importantbox{Dans un grand nombre de cas, il est possible de
  remplacer les boucles \icode{for} par des applications avec
  \icode{lapply} ou \icode{sapply}. On ne saurait donc trop insister
  sur l'importance de ces deux fonctions.}

Autre membre de la famille des fonctions d'application sur les listes
et les vecteurs, \Icode{mapply} est une version multidimensionnelle de
\code{sapply}. Sa syntaxe est, pour l'essentiel:
\begin{Schunk}
\begin{Verbatim}
mapply(FUN, ...)
\end{Verbatim}
\end{Schunk}
Le résultat de \code{mapply} est l'application de la fonction
\code{FUN} aux premiers éléments de tous les arguments contenus dans
`\code{...}', puis à tous les seconds éléments, et ainsi de suite.

Ainsi, si \code{v} et \code{w} sont des vecteurs, \code{mapply(FUN, v,
  w)} retourne sous forme de liste, de vecteur ou de matrice, selon le
cas, \code{FUN(v[1], w[1])}, \code{FUN(v[2], w[2])}, etc.

\subsection[Groupes de données]{Fonction d'application pour groupes de données}
\label{sec:application:application:tapply}

La fonction \Icode{tapply} applique une fonction à chacun des groupes
de données définis par les catégories d'un facteur ou d'une
combinaison de facteurs. Pour mieux comprendre, étudions la syntaxe de
la fonction:
\begin{Schunk}
\begin{Verbatim}
tapply(X, INDEX, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur.
\item \code{INDEX} est un facteur ou une liste de facteurs, chacun de la
  même longueur que \code{X}.
\item \code{FUN} est la fonction à appliquer à chacun des groupes de
  données définis par les catégories des facteurs dans \code{INDEX}.
\end{itemize}
<<echo=TRUE>>=
x <- data.frame(couleur=c("r", "v", "r", "r", "v"),
                score=c(2, 0, 4, 3, 10))
str(x)
tapply(x$score, x$couleur, mean)
@

\subsection{Produit extérieur}
\label{sec:application:application:outer}

J'étire quelque peu le concept de fonction d'application pour
discuter ici de la fonction de produit extérieur \code{outer}. Ce
n'est pas la fonction la plus intuitive à utiliser, mais elle s'avère
extrêmement utile pour effectuer plusieurs opérations en une seule
expression tout en masquant les boucles implicites.

La \capsule{https://youtu.be/cyPUAnieWHw}{fonction \Icode{outer}}
calcule le \index{produit!extérieur}produit extérieur entre deux
vecteurs, c'est à dire le résultat de \code{FUN(X[i], Y[j])} pour
toutes les valeurs des indices \code{i} et \code{j}. La syntaxe de la
fonction est la suivante:
\begin{Schunk}
\begin{Verbatim}
outer(X, Y, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} et \code{Y} sont deux objets, normalement des vecteurs
  ou des matrices.
\item \code{FUN} est la fonction à appliquer (\code{"*"} par défaut)
  entre chacun des éléments de \code{X} et chacun des éléments de
  \code{Y}. Lorsque \code{FUN} est un opérateur arithmétique du
  \autoref{tab:bases:operateurs}, il faut placer le symbole entre
  guillemets: \code{"*"}, \code{"+"}, \code{"<="}, etc.
\end{itemize}
La dimension du résultat de \code{outer} est \code{c(dim(X), dim(Y))}.
<<echo=TRUE>>=
outer(c(1, 2, 5), c(2, 3, 6))
@

L'opérateur \Icode{\%o\%} est un raccourci de \code{outer(X, Y, "*")}.

\section{Exemples}
\label{sec:application:exemples}

\def\scriptfilename{application.R}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=13]{\scriptfilename}


\section{Exercices}
\label{sec:application:exercices}

\Opensolutionfile{solutions}[solutions-application]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:application}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:application}}

\end{Filesave}

\begin{exercice}
  Le produit matriciel entre deux matrices
  $\mat{A} = [a_{ij}]_{m \times p}$ et
  $\mat{B} = [b_{ij}]_{p \times n}$ est une matrice $m \times n$ dont
  l'élément en position $(i, j)$ est
  \begin{equation*}
    \sum_{k = 1}^p a_{ik} b_{kj}.
  \end{equation*}

  Sans utiliser l'opérateur \code{\%*\%}, écrire une fonction
  \code{prod\_mat} qui effectuera le produit matriciel entre deux
  matrices seulement si les dimensions de celles-ci le permettent.
  Cette fonction aura deux arguments (\code{A} et \code{B}) et devra
  tout d'abord vérifier si le produit matriciel est possible. Si
  celui-ci est impossible, la fonction retourne un message d'erreur.
  \begin{enumerate}
  \item Utiliser une structure de contrôle \code{if ... else ...} et
    deux boucles.
  \item Utiliser une structure de contrôle \code{if ... else ...},
    une seule boucle et une fonction d'application.
  \end{enumerate}
  Dans chaque cas, comparer le résultat avec l'opérateur \code{\%*\%}.
  \begin{sol}
    \begin{enumerate}
    \item
\begin{Schunk}
\begin{Verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")

    res <- matrix(0, nrow = nrow(A),
                  ncol = ncol(B))
    for (i in seq_len(nrow(A)))
    {
        for (j in seq_len(ncol(B)))
        {
            res[i, j] <- sum(A[i, ] * B[, j])
        }
    }
    res
}
\end{Verbatim}
\end{Schunk}
    \item
\begin{Schunk}
\begin{verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")

    res <- matrix(0, nrow = nrow(A),
                  ncol = ncol(B))
    for (i in seq_len(nrow(A)))
        res[i, ] <- apply(A[i, ] * B, 2, sum)
    res
}
\end{verbatim}
\end{Schunk}
    \end{enumerate}
    Solution bonus qui remplace la boucle par une fonction d'application
    \icode{sapply}. (La fonction \icode{t} transpose la matrice en
    argument.)
\begin{Schunk}
\begin{verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")
    sapply(seq_len(ncol(B)),
           function(j) apply(t(A) * B[, j], 2, sum))
}
\end{verbatim}
\end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}
  La valeur actuelle d'une série de $n$ paiements de $1$ versés à la
  fin des années $1, 2, \dots, n$ à un taux d'intérêt $i$ effectif
  annuellement est
  \begin{equation*}
    a_\angln
    = v + v^2 + \dots + v^n
    = \frac{1 - v^n}{i},
  \end{equation*}
  où $v = (1 + i)^{-1}$. Calculer en une seule expression et
  \emph{sans boucle} un tableau des valeurs actuelles de séries de
  $n = 1, 2, \dots, 10$ paiements à chacun des taux d'intérêt
  effectifs annuellement $i = 0,05, 0,06, \dots, 0,10$.
  \begin{sol}
<<echo=TRUE>>=
n <- 1:10
i <- seq(0.05, 0.1, by = 0.01)
(1 - outer((1 + i), -n, "^"))/i
@
ou
<<echo=TRUE>>=
n <- 1:10
i <- (5:10)/100
apply(outer(1/(1 + i), n, "^"), 1, cumsum)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{exercice:application:moyennes}
  Étant donné un vecteur d'observations $\mat{x} = (x_1, \dots, x_n)$
  et un vecteur de poids correspondants $\mat{w} = (w_1, \dots, w_n)$,
  calculer la moyenne pondérée des observations,
  \begin{equation*}
    X_w = \sum_{i = 1}^n \frac{w_i}{w_\pt} x_i,
  \end{equation*}
  où $w_\pt = \sum_{i = 1}^n w_i$. Tester l'expression avec les vecteurs
  de données
  \begin{align*}
    \mat{x}
    &= (7, 13, 3, 8, 12, 12, 20, 11) \\
    \intertext{et} \mat{w}
    &= (0,15,\; 0,04,\; 0,05,\; 0,06,\; 0,17,\; 0,16,\; 0,11,\; 0,09).
  \end{align*}
  \begin{sol}
<<echo=TRUE>>=
x <- c(7, 13, 3, 8, 12, 12, 20, 11)
w <- c(0.15, 0.04, 0.05, 0.06, 0.17, 0.16, 0.11, 0.09)
sum(x * w)/sum(w)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Nous pouvons généraliser aux matrices et aux tableaux de données la
  définition de moyenne pondérée de
  l'\autoref{exercice:application:moyennes}.

  Dans le cas d'une matrice $n \times p$ d'observations $X_{ij}$ et
  poids $w_{ij}$ correspondant, on définit les moyennes pondérées
  suivantes:
  \begin{align*}
    X_{iw}
    &= \sum_{j = 1}^p \frac{w_{ij}}{w_{i\pt}}\, X_{ij}, \quad
    w_{i\pt} = \sum_{j = 1}^p w_{ij} \\
    X_{wj}
    &= \sum_{i = 1}^n \frac{w_{ij}}{w_{\pt j}}\, X_{ij}, \quad
    w_{\pt j} = \sum_{i = 1}^n w_{ij} \\
    \intertext{et}
    X_{ww}
    &= \sum_{i = 1}^n \sum_{j=1}^p \frac{w_{ij}}{w_{\pt\pt}}\, X_{ij}, \quad
    w_{\pt\pt} = \sum_{i = 1}^n \sum_{j = 1}^p w_{ij}.
  \end{align*}
  En suivant la même logique que ci-dessus, il est possible de définir
  des moyennes pondérées pour un tableau de données $X_{ijk}$ de
  dimensions $n \times p \times r$ et ses poids $w_{ijk}$
  correspondant.

  Écrire des expressions R pour calculer, sans boucle, les moyennes
  pondérées suivantes.
  \begin{enumerate}
  \item $X_{iw}$ en supposant une matrice de données $n \times p$.
  \item $X_{wj}$ en supposant une matrice de données $n \times p$.
  \item $X_{ww}$ en supposant une matrice de données $n \times p$.
  \item $X_{ijw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{iww}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{wjw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{www}$ en supposant un tableau de données $n \times p
    \times r$.
  \end{enumerate}
  \begin{sol}
    Soit \code{Xij} et \code{wij} des matrices, et \code{Xijk}
    et \code{wijk} des tableaux à trois dimensions.
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 1, sum)/apply(wij, 1, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
rowSums(Xij * wij)/rowSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 2, sum)/apply(wij, 2, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
colSums(Xij * wij)/colSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xij * wij)/sum(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, c(1, 2), sum) /
    apply(wijk, c(1, 2), sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 1, sum)/apply(wijk, 1, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 2, sum)/apply(wijk, 2, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xijk * wijk)/sum(wijk)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Générer les suites de nombres suivantes à l'aide d'expressions R.
  (Évidemment, il faut trouver un moyen de générer les suites sans
  simplement concaténer les différentes sous-suites.)
  \begin{enumerate}
  \item $0, 0, 1, 0, 1, 2, \dots, 0, 1, 2, 3, \dots, 10$.
  \item $10, 9, 8, \dots, 2, 1, 10, 9, 8, \dots 3, 2, \dots, 10, 9, 10$.
  \item $10, 9, 8, \dots, 2, 1, 9, 8, \dots, 2, 1, \dots, 2, 1, 1$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE>>=
unlist(lapply(0:10, seq, from = 0))
@
\item
<<echo=TRUE>>=
unlist(lapply(1:10, seq, from = 10))
@
\item
<<echo=TRUE>>=
unlist(lapply(10:1, seq, to = 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  La fonction de densité de probabilité et la fonction de répartition
  de la loi de Pareto de paramètres $\alpha$ et $\lambda$ sont,
  respectivement,
  \begin{align*}
    f(x)
    &= \frac{\alpha \lambda^\alpha}{(x + \lambda)^{\alpha + 1}} \\
    \intertext{et}
    F(x)
    &= 1 - \left( \frac{\lambda}{x + \lambda} \right)^\alpha.
  \end{align*}
  La fonction suivante simule un échantillon aléatoire de taille $n$
  issu d'une distribution de Pareto de paramètres
  $\alpha = \text{\texttt{shape}}$ et
  $\lambda = \text{\texttt{scale}}$:
\begin{Schunk}
\begin{Verbatim}
rpareto <- function(n, shape, scale)
    scale * (runif(n)^(-1/shape) - 1)
\end{Verbatim}
\end{Schunk}
  \begin{enumerate}
  \item Écrire une expression R utilisant la fonction \code{rpareto}
    ci-dessus qui permet de simuler cinq échantillons aléatoires de
    tailles $100$, $150$, $200$, $250$ et $300$ d'une loi de Pareto
    avec $\alpha = 2$ et $\lambda = \nombre{5000}$. Les échantillons
    aléatoires devraient être stockés dans une liste.
  \item Vous disposez de l'exemple suivant d'utilisation de la
    fonction \icode{paste}:
<<echo=TRUE>>=
paste("a", 1:5, sep = "")
@
    Nommer les éléments de la liste créée en a) \code{sample1},
    \code{sample2}, \dots, \code{sample5}.
  \item Calculer la moyenne de chacun des échantillons aléatoires
    obtenus en a). Retourner le résultat dans un vecteur.
  \item Évaluer la fonction de répartition de la loi de Pareto$(2,
    \nombre{5000})$ en chacune des valeurs de chacun des échantillons
    aléatoires obtenus en a). Retourner les valeurs de la fonction de
    répartition en ordre croissant.
  \item Ajouter $\nombre{1000}$ à toutes les valeurs de tous les
    échantillons simulés en a), ceci afin d'obtenir des observations
    d'une distribution de Pareto \emph{translatée}.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=FALSE>>=
library(actuar)
@
<<echo=TRUE>>=
x <- lapply(seq(100, 300, by = 50), rpareto,
            shape = 2, scale = 5000)
@
\item
<<echo=TRUE>>=
names(x) <- paste("sample", 1:5, sep = "")
@
\item
<<echo=TRUE>>=
sapply(x, mean)
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, function(x) sort(ppareto(x, 2, 5000)))
lapply(lapply(x, sort), ppareto,
       shape = 2, scale = 5000)
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, "+", 1000)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Une base de données contenant toutes les informations sur les
  assurés est stockée dans une liste de la façon suivante:
<<echo=FALSE>>=
library(actuar)
set.seed(1)
genere.assures <- function(nb.assures)
{
    tous.assures <- as.list(numeric(nb.assures))
    franchise <- sample(c(250, 500, 1000), nb.assures, replace = TRUE)
    moyennes <- sample(c(0.85, 1, 1.67), nb.assures, replace = TRUE)
    nb.annees <- sample(3:10, nb.assures, replace = TRUE)
    for (i in 1:nb.assures)
    {
        nb.sinistres <- rpois(nb.annees[i], moyennes[i])
        montants <- rpareto(sum(nb.sinistres), 2, 5000) + franchise[i]
        tous.assures[[i]] <- list(num.police = 1000+i, franchise = franchise[i],
                                  nb.acc = nb.sinistres, montants = montants)
    }
    tous.assures
}
x <- genere.assures(2)
@
<<echo=TRUE>>=
x[[1]]
x[[2]]
@ %
  Ainsi, \code{x[[i]]} contient les informations relatives à l'assuré
  $i$. Sans utiliser de boucles, écrire des expressions ou des fonctions
  R qui permettront de calculer les quantités suivantes.
  \begin{enumerate}
  \item La franchise moyenne dans le portefeuille.
  \item Le nombre annuel moyen de réclamations par assuré.
  \item Le nombre total de réclamations dans le portefeuille.
  \item Le montant moyen par accident dans le portefeuille.
  \item Le nombre d'assurés n'ayant eu aucune réclamation.
  \item Le nombre d'assurés ayant eu une seule réclamation dans leur
    première année.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
mean(sapply(x, function(liste) liste$franchise))
@
Les crochets utilisés pour l'indiçage constituent en fait un
opérateur dont le «nom» est \icode{[[}. Nous pouvons donc utiliser cet
opérateur dans la fonction \icode{sapply}.
<<echo=TRUE,eval=FALSE>>=
mean(sapply(x, "[[", "franchise"))
@
\item
<<echo=TRUE,eval=FALSE>>=
sapply(x, function(x) mean(x$nb.acc))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) sum(x$nb.acc)))
@
ou
<<echo=TRUE,eval=FALSE>>=
sum(unlist(sapply(x, "[[", "nb.acc")))
@
\item
<<echo=TRUE,eval=FALSE>>=
mean(unlist(lapply(x, "[[", "montants")))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) sum(x$nb.acc) == 0))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) x$nb.acc[1] == 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}


%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
