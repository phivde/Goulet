%%% Copyright (C) 2018 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Fonctions d'application}
\label{chap:application}

\def\scriptfilename{\currfilebase.R}
<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Effectuer des sommaires sur des tableaux à l’aide de la fonction
  \code{apply}.
\item Réduire des vecteurs et des listes avec les fonctions
  \code{lapply}, \code{sapply} et \code{mapply}; comparer l'effet de
  ces fonctions.
\item Passer des valeurs à une fonction d'application via l’argument
  `\code{...}'.
\end{objectifs}

Nous savons déjà que certains types de calculs répétitifs sont
automatiquement pris en charge par le langage R via une couche
d'abstraction que nous avons appelée l'arithmétique vectorielle
(\autoref{sec:premiers:vecteurs:arithmetique}). Pour les autres cas,
le langage prévoit les boucles et autres %
\index{structure de contrôle}structures de contrôle
(\autoref{sec:fonctions:controle}). Or, à moins que le code ne soit
accompagné de commentaires très complets, la programmation par boucles
demande un certain effort de décryptage pour les humains.

Il s'avère qu'un large pan des calculs répétitifs peut être réduit à
quelques fonctions abstraites dites d'\emph{application}
(\emph{mapping}, un autre concept hérité du \index{Lisp}Lisp). Les
fonctions d'application permettent de masquer, par une couche
d'abstraction, les calculs répétitifs sur les dimensions des matrices
et des tableaux, ainsi que ceux sur les éléments d'un vecteur ou d'une
liste. De plus, elles se prêtent beaucoup plus naturellement à la
programmation vectorielle.


\section{Application pour les matrices et les tableaux}
\label{sec:application:apply}

Une matrice \code{x} contient le nombre de réclamations en assurance
dommages de trois entreprises pour les cinq dernières années.
<<echo=FALSE>>=
set.seed(1)
ncontracts <- 3
nyears <- 5
x <- matrix(rpois(ncontracts * nyears, rgamma(ncontracts, 1.5)),
            nrow = ncontracts)
@
<<echo=TRUE>>=
x
@

Une analyste souhaite connaitre le nombre total de réclamations par
entreprise, d'une part, et par année, d'autre part. Cela consiste à
calculer les sommes par ligne et par colonne de la matrice, dans
l'ordre. Or, aucun opérateur usuel de R ne permet d'effectuer
directement de tels calculs. Notre analyste pourrait s'en sortir en
écrivant des fonctions itératives pour effectuer les calculs.

<<echo=TRUE>>=
rowsum <- function(x)
{
    n <- nrow(x)
    res <- numeric(n)
    for (i in seq_len(n))
        res[i] <- sum(x[i, ])
    res
}
colsum <- function(x)
{
    n <- ncol(x)
    res <- numeric(n)
    for (j in seq_len(n))
        res[j] <- sum(x[, j])
    res
}
@
<<echo=TRUE>>=
rowsum(x)
colsum(x)
@

L'analyste devrait utiliser ce genre de procédure pour tout calcul de
sommaire par ligne ou par colonne d'une matrice. Pourtant, seule la
fonction de sommaire (\icode{sum} dans notre exemple) changerait d'une
fois à l'autre. En fait, ce que souhaite l'analyste, c'est pouvoir
facilement \emph{appliquer} une fonction quelconque sur l'une ou
l'autre des deux dimensions d'une matrice. C'est exactement ce que
permet de faire la fonction \icode{apply}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

La \capsule{https://youtu.be/12Uy8_SJQzA}{fonction \Icode{apply}}
s'utilise autant avec les matrices qu'avec les tableaux. Sa syntaxe
complète est la suivante:
\begin{Schunk}
\begin{Verbatim}
apply(X, MARGIN, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est une matrice ou un tableau.
\item \code{MARGIN} est un vecteur d'entiers contenant la ou les
  dimensions de la matrice ou du tableau sur lesquelles la fonction
  doit s'appliquer.
\item \code{FUN} est la fonction à appliquer sur la ou les dimensions.
  La fonction reçoit les sous-ensembles de \code{X} sans que ceux-ci
  ne soient nommés. Les règles habituelles d'évaluation d'un appel de
  fonction s'appliquent: les données constituent le premier argument
  de \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\item `\code{...}' contient des arguments supplémentaires à passer à
  \code{FUN}, séparés par des virgules.
\end{itemize}

Le quatrième argument de \code{apply} est l'argument formel spécial
`\icode{...}' dont nous avons traité à la
\autoref{sec:fonctions:definition}. Il devient très utile, ici,
lorsque la fonction \code{FUN} prend plus d'un argument.

Pour illustrer, reprenons l'exemple précédent en supposant maintenant
que les entreprises n'ont pas toutes cinq années de données.
<<echo=FALSE>>=
x[1, c(4, 5)] <- NA
x[2, c(1, 2)] <- NA
x[3, 5] <- NA
@
<<echo=TRUE>>=
x
@

Si l'analyste a recours aux mêmes expressions que ci-dessus pour
calculer les sommaires par ligne et par colonne, elle obtiendra des
résultats sans grand intérêt puisque, comme on le sait, tout calcul
avec des données manquantes retourne la valeur \code{NA}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

Fort heureusement, la fonction \code{sum} possède un argument
\code{na.rm} qui indique de supprimer les données manquantes avant
d'effectuer la somme. L'analyste spécifie donc cet argument de la
fonction \code{sum} dans l'argument `\icode{...}' de \code{apply}.
<<echo=TRUE>>=
apply(x, 1, sum, na.rm = TRUE)
apply(x, 2, sum, na.rm = TRUE)
@

\tipbox{Les sommaires les plus usuels pour les matrices sont la somme
  et la moyenne, par ligne et par colonne. Les fonctions
  \icode{rowSums}, \icode{colSums}, \icode{rowMeans} et
  \icode{colMeans} permettent de calculer plus directement ces
  sommaires.}

Lorsque l'on applique une fonction à un tableau à plus de deux
dimensions, l'objet passé à la fonction peut s'avérer être une matrice
ou un tableau, selon le contenu de l'argument \code{MARGIN}. Par
exemple, si \code{X} est un tableau à trois dimensions et que la
longueur de \code{MARGIN} est $1$, on applique \code{FUN} sur les
«tranches» de \code{X} (des matrices). Si la longueur de \code{MARGIN}
est $2$, on applique plutôt \code{FUN} à des «carottes» tirées de
\code{X} (des vecteurs).

Nous allons illustrer ces propos à partir du tableau
$3 \times 4 \times 2$ ci-dessous.
<<echo=FALSE>>=
x <- array(sample(0:10, 24, rep = TRUE), c(3, 4, 2))
@
<<echo=TRUE>>=
x
@

Les expressions suivantes calculent, dans l'ordre:
\begin{enumerate}
\item les sommes des trois tranches horizontales (de l'avant vers
  l'arrière) dans le tableau;
\item les sommes des quatre tranches verticales (du haut vers le bas);
\item les sommes des deux tranches transversales (de la gauche vers la
  droite);
\item les sommes des douze carottes horizontales;
\item les sommes des huit carottes verticales.
\item les sommes des six carottes transversales;
\end{enumerate}
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
apply(x, 3, sum)
apply(x, c(1, 2), sum)
apply(x, c(2, 3), sum)
apply(x, c(1, 3), sum)
@

\tipbox{Truc mnémotechnique: la ou les dimensions figurant dans
  l'argument \code{MARGIN} sont celles retenues par le passage de
  \icode{apply}. En d'autres termes, les dimensions du résultat de
  \code{apply} sont \code{dim(X)[\code{MARGIN}]}.}

\gotorbox{Étudiez les lignes \reflines{application:apply}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:application:exemples}.}


\section{Application pour les listes et les vecteurs}
\label{sec:application:lapply}

Les idées de la sous-section précédente se transposent sans mal aux
listes et aux vecteurs. En effet, il n'y a pas d'arithmétique
vectorielle qui tienne pour les listes. Pour effectuer une opération
sur chaque élément d'une liste, il faut utiliser une procédure
itérative, procédure que R masque avec des fonctions d'application.

La fonction d'application de base pour les listes et les vecteurs est
\Icode{lapply}. Elle applique une fonction \code{FUN} à tous les
éléments d'un vecteur ou d'une liste \code{X} et retourne le résultat
sous forme de liste. La syntaxe de \code{lapply} est similaire à celle
de \icode{apply}, l'argument \code{MARGIN} en moins:
\begin{Schunk}
\begin{Verbatim}
lapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur ou une liste.
\item \code{FUN} est la fonction à appliquer à chacun des éléments de
  \code{X}. Ceux-ci ne sont pas nommés lorsqu'ils sont passés à la
  fonction. Les règles habituelles d'évaluation d'un appel de fonction
  s'appliquent: les données constituent le premier argument de
  \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\end{itemize}

Nous avons déjà rencontré la fonction \icode{sample} qui permet de
tirer un échantillon aléatoire parmi un ensemble de valeurs. Le
premier argument de \code{sample} est \code{x}, l'ensemble de valeurs.
Le second argument est \code{size}, la taille de l'échantillon. Les
expressions ci-dessous permettent de créer une liste formée de quatre
vecteurs aléatoires de taille $5$, $6$, $7$ et $8$; de calculer la
somme de chacun de ces vecteurs; de trier chacun des vecteurs.
<<echo=TRUE>>=
(x <- lapply(5:8, sample, x = 1:10))
lapply(x, sum)
lapply(x, sort)
@

Sœur siamoise de \code{lapply}, la fonction \Icode{sapply} retourne,
lorsque c'est possible, son résultat sous forme de vecteur ou de
matrice. Le résultat est donc \emph{simplifié} par rapport à celui de
\code{lapply}, d'où le nom de la fonction. La syntaxe en change pas:
\begin{Schunk}
\begin{Verbatim}
sapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item Si les résultats de l'application sont tous des vecteurs de
  longueur $1$, alors \code{sapply} retourne un vecteur.
\item Si les résultats de l'application sont des vecteurs de la même
  longueur supérieure à $a$, alors \code{sapply} retourne une
  matrice, remplie comme toujours par colonne.
\item Si les résultats de l'application sont des vecteurs de longueurs
  différentes, alors \code{sapply} est identique à \code{lapply}.
\end{itemize}
<<echo=TRUE>>=
(x <- lapply(rep(5, 3), sample, x = 1:10))
sapply(x, sum)
sapply(x, sort)
@

\tipbox{La fonction \icode{sapply} est souvent utile pour rendre
  vectorielle une fonction \code{f} qui ne le serait pas autrement. Il
  y a deux stratégies possibles: appliquer la fonction \code{f} à un
  vecteur avec \code{sapply}, ou modifier \code{f} pour y intégrer un
  appel à \code{sapply}.}

\importantbox{Dans un grand nombre de cas, il est possible de
  remplacer les boucles \icode{for} par des applications avec
  \icode{lapply} ou \icode{sapply}. On ne saurait donc trop insister
  sur l'importance de ces deux fonctions.}

Autre membre de la famille des fonctions d'application sur les listes
et les vecteurs, \Icode{mapply} est une version multidimensionnelle de
\code{sapply}. Sa syntaxe est, pour l'essentiel:
\begin{Schunk}
\begin{Verbatim}
mapply(FUN, ...)
\end{Verbatim}
\end{Schunk}
Le résultat de \code{mapply} est l'application de la fonction
\code{FUN} aux premiers éléments de tous les arguments contenus dans
`\code{...}', puis à tous les seconds éléments, et ainsi de suite.

Ainsi, si \code{v} et \code{w} sont des vecteurs, \code{mapply(FUN, v,
  w)} retourne sous forme de liste, de vecteur ou de matrice, selon le
cas, \code{FUN(v[1], w[1])}, \code{FUN(v[2], w[2])}, etc.


\section{Application pour les groupes de données}
\label{sec:application:tapply}

La fonction \Icode{tapply} applique une fonction à chacun des groupes
de données définis par les catégories d'un facteur ou d'une
combinaison de facteurs. Pour mieux comprendre, étudions la syntaxe de
la fonction:
\begin{Schunk}
\begin{Verbatim}
tapply(X, INDEX, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur.
\item \code{INDEX} est un facteur ou une liste de facteurs, chacun de la
  même longueur que \code{X}.
\item \code{FUN} est la fonction à appliquer à chacun des groupes de
  données définis par les catégories des facteurs dans \code{INDEX}.
\end{itemize}
<<echo=TRUE>>=
x <- data.frame(couleur=c("r", "v", "r", "r", "v"),
                score=c(2, 0, 4, 3, 10))
str(x)
tapply(x$score, x$couleur, mean)
@

\gotorbox{Étudiez les lignes \reflines{application:lstapply}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:application:exemples}.}


\section{Produit extérieur}
\label{sec:application:outer}

J'étire quelque peu le concept de fonction d'application pour
discuter ici de la fonction de produit extérieur \code{outer}. Ce
n'est pas la fonction la plus intuitive à utiliser, mais elle s'avère
extrêmement utile pour effectuer plusieurs opérations en une seule
expression tout en masquant les boucles implicites.

La \capsule{https://youtu.be/cyPUAnieWHw}{fonction \Icode{outer}}
calcule le \index{produit!extérieur}produit extérieur entre deux
vecteurs, c'est à dire le résultat de \code{FUN(X[i], Y[j])} pour
toutes les valeurs des indices \code{i} et \code{j}. La syntaxe de la
fonction est la suivante:
\begin{Schunk}
\begin{Verbatim}
outer(X, Y, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} et \code{Y} sont deux objets, normalement des vecteurs
  ou des matrices.
\item \code{FUN} est la fonction à appliquer (\code{"*"} par défaut)
  entre chacun des éléments de \code{X} et chacun des éléments de
  \code{Y}. Lorsque \code{FUN} est un opérateur arithmétique du
  \autoref{tab:premiers:operateurs}, il faut placer le symbole entre
  guillemets: \code{"*"}, \code{"+"}, \code{"<="}, etc.
\end{itemize}
La dimension du résultat de \code{outer} est \code{c(dim(X), dim(Y))}.
<<echo=TRUE>>=
outer(c(1, 2, 5), c(2, 3, 6))
@

L'opérateur \Icode{\%o\%} est un raccourci de \code{outer(X, Y, "*")}.

\gotorbox{Étudiez les lignes \reflines{application:outer}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:application:exemples}.}


\section{Exemples}
\label{sec:application:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:application:exercices}

\Opensolutionfile{solutions}[solutions-application]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:application}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:application}}

\end{Filesave}

\begin{exercice}
  Reprendre l'\autoref{ex:fonctions:prodmat} en utilisant cette fois
  une structure de contrôle \code{if ... else ...}, une seule boucle
  et une fonction d'application.
  \begin{sol}
    La solution ci-dessous satisfait les exigences du problème.
\begin{Schunk}
\begin{verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")

    res <- matrix(0, nrow = nrow(A),
                  ncol = ncol(B))
    for (i in seq_len(nrow(A)))
        res[i, ] <- apply(A[i, ] * B, 2, sum)
    res
}
\end{verbatim}
\end{Schunk}
    La solution bonus ci-dessous remplace entièrement la boucle par
    une fonction d'application \icode{sapply}. Elle a recours à la
    fonction \icode{t} de transposition d'une matrice.
\begin{Schunk}
\begin{verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")
    sapply(seq_len(ncol(B)),
           function(j) apply(t(A) * B[, j], 2, sum))
}
\end{verbatim}
\end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}
  La valeur actuelle d'une série de $n$ paiements de $1$ versés à la
  fin des années $1, 2, \dots, n$ à un taux d'intérêt $i$ effectif
  annuellement est
  \begin{equation*}
    a_\angln
    = v + v^2 + \dots + v^n
    = \frac{1 - v^n}{i},
  \end{equation*}
  où $v = (1 + i)^{-1}$. Calculer en une seule expression et
  \emph{sans boucle} un tableau des valeurs actuelles de séries de
  $n = 1, 2, \dots, 10$ paiements à chacun des taux d'intérêt
  effectifs annuellement $i = 0,05, 0,06, \dots, 0,10$.
  \begin{sol}
<<echo=TRUE>>=
n <- 1:10
i <- seq(0.05, 0.1, by = 0.01)
(1 - outer((1 + i), -n, "^"))/i
@
ou
<<echo=TRUE>>=
n <- 1:10
i <- (5:10)/100
apply(outer(1/(1 + i), n, "^"), 1, cumsum)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{exercice:application:moyennes}
  Étant donné un vecteur d'observations $\mat{x} = (x_1, \dots, x_n)$
  et un vecteur de poids correspondants $\mat{w} = (w_1, \dots, w_n)$,
  calculer la moyenne pondérée des observations,
  \begin{equation*}
    X_w = \sum_{i = 1}^n \frac{w_i}{w_\pt} x_i,
  \end{equation*}
  où $w_\pt = \sum_{i = 1}^n w_i$. Tester l'expression avec les vecteurs
  de données
  \begin{align*}
    \mat{x}
    &= (7, 13, 3, 8, 12, 12, 20, 11) \\
    \intertext{et} \mat{w}
    &= (0,15,\; 0,04,\; 0,05,\; 0,06,\; 0,17,\; 0,16,\; 0,11,\; 0,09).
  \end{align*}
  \begin{sol}
<<echo=TRUE>>=
x <- c(7, 13, 3, 8, 12, 12, 20, 11)
w <- c(0.15, 0.04, 0.05, 0.06, 0.17, 0.16, 0.11, 0.09)
sum(x * w)/sum(w)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Nous pouvons généraliser aux matrices et aux tableaux de données la
  définition de moyenne pondérée de
  l'\autoref{exercice:application:moyennes}.

  Dans le cas d'une matrice $n \times p$ d'observations $X_{ij}$ et
  poids $w_{ij}$ correspondant, on définit les moyennes pondérées
  suivantes:
  \begin{align*}
    X_{iw}
    &= \sum_{j = 1}^p \frac{w_{ij}}{w_{i\pt}}\, X_{ij}, \quad
    w_{i\pt} = \sum_{j = 1}^p w_{ij} \\
    X_{wj}
    &= \sum_{i = 1}^n \frac{w_{ij}}{w_{\pt j}}\, X_{ij}, \quad
    w_{\pt j} = \sum_{i = 1}^n w_{ij} \\
    \intertext{et}
    X_{ww}
    &= \sum_{i = 1}^n \sum_{j=1}^p \frac{w_{ij}}{w_{\pt\pt}}\, X_{ij}, \quad
    w_{\pt\pt} = \sum_{i = 1}^n \sum_{j = 1}^p w_{ij}.
  \end{align*}
  En suivant la même logique que ci-dessus, il est possible de définir
  des moyennes pondérées pour un tableau de données $X_{ijk}$ de
  dimensions $n \times p \times r$ et ses poids $w_{ijk}$
  correspondant.

  Écrire des expressions R pour calculer, sans boucle, les moyennes
  pondérées suivantes.
  \begin{enumerate}
  \item $X_{iw}$ en supposant une matrice de données $n \times p$.
  \item $X_{wj}$ en supposant une matrice de données $n \times p$.
  \item $X_{ww}$ en supposant une matrice de données $n \times p$.
  \item $X_{ijw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{iww}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{wjw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{www}$ en supposant un tableau de données $n \times p
    \times r$.
  \end{enumerate}
  \begin{sol}
    Soit \code{Xij} et \code{wij} des matrices, et \code{Xijk}
    et \code{wijk} des tableaux à trois dimensions.
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 1, sum)/apply(wij, 1, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
rowSums(Xij * wij)/rowSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 2, sum)/apply(wij, 2, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
colSums(Xij * wij)/colSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xij * wij)/sum(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, c(1, 2), sum) /
    apply(wijk, c(1, 2), sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 1, sum)/apply(wijk, 1, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 2, sum)/apply(wijk, 2, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xijk * wijk)/sum(wijk)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Générer les suites de nombres suivantes à l'aide d'expressions R.
  (Évidemment, il faut trouver un moyen de générer les suites sans
  simplement concaténer les différentes sous-suites.)
  \begin{enumerate}
  \item $0, 0, 1, 0, 1, 2, \dots, 0, 1, 2, 3, \dots, 10$.
  \item $10, 9, 8, \dots, 2, 1, 10, 9, 8, \dots 3, 2, \dots, 10, 9, 10$.
  \item $10, 9, 8, \dots, 2, 1, 9, 8, \dots, 2, 1, \dots, 2, 1, 1$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE>>=
unlist(lapply(0:10, seq, from = 0))
@
\item
<<echo=TRUE>>=
unlist(lapply(1:10, seq, from = 10))
@
\item
<<echo=TRUE>>=
unlist(lapply(10:1, seq, to = 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  La fonction de densité de probabilité et la fonction de répartition
  de la loi de Pareto de paramètres $\alpha$ et $\lambda$ sont,
  respectivement,
  \begin{align*}
    f(x)
    &= \frac{\alpha \lambda^\alpha}{(x + \lambda)^{\alpha + 1}} \\
    \intertext{et}
    F(x)
    &= 1 - \left( \frac{\lambda}{x + \lambda} \right)^\alpha.
  \end{align*}
  La fonction suivante simule un échantillon aléatoire de taille $n$
  issu d'une distribution de Pareto de paramètres
  $\alpha = \text{\texttt{shape}}$ et
  $\lambda = \text{\texttt{scale}}$:
\begin{Schunk}
\begin{Verbatim}
rpareto <- function(n, shape, scale)
    scale * (runif(n)^(-1/shape) - 1)
\end{Verbatim}
\end{Schunk}
  \begin{enumerate}
  \item Écrire une expression R utilisant la fonction \code{rpareto}
    ci-dessus qui permet de simuler cinq échantillons aléatoires de
    tailles $100$, $150$, $200$, $250$ et $300$ d'une loi de Pareto
    avec $\alpha = 2$ et $\lambda = \nombre{5000}$. Les échantillons
    aléatoires devraient être stockés dans une liste.
  \item Vous disposez de l'exemple suivant d'utilisation de la
    fonction \icode{paste}:
<<echo=TRUE>>=
paste("a", 1:5, sep = "")
@
    Nommer les éléments de la liste créée en a) \code{sample1},
    \code{sample2}, \dots, \code{sample5}.
  \item Calculer la moyenne de chacun des échantillons aléatoires
    obtenus en a). Retourner le résultat dans un vecteur.
  \item Évaluer la fonction de répartition de la loi de Pareto$(2,
    \nombre{5000})$ en chacune des valeurs de chacun des échantillons
    aléatoires obtenus en a). Retourner les valeurs de la fonction de
    répartition en ordre croissant.
  \item Ajouter $\nombre{1000}$ à toutes les valeurs de tous les
    échantillons simulés en a), ceci afin d'obtenir des observations
    d'une distribution de Pareto \emph{translatée}.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=FALSE>>=
library(actuar)
@
<<echo=TRUE>>=
x <- lapply(seq(100, 300, by = 50), rpareto,
            shape = 2, scale = 5000)
@
\item
<<echo=TRUE>>=
names(x) <- paste("sample", 1:5, sep = "")
@
\item
<<echo=TRUE>>=
sapply(x, mean)
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, function(x) sort(ppareto(x, 2, 5000)))
lapply(lapply(x, sort), ppareto,
       shape = 2, scale = 5000)
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, "+", 1000)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Une base de données contenant toutes les informations sur les
  assurés est stockée dans une liste de la façon suivante:
<<echo=FALSE>>=
library(actuar)
set.seed(1)
genere.assures <- function(nb.assures)
{
    tous.assures <- as.list(numeric(nb.assures))
    franchise <- sample(c(250, 500, 1000), nb.assures, replace = TRUE)
    moyennes <- sample(c(0.85, 1, 1.67), nb.assures, replace = TRUE)
    nb.annees <- sample(3:10, nb.assures, replace = TRUE)
    for (i in 1:nb.assures)
    {
        nb.sinistres <- rpois(nb.annees[i], moyennes[i])
        montants <- rpareto(sum(nb.sinistres), 2, 5000) + franchise[i]
        tous.assures[[i]] <- list(num.police = 1000+i, franchise = franchise[i],
                                  nb.acc = nb.sinistres, montants = montants)
    }
    tous.assures
}
x <- genere.assures(2)
@
<<echo=TRUE>>=
x[[1]]
x[[2]]
@ %
  Ainsi, \code{x[[i]]} contient les informations relatives à l'assuré
  $i$. Sans utiliser de boucles, écrire des expressions ou des fonctions
  R qui permettront de calculer les quantités suivantes.
  \begin{enumerate}
  \item La franchise moyenne dans le portefeuille.
  \item Le nombre annuel moyen de réclamations par assuré.
  \item Le nombre total de réclamations dans le portefeuille.
  \item Le montant moyen par accident dans le portefeuille.
  \item Le nombre d'assurés n'ayant eu aucune réclamation.
  \item Le nombre d'assurés ayant eu une seule réclamation dans leur
    première année.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
mean(sapply(x, function(liste) liste$franchise))
@
Les crochets utilisés pour l'indiçage constituent en fait un
opérateur dont le «nom» est \icode{[[}. Nous pouvons donc utiliser cet
opérateur dans la fonction \icode{sapply}.
<<echo=TRUE,eval=FALSE>>=
mean(sapply(x, "[[", "franchise"))
@
\item
<<echo=TRUE,eval=FALSE>>=
sapply(x, function(x) mean(x$nb.acc))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) sum(x$nb.acc)))
@
ou
<<echo=TRUE,eval=FALSE>>=
sum(unlist(sapply(x, "[[", "nb.acc")))
@
\item
<<echo=TRUE,eval=FALSE>>=
mean(unlist(lapply(x, "[[", "montants")))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) sum(x$nb.acc) == 0))
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(sapply(x, function(x) x$nb.acc[1] == 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}


%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
