%%% Copyright (C) 2021 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Tri et recherche}
\label{chap:tri}

\def\scriptfilename{\currfilebase.R}
\SweaveOpts{echo=FALSE}
\SweaveInput{share/license-by-sa.nw}

<<echo=FALSE, results=hide>>=
source(".Sweaveprofile")   # configuration
source("Stangle.R")        # lancement de Stangle
@
<<script>>=
<<license-by-sa>>
@

\begin{objectifs}
\item Expliquer les algorithmes classiques de tri et de recherche;
  comparer leurs avantages et inconvénients.
\item Concevoir une boucle itérative dans R.
\item Effectuer la mise en oeuvre d'un algorithme itératif dans le
  langage R.
\end{objectifs}

Nous nous sommes penchés sur le concept d'algorithme et sur les
principes de base de l'algorithmique au \autoref{chap:algorithmes}.
Or, \citet{Kernighan:practice:1999} font remarquer, fort à propos:
\begin{quote}
  Tous les programmes reposent sur des algorithmes et des structures
  de données, mais très peu de programmes exigent d'en concevoir de
  nouveaux.
\end{quote}
Autrement dit, aussi complexe soit-il, un programme repose souvent sur
quelques algorithmes fondamentaux bien connus et bien établis. À ce
titre, les algorithmes de tri et de recherche jouent un rôle
particulièrement important. Donald Knuth consacre d'ailleurs un volume
entier de son œuvre monumentale \emph{The Art of Computer Programming}
à ce seul sujet \citep{Knuth:ACP:vol3:1997}.

Dans l'introduction de son chapitre~5, Knuth rapporte que les grands
fabricants d'ordinateurs estimaient dès les années 1960 que 25~\% du
temps de calcul de leurs ordinateurs était consacré au tri! Dans
certaines applications, cela dépassait même la part de 50~\% du temps
de calcul. Selon Knuth, de telles statistiques signifient ou bien
qu'il existe plusieurs applications importantes du tri; ou bien que
plusieurs personnes trient sans que ça ne soit nécessaire; ou bien que
les algorithmes employés sont inefficaces. Il y a sans doute une part
de vérité dans chacune de ces hypothèses, mais le fait est que le tri
s'avère, d'un point de vue pratique, un sujet d'étude important.

Ce chapitre est consacré à l'étude des algorithmes classiques de tri
et de recherche. Ces opérations sont par nature répétitives.
Le sujet se prête donc bien à la revue des boucles itératives.


\section{Expérience de tri}
\label{sec:tri:experience}

Avant de vous lancer dans l'étude des algorithmes de tri, prenez le
temps de réaliser la petite expérience suivante:
\begin{quote}
  Choisir au hasard cinq cartes à jouer d'une même
  enseigne.\footnote{%
    Les quatre enseignes d'un jeu de carte de standard sont piques,
    cœurs, carreaux et trèfles.}%
  \textsuperscript{,}%
  \footnote{%
    Si vous n'avez pas de jeu de carte à portée de la main, une simple
    liste de nombres tirés aléatoirement de votre cerveau fertile et
    inscrits sur une feuille de papier fera l'affaire.} %
  Déterminer un algorithme ou une procédure pas à pas pour trier les
  cartes en ordre croissant. Comparer votre méthode de tri avec celles
  d'autres personnes de votre entourage\footnote{%
    À défaut d'entourage apte à trier des cartes, déterminer une ou
    deux autres procédures de tri de votre cru.}.
\end{quote}

Si vous en êtes à ce point sans avoir complété l'expérience, je vous
encourage à rebrousser chemin. L'expérience en vaut le coup pour la
suite.

La procédure de tri que vous avez utilisée est fort probablement de
l'un ou l'autre des types suivants
\citep[section~5.2]{Knuth:ACP:vol3:1997}:
\begin{enumerate}[i)]
\item tri par insertion, où chaque carte de la main est évaluée tour à
  tour et placée au bon endroit dans la liste des cartes déjà triées;
\item tri par échange, où deux cartes qui ne sont pas dans le bon
  ordre sont échangées, le procédé étant répété tant et aussi
  longtemps que les cartes ne sont pas entièrement triées;
\item tri par sélection, où la plus petite carte est identifiée et
  placée au début de la main, puis la seconde plus grande, et ainsi de
  suite;
\item tri par dénombrement, où l'on compte le nombre de cartes plus
  petites qu'une carte donnée pour déterminer son rang dans la main
  triée;
\item tri par une méthode \emph{ad hoc} qui fonctionne pour une main
  de cinq cartes, mais qui ne saurait se généraliser à un problème de
  plus grande taille;
\item tri paresseux, qui consiste à ne pas faire l'expérience
  recommandée.
\end{enumerate}


\section{Algorithmes classiques}
\label{sec:tri:tri}

Pour l'étude des algorithmes classiques, je m'en remets à l'excellent
ouvrage \emph{Essential Algorithms} de
\citet{Stephens:algorithms:2013}. Rédigé dans un style clair et
direct, le manuscrit va juste assez loin pour nos besoins dans les
différentes notions, sans pour autant sacrifier les détails
importants. Bref, un juste équilibre entre «algorithmique pour les
nuls» et un livre plus théorique.

Je vous invite donc à étudier les chapitres suivants de \emph{Essential
Algorithms}:
\begin{itemize}
\item chapitre 6, pages 131--138, 145 (à partir de la section
  \emph{Quicksort})--148 et 156--160;
\item chapitre 7, pages 163--168;
\item chapitre 9, pages 185--193.
\end{itemize}

Quelques remarques pour vous aider dans votre lecture.
\begin{itemize}
\item Partout où vous lirez \emph{array}, pensez tout simplement à un
  vecteur dans R.
\item Tel que mentionné au chapitre~1 de
  \citet{Stephens:algorithms:2013}, l'auteur a pris le parti d'indicer
  les vecteurs comme dans plusieurs langages de programmation, soit de
  $0$ à $n - 1$ pour un vecteur de longueur $n$. Vous devrez adapter
  les algorithmes en conséquence pour la programmation en R où les
  vecteurs sont plutôt indicés de $1$ à $n$.
\item Le livre fait ici et là référence au concept de \emph{library}.
  Une bibliothèque (le nom en français) est une collection de
  fonctions ou de sous-programmes que l'on peut utiliser dans nos
  programmes. Certains langages de programmation sont constitués d'un
  noyau assez restreint auquel on ajoute plusieurs fonctionnalités
  standards (le tri ou la recherche, par exemple) par le biais de
  bibliothèques. C'est en partie le cas de R, mais le système de base
  contient déjà un grand nombre de fonctionnalités.
\end{itemize}

\section{Boucles itératives}
\label{sec:tri:boucles}

Comme nous l'avons déjà vu, il existe deux grandes manières de répéter
des calculs en programmation: par \index{iteration@itération}itération
ou par \index{recursion@récursion}récursion. La récursion est très
simple à mettre en œuvre dans un langage fonctionnel comme R puisqu'il
suffit de faire en sorte qu'une fonction s'invoque elle-même,
idéalement, dans R, avec la fonction \icode{Recall}
(\autoref{sec:bases:recursion}).

Une procédure itérative répète un bloc d'instructions, habituellement
avec un léger changement d'état, jusqu'à ce qu'un nombre de
répétitions soit atteint ou qu'une condition soit satisfaite. C'est ce
que l'on appelle communément une \emph{boucle} (\emph{loop}). La
présente section étudie les structures de contrôles itératives de R.
Elles sont de trois types: la boucle à contrôle par dénombrement
(boucle \code{for}), la boucle à précondition «tant que» (boucle
\code{while}) et la boucle à condition d'arrêt (boucle \code{repeat}).

\warningbox{Les boucles sont beaucoup moins utilisées dans R que dans
  la plupart des autres langages de programmation. Avant d'utiliser
  une boucle, demandez-vous si l'arithmétique vectorielle ou une
  fonction d'application ne pourrait faire le travail de manière plus
  claire et plus efficace.}

\subsection{Boucle à dénombrement}
\label{sec:tri:boucles:for}

La boucle à dénombrement \Icode{for} sert pour répéter une procédure
un nombre prédéterminé de fois. La syntaxe de la boucle \code{for} est
la suivante dans R:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
for (\meta{variable} in \meta{suite})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{variable} est un \emph{compteur} ou, plus spécifiquement,
  un \emph{itérateur} qui prend successivement les valeurs contenues
  dans \meta{suite}. La variable est habituellement --- mais pas
  nécessairement --- utilisée dans les calculs à l'intérieur de la
  boucle.
\item \meta{suite} est une expression dont le résultat est un vecteur
  (y compris une liste). À noter que le résultat n'a pas à être
  composé de nombres consécutifs, ni même de nombres, en fait.
\item \meta{expression} est le contenu de la boucle à proprement
  parler. L'itérateur \meta{variable} apparait habituellement dans
  l'\meta{expression}. Comme toujours, si le contenu est constitué de
  plusieurs expressions, elles doivent être regroupées dans des
  accolades \verb={ }=.
\end{itemize}

La fonction ci-dessous est une mise en œuvre de
l'\autoref{algo:algorithmes:factorielle-iterative} du calcul de la
factorielle qui utilise une boucle \icode{for}. Remarquez comment la
boucle n'est exécutée que pour $n \geq 2$ afin d'éviter d'effectuer le
produit $1 \times 1$ dans le calcul de $1!$.
\begin{Schunk}
\begin{Verbatim}
factorial <- function(n)
{
    p <- 1
    for (i in seq(from = 2, length.out = n - 1))
        p <- p * i
    p
}
\end{Verbatim}
\end{Schunk}

\subsection{Boucle à précondition}
\label{sec:tri:boucles:while}

La boucle à précondition \Icode{while} exécute une procédure tant
qu'une condition est satisfaite. La condition étant vérifiée avant
d'entrer dans la boucle, celle-ci peut ne jamais s'exécuter. La
syntaxe de la boucle \code{while} est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
while (\meta{condition})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{condition} est une expression dont le résultat est une
  valeur \code{TRUE} ou \code{FALSE} unique.
\item \meta{expression} est une expression ou un groupe d'expressions
  entre accolades \verb={ }= qui sont exécutées tant que la
  \meta{condition} est \code{TRUE}.
\end{itemize}

Vous avez déjà rencontré la structure «tant que» dans la version en
pseudocode de l'algorithme d'Euclide
(\autoref{algo:algorithmes:euclide:pseudo}). Voici la mise en œuvre
correspondante avec une boucle \icode{while}.
\begin{Schunk}
\begin{Verbatim}
PGCD <- function(m, n)
{
    while (n != 0)
    {
        r <- m %% n
        m <- n
        n <- r
    }
    m
}
\end{Verbatim}
\end{Schunk}

\subsection{Boucle à condition d'arrêt}
\label{sec:tri:boucles:repeat}

Plusieurs langages de programmation comportent une structure itérative
à postcondition «répéter, tant que» (boucle \code{do ... while}) ou
«répéter, jusqu'à ce que» (boucle \code{do ... until}), voire les
deux. Dans R, la boucle à postcondition prend plutôt la forme d'une
boucle à condition d'arrêt \Icode{repeat}. La syntaxe de cette boucle
est on ne peut plus simple:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
repeat
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{expression} est l'expression ou le groupe d'expressions à
  répéter. En pratique, pour éviter que la boucle ne se répète
  indéfiniment, l'\meta{expression} est toujours un groupe
  d'expressions comportant un test d'arrêt.
\end{itemize}

Le test d'arrêt d'une boucle \icode{repeat} utilise habituellement la
commande \icode{break} (\autoref{sec:tri:boucles:flux}) pour forcer
la sortie de la boucle. Puisque le test se trouve à l'intérieur de la
boucle --- généralement à ou vers la fin ---, une boucle \icode{repeat}
est toujours exécutée au moins une fois. C'est d'ailleurs la grande
différence entre une boucle \icode{while} et une boucle \icode{repeat}.

Le fichier de script du \autoref{chap:pratiques} propose une fonction
\code{sqrt} pour calculer la racine carrée d'un nombre par
approximations successives. Elle a recours à une boucle à précondition
\icode{while}. Voici une variante qui utilise plutôt une boucle à
critère d'arrêt \icode{repeat}.
\begin{Schunk}
\begin{Verbatim}
sqrt <- function(x)
{
    y <- 1
    repeat
    {
        y <- (y + x/y)/2
        if (abs(y^2 - x) < 0.001)
            break
    }
    y
}
\end{Verbatim}
\end{Schunk}

\subsection{Contrôle du flux}
\label{sec:tri:boucles:flux}

Les commandes de contrôle du flux permettent d'infléchir le
déroulement normal d'une boucle.

\begin{ttscript}{break}
\item[\Icode{break}] force la sortie de la boucle courante. La
  commande \code{break} peut être utilisée dans les boucles
  \icode{for} ou \icode{while}, mais elle est presque indissociable de
  la boucle \icode{repeat}, tel qu'illustré à la
  \autoref{sec:tri:boucles:repeat}.
\item[\Icode{next}] force le passage à la prochaine itération de la
  boucle \icode{for}, \icode{while} ou \icode{repeat}. Comme
  \icode{break}, la commande est généralement utilisée à l'intérieur
  d'une structure conditionnelle.
\end{ttscript}

\subsection{Syndrome de la plaque à biscuits}
\label{sec:tri:boucles:syndrome}

Il arrive souvent que les fonctions itératives calculent un à un les
éléments d'un vecteur. Une erreur fréquente consiste à utiliser une
construction comme celle-ci pour effectuer les calculs.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\+*]
...
x <- numeric(0)
for (i in seq_len(n))
    x <- c(x, \meta+calcul*)
...
\end{Verbatim}
\end{Schunk}

Le code ci-dessus est tout à fait valide. Pourquoi parler d'une
erreur, alors? Parce qu'il souffre du gros défaut suivant: la taille
du vecteur doit constamment augmenter pour stocker un résultat
additionnel.

Tentons une (autre) analogie alimentaire pour cette manière de
procéder. Pour ranger dans une boite des biscuits frais sortis du
four, vous prenez un premier biscuit et vous le rangez dans une boite
ne pouvant contenir qu'un seul biscuit. Au second biscuit, constatant
que le contenant n'est pas assez grand, vous sortez une boite pouvant
contenir deux biscuits, vous changez le premier biscuit de boite et
vous y rangez aussi le second biscuit. Au troisième biscuit, le petit
manège recommence, et ainsi de suite jusqu'à ce que le plateau de
biscuits soit épuisé. C'est ce que je nomme, non sans un sourire en
coin, le Syndrome de la plaque à
biscuits{\texttrademark}\index{syndrome@Syndrome de la plaque à
  biscuits}\index{biscuits|see{Syndrome de la plaque à biscuits}}.

Le manège décrit ci-dessus se reproduit à l'identique dans la mémoire
de l'ordinateur, l'odeur des biscuits chauds en moins. En effet, pour
ajouter des éléments à un vecteur, l'ordinateur doit allouer de la
nouvelle mémoire et déplacer les termes déjà sauvegardés avant de
pouvoir sauvegarder un terme additionnel. Vous aurez compris que vous
devriez absolument éviter de procéder ainsi lorsque c'est possible ---
et ça l'est la plupart du temps.

Quand vous savez quelle sera la longueur finale d'un objet, il vaut
mieux créer un contenant vide de la bonne longueur et le remplir par
la suite avec une construction comme ci-dessous.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\+*]
...
x <- numeric(n)
for (i in seq_len(n))
    x[i] <- \meta+calcul*
...
\end{Verbatim}
\end{Schunk}

\gotorbox{Les lignes \reflines{tri:boucles} du fichier de script
  \code{\scriptfilename} reproduit à la \autoref{sec:tri:exemples}
  proposent un exemple additionnel de fonction ayant recours à une
  boucle itérative.}

<<script, results=hide>>=
###
### BOUCLES ITÉRATIVES  `\labelline{tri:boucles}`
###

## Débutons par illustrer les boucles à dénombrement avec des
## boucles triviales qui ne font qu'afficher des valeurs à
## l'écran.
##
## La syntaxe de la déclaration d'une boucle 'for' dans R est
## la suivante:
##
##   for(<variable> in <suite>)
##
## La <variable> est un compteur (ou itérateur) et <suite> est
## une expression qui permet de créer un vecteur (ou une
## liste) des valeurs successives du compteur.
##
## Plus souvent qu'autrement, l'expression fait appel à une
## fonction de génération de suites de valeurs.
for (n in 1:10)
    print(n)

## Je recommande d'utiliser les fonctions 'seq_len' et
## 'seq_along', ou alors 'seq' avec l'argument 'length.out',
## afin de vous prémunir contre le risque de générer une suite
## non vide alors le nombre d'itérations de la bouche devrait
## être zéro.
##
## Voici un exemple où les deux approches sont équivalentes.
n <- 5
for (i in 1:n) print(i)        # approche avec ':'
for (i in seq_len(n)) print(i) # approche avec 'seq_len'

## Si le nombre d'itérations devait toutefois être nul,
## l'approche avec ':' ne donne pas le résultat escompté;
## celle avec 'seq_len', oui.
n <- 0
for (i in 1:n) print(i)        # deux itérations!
for (i in seq_len(n)) print(i) # aucune itération

## De manière équivalente, s'il faut répéter une boucle un
## nombre de fois égal à la longueur d'un vecteur déjà connu,
## la fonction 'seq_along' permet de générer la suite de
## valeurs de manière robuste.
x <- c(5, 32, 57, 42, 0)         # vecteur de longueur 5...
for (i in seq_along(x)) print(i) # ... 5 itérations
x <- numeric(0)                  # vecteur vide...
for (i in seq_along(x)) print(i) # ... 0 itération

## Il y a une petite subtilité avec les boucles 'for' à
## laquelle vous devez faire bien attention: la classe du
## vecteur (ou de la liste) créé par l'expression n'est PAS
## prise en compte.
##
## Vous rencontrerez ce cas si, par exemple, vous souhaitez
## itérer sur un vecteur de dates. Rappelez-vous: une date
## dans R n'est qu'un nombre entier «maquillé» pour être plus
## lisible lorsque présenté à l'écran. (Ce «maquillage» est
## fourni par la classe de l'objet.)
dates <- seq(as.Date("2042-05-09"), by = "+1 month",
             length.out = 6)
dates                      # objet maquillé
unclass(dates)             # sans classe, sans maquillage

## Si l'on essaie d'itérer sur un vecteur de dates, la classe
## (le maquillage) ne suit pas dans la boucle.
for (d in dates)
    print(d)

## Si vous devez utiliser les dates successives sous forme de
## chaines de caractères à l'intérieur de la boucle, vous
## pouvez soit indicer le vecteur de dates dans la boucle,
## soit «cacher» les dates à l'intérieur d'une liste.
for (i in seq_along(dates))
    print(dates[i])
for (d in as.list(dates))
    print(d)

## Passons maintenant aux boucles 'while' et 'repeat'.
##
## Nous allons illustrer leur utilisation avec la méthode
## numérique du point fixe. On dit qu'une valeur x est un
## «point fixe» d'une fonction f si cette valeur satisfait
## l'équation
##
##   x = f(x).
##
## La méthode numérique de recherche du point fixe d'une
## fonction f est simple et puissante: elle consiste à choisir
## une valeur de départ, puis à évaluer successivement f(x),
## f(f(x)), f(f(f(x))), ... jusqu'à ce que la valeur change
## «peu».
##
## L'algorithme est donc très simple:
##
## 1. Choisir une valeur de départ y.
## 2. Calculer x = f(y)
## 3. Si |x - y|/|x| >= e, poser y <- x et retourner à
##    l'étape 2.
## 4. Retourner x.
##
## Avant de poursuivre votre lecture, tentez d'identifier le
## meilleur type de boucle ('for', 'while' ou 'repeat') à
## utiliser pour programmer cet algorithme.

## La méthode de Newton du calcul de la racine carrée par
## approximations successives est un cas spécial de la méthode
## du point fixe. En effet, la racine carrée d'un nombre est
## la valeur positive de y satisfaisant l'équation y^2 = x.
## Cette équation peut se réécrire sous forme de point fixe
## ainsi:
##
##   y = (y + x/y)/2.
##
## Voici une nouvelle mise en oeuvre de la fonction 'sqrt' qui
## utilise la méthode du point fixe. Le critère d'arrêt y est
## exprimé non plus en fonction de l'écart entre 'y'^2 et 'x',
## mais plutôt en fonction de l'écart entre deux
## approximations successives. De plus, la valeur de départ et
## l'erreur d'approximation sont passées en argument à la
## fonction.
##
## Puisqu'il faut au minimum vérifier si la valeur initiale
## est un point fixe, nous utilisons une boucle 'repeat'.
sqrt <- function(x, start = 1, TOL = 1E-10)
{
    repeat
    {
        y <- (start + x/start)/2
        if (abs(y - start)/y < TOL)
            break
        start <- y
    }
    y
}

## Vérifions la validité de la fonction.
sqrt(9, 1)
sqrt(225, 1)
sqrt(3047, 50)

## Formidable. Toutefois, si nous voulions utiliser la méthode
## du point fixe pour résoudre une autre équation, il faudrait
## écrire une nouvelle fonction qui serait pour l'essentiel
## identique, sinon pour le calcul de la fonction
## (mathématique) f(x) pour laquelle nous cherchons le point
## fixe.
##
## Créons donc une fonction de point fixe générale qui prendra
## la fonction mathématique f(x) en argument.
fixed_point <- function(FUN, start, TOL = 1E-10)
{
    repeat
    {
        x <- FUN(start)
        if (abs(x - start)/x < TOL)
            break
        start <- x
    }
    x
}

## Nous pouvons ensuite écrire une nouvelle fonction 'sqrt'
## qui utilise 'fixed_point'. Nous y ajoutons un test de
## validité de l'argument, pour faire bonne mesure.
sqrt <- function(x)
{
    if (x < 0)
        stop("cannot compute square root of negative value")

    fixed_point(function(y) (y + x/y)/2, start = 1)
}

## Validation. Nous obtenons les mêmes résultats que
## précédemment.
sqrt(9)
sqrt(25)
sqrt(3047)

## Suppression de la fonction pour éviter qu'elle n'entre en
## conflit avec celle de R.
rm("sqrt")

## SYNDROME DE LA PLAQUE À BISCUITS

## La fonction ci-dessous calcule les 'nterm' premiers termes
## de la suite de Fibonacci. Elle souffre toutefois du
## Syndrome de la plaque à biscuits. (Identifiez pourquoi.)
fibonacci0 <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- c(0, 1)
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}

## Validation de la fonction
fibonacci0(1)
fibonacci0(2)
fibonacci0(5)

## Une seconde version de la fonction prend garde de d'abord
## créer un vecteur de la bonne longueur pour stocker tous les
## résultats, puis de le remplir graduellement. (Le premier
## terme du vecteur est déjà 0 suite à l'initialisation avec
## 'numeric'.)
fibonacci <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- numeric(nterm)
    x[2] <- 1
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}

## Validation de la fonction
fibonacci(1)
fibonacci(2)
fibonacci(5)

## Avons-nous vraiment gagné en efficacité? En comparant le
## temps requis pour calculer plusieurs valeurs de la suite de
## Fibonacci pour chaque fonction, vous pourrez constater que
## la seconde version est entre trois et quatre fois plus
## rapide!
system.time(fibonacci0(1e6))
system.time(fibonacci(1e6))   #-*- `\labelline{tri:boucles:fin}`
@


\section{Fonctions internes utiles}
\label{sec:tri:internes}

Le tri et la recherche sont des opérations de base dans l'analyse de
données. Il ne faut donc pas se surprendre que R comporte des
fonctions internes pour ces opérations.

\subsection{Tri et opérations apparentées}
\label{sec:tri:internes:tri}

\begin{ttscript}{unique}
\item[\Icode{sort}] \index{tri}tri en ordre croissant ou
  décroissant.
<<echo=TRUE>>=
sort(c(4, -1, 2, 6))
@
\item[\Icode{rank}] \index{rang}rang des éléments d'un vecteur dans
  l'ordre croissant ou décroissant.
<<echo=TRUE>>=
rank(c(4, -1, 2, 6))
@
\item[\Icode{order}] \index{ordre}ordre d'extraction des éléments d'un
  vecteur pour les placer en ordre croissant ou décroissant.
<<echo=TRUE>>=
order(c(4, -1, 2, 6))
@
\item[\Icode{rev}] vecteur \index{renverser}renversé.
<<echo=TRUE>>=
rev(1:10)
@
\item[\Icode{unique}] éléments uniques d'un vecteur.
<<echo=TRUE>>=
unique(c(2, 4, 2, 5, 9, 5, 0))
@
\end{ttscript}

\videobox{\link{https://youtu.be/uC-zkzwsCVY}{Fonction \code{order}}}{%
  Visionnez la \link{https://youtu.be/uC-zkzwsCVY}{vidéo sur
    la fonction \icode{order}} qui explique plus en détail les
  différences entre les fonctions \icode{sort}, \icode{order} et \icode{rank}.}

\subsection{Recherche}
\label{sec:tri:internes:recherche}

Les exemples de cette sous-section utilisent le vecteur suivant.
<<echo=FALSE>>=
x <- c(4, -1, 2, -3, 6)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{which.max}
\item[\Icode{which}] positions des éléments satisfaisant la condition
  en argument.
<<echo=TRUE>>=
which(x < 0)
@
\item[\Icode{which.min}] position du \index{minimum!position}minimum.
<<echo=TRUE>>=
which.min(x)
@
\item[\Icode{which.max}] position du \index{maximum!position}maximum.
<<echo=TRUE>>=
which.max(x)
@
\item[\Icode{match}] position de la première occurrence d'un élément.
<<echo=TRUE>>=
match(2, x)
@
\item[\Icode{\%in\%}] appartenance d'une ou plusieurs valeurs au
  vecteur.
<<echo=TRUE>>=
-1:2 %in% x
@
\end{ttscript}


\section{Exemples}
\label{sec:tri:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:tri:exercices}

\Opensolutionfile{solutions}[solutions-tri]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:tri}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:tri}}

Nous allons tester nos fonctions avec des vecteurs aléatoires obtenus
avec la fonction \Icode{sample} qui tire un échantillon aléatoire
parmi des valeurs avec ou sans remise:
\begin{Schunk}
\begin{Verbatim}
sample(x, size, replace = FALSE)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{x} est un vecteur parmi lequel sera tiré l'échantillon;
\item \code{size} est la taille de l'échantillon;
\item \code{replace} est une valeur booléenne qui indique si
  l'échantillonnage doit s'effectuer avec ou sans remise.
\end{itemize}

\begingroup
%% modifications locales au style des listings
\lstset{%
  frame=single,
  numbers=none,
  basicstyle=\normalfont\ttfamily\NoAutoSpacing}

\end{Filesave}

\noindent%
Réaliser les mises en œuvre ci-dessous avec R.

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme
  \index{insertionsort}\emph{insertionsort}.
  \begin{sol}
    L'algorithme \index{insertionsort}\emph{insertionsort} déplace
    successivement les valeurs du vecteur vers l'avant dans leur
    position en ordre croissant, comme on le ferait avec des cartes.
    L'algorithme requiert deux boucles: une pour passer par toutes les
    valeurs du vecteur et une autre pour déterminer à quel endroit,
    parmi les valeurs déjà triées, chaque valeur doit se retrouver.

    La fonction \icode{insertionsort} de la
    \autoref{fig:tri:insertionsort} constitue une mise en
    œuvre de l'algorithme en R. L'expression à l'intérieur de la
    clause \icode{if} repositionne les éléments du vecteur dans le bon
    ordre.

    \begin{figure}
      \lstinputlisting{include/insertionsort.R}
      \caption{Mise en œuvre en R de l'algorithme
        \emph{insertionsort}}
      \label{fig:tri:insertionsort}
    \end{figure}

<<echo=FALSE>>=
source("include/insertionsort.R")
@
<<echo=TRUE>>=
(x <- sample(0:10, 7, replace = TRUE))
insertionsort(x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme
  \index{selectionsort}\emph{selectionsort}.
  \begin{sol}
    L'algorithme \emph{selectionsort} déplace graduellement vers
    l'avant la plus petite valeur du vecteur, la deuxième plus petite
    valeur, et ainsi de suite. Deux boucles sont encore nécessaires:
    une pour passer à travers toutes les positions du vecteur et une
    autre pour, à chaque itération de la première boucle, trouver le
    minimum dans les valeurs restantes du vecteur.

    La fonction \icode{selectionsort} de la
    \autoref{fig:tri:selectionsort} constitue une mise en
    œuvre de l'algorithme en R. Dans la majorité des langages de
    programmation, l'échange de deux éléments d'un vecteur nécessite
    une variable tampon (temporaire), comme ceci:
    \begin{Schunk}
\begin{Verbatim}
tmp <- x[i]
x[i] <- x[j]
x[j] <- tmp
\end{Verbatim}
    \end{Schunk}
    Vous remarquerez comment l'échange est facile à faire en R
    simplement par indiçage.

    \begin{figure}
      \lstinputlisting{include/selectionsort.R}
      \caption{Mise en œuvre en R de l'algorithme \emph{selectionsort}}
      \label{fig:tri:selectionsort}
    \end{figure}

<<echo=FALSE>>=
source("include/selectionsort.R")
@
<<echo=TRUE>>=
(x <- sample(0:10, 7, replace = TRUE))
selectionsort(x)
@

    La fonction \icode{which.min} retourne l'indice du minimum
    dans un vecteur. Nous pouvons l'utiliser pour éliminer la
    seconde boucle dans la mise en œuvre de la
    \autoref{fig:tri:selectionsort}; voir la fonction de la
    \autoref{fig:tri:selectionsort-which}.

    \begin{figure}
      \lstinputlisting{include/selectionsort-which.R}
      \caption{Mise en œuvre en R de l'algorithme \emph{selectionsort}
        utilisant la fonction \code{which.min}}
      \label{fig:tri:selectionsort-which}
    \end{figure}

<<echo=FALSE>>=
source("include/selectionsort-which.R")
@
<<echo=TRUE>>=
(x <- sample(0:10, 7, replace = TRUE))
selectionsort(x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme
  \index{bubblesort}\emph{bubblesort}.
  \begin{sol}
    L'algorithme \emph{bubblesort} fait graduellement «remonter à la
    surface» les plus petites valeurs du vecteur. Il faut comparer
    deux valeurs adjacentes tant que le vecteur n'est pas trié. Par
    nature, l'algorithme requiert deux boucles: une pour comparer les
    valeurs deux à deux, et une autre pour continuer le travail tant
    que le vecteur n'est pas trié.

    Une première version de la mise en œuvre, à la
    \autoref{fig:tri:bubblesort-while}, colle de près à
    l'algorithme de \citet{Stephens:algorithms:2013}.

    \begin{figure}
      \lstinputlisting{include/bubblesort-while.R}
      \caption{Mise en œuvre en R de l'algorithme \emph{bubblesort}}
      \label{fig:tri:bubblesort-while}
    \end{figure}

<<echo=FALSE>>=
source("include/bubblesort-while.R")
@
<<echo=TRUE>>=
(x <- sample(0:10, 7, replace = TRUE))
bubblesort(x)
@

    Dans la version de \icode{bubblesort} de la
    \autoref{fig:tri:bubblesort-while}, il faut changer la
    variable indicatrice \code{not\_sorted} plusieurs fois, dont une pour
    s'assurer d'effectuer la boucle \code{while} au moins une fois.

    Une seconde mise œuvre, à la
    \autoref{fig:tri:bubblesort-repeat}, est rendue plus facile à
    suivre par l'utilisation d'une boucle \code{repeat}, qui est
    toujours exécutée au moins une fois. Au passage, j'inverse
    également le rôle de la variable indicatrice pour éviter
    les déroutantes doubles négations.

    \begin{figure}
      \lstinputlisting{include/bubblesort-repeat.R}
      \caption{Mise en œuvre en R de l'algorithme \emph{bubblesort}
        utilisant une boucle \code{repeat}}
      \label{fig:tri:bubblesort-repeat}
    \end{figure}

<<echo=FALSE>>=
source("include/bubblesort-repeat.R")
@
<<echo=TRUE>>=
(x <- sample(0:10, 7, replace = TRUE))
bubblesort(x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme
  \index{countingsort}\emph{countingsort}.
  \begin{sol}
    L'algorithme \emph{countingsort} compte le nombre d'occurrences de
    chaque valeur dans le vecteur pour ensuite les retourner dans le
    bon ordre et le bon nombre de fois.

    La mise en œuvre d'une fonction \icode{countingsort} à
    la \autoref{fig:tri:countingsort} utilise une boucle
    pour passer à travers toutes les valeurs du vecteur. Elle est un
    peu plus générale que l'algorithme de
    \citet{Stephens:algorithms:2013} dans la mesure où elle fonctionne
    pour des nombres entre \code{min} et \code{max} plutôt que
    uniquement entre 0 et \code{max}. La clé ici pour éviter certaines
    boucles de l'algorithme: la fonction \icode{rep} qui permet de
    répéter les valeurs d'un vecteur autant de fois que nécessaire.

    \begin{figure}
      \lstinputlisting{include/countingsort.R}
      \caption{Mise en œuvre en R de l'algorithme \emph{countingsort}}
      \label{fig:tri:countingsort}
    \end{figure}
    \enlargethispage{5mm}

<<echo=FALSE>>=
source("include/countingsort.R")
@
<<echo=TRUE>>=
(x <- sample(10:20, 100, replace = TRUE))
countingsort(x, 10, 20)
@

    La seconde mise en œuvre, ci-dessous, triche un peu: elle
    a recours à la fonction \icode{table} de R qui retourne justement le
    tableau de fréquence de chaque valeur d'un vecteur.
    Résultat: plus de boucle! Cela dit, c'est un exercice bien
    artificiel puisque \code{table} elle-même trie les données\dots
<<echo=TRUE>>=
countingsort <- function(x, min, max)
    rep(min:max, table(x))
(x <- sample(10:20, 100, replace = TRUE))
countingsort(x, 10, 20)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme \emph{linear search}.
  \begin{sol}
    L'algorithme \emph{linear search} compare une à une les valeurs du
    vecteur à celle qui est recherchée. Ceci requiert une boucle.

    La fonction \icode{linsearch} présentée à la
    \autoref{fig:tri:linsearch} retourne \code{NA}
    plutôt que $-1$ lorsque la valeur n'est pas trouvée, comme c'est
    l'usage en R.

    \begin{figure}
      \lstinputlisting{include/linsearch.R}
      \caption{Mise en œuvre en R de l'algorithme
        \emph{linear search}}
      \label{fig:tri:linsearch}
    \end{figure}

<<echo=FALSE>>=
source("include/linsearch.R")
@
<<echo=TRUE>>=
x <- c(4, 5, 7, 9, 9, 11, 11, 12, 16, 19)
linsearch(7, x)
linsearch(10, x)
linsearch(21, x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre récursive de l'algorithme
  \emph{linear search}.
  \begin{sol}
    En version récursive, l'algorithme de recherche linéaire revient à
    vérifier si la valeur courante du vecteur est la valeur recherchée
    et, sinon, à recommencer le même processus à partir de la valeur
    suivante du vecteur.

    Je propose deux mises en œuvre. La première, à la
    \autoref{fig:tri:rlinsearch}, a recours à une fonction
    auxiliaire qui garde le compte de la progression dans le vecteur.
    Les règles de portée lexicale de R
    (\autoref{sec:environnement:portee}) font en sorte que nous
    n'avons pas à passer les variables \code{x}, \code{target} et
    \code{xlen} à la fonction auxiliaire.

    \begin{figure}
      \lstinputlisting{include/rlinsearch.R}
      \caption{Mise en œuvre récursive en R de l'algorithme
        \emph{linear search}}
      \label{fig:tri:rlinsearch}
    \end{figure}

<<echo=FALSE>>=
source("include/rlinsearch.R")
@
<<echo=TRUE>>=
x <- c(4, 5, 7, 9, 9, 11, 11, 12, 16, 19)
rlinsearch(7, x)
rlinsearch(10, x)
rlinsearch(21, x)
@

    La seconde mise en œuvre, à la
    \autoref{fig:tri:rlinsearch-na} est un peu plus simple,
    mais, comme la position de la valeur recherchée dans le vecteur
    est calculée, elle repose sur le fait que tout calcul avec
    \code{NA} retourne \code{NA}, ce qui ne constitue sans doute pas
    du bon style\dots

    \begin{figure}
      \lstinputlisting{include/rlinsearch-na.R}
      \caption{Mise en œuvre récursive en R de l'algorithme
        \emph{linear search} utilisant une propriété de la valeur
        \code{NA}}
      \label{fig:tri:rlinsearch-na}
    \end{figure}

<<echo=FALSE>>=
source("include/rlinsearch-na.R")
@
<<echo=TRUE>>=
x <- c(4, 5, 7, 9, 9, 11, 11, 12, 16, 19)
rlinsearch(7, x)
rlinsearch(10, x)
rlinsearch(21, x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme \emph{binary search}.
  \begin{sol}
    L'algorithme \emph{binary search} coupe en deux l'intervalle dans
    lequel la valeur recherchée pourrait se trouver jusqu'à ce qu'il
    ne reste que la valeur recherchée ou un intervalle vide, auquel
    cas la valeur ne se trouve pas dans le vecteur.

    Attention à une chose: dans l'algorithme de
    \citet{Stephens:algorithms:2013}, il est spécifié que le résultat
    du calcul $\text{mid} = (\min + \max)/2$ doit être un entier
    (\emph{integer}). Dans R, nous pouvons obtenir ce résultat avec
    \icode{as.integer} ou, plus simplement, en calculant la partie
    entière du résultat avec \icode{floor}. C'est ce qu'utilise la
    fonction \icode{binsearch} de la
    \autoref{fig:tri:binsearch}.

    \begin{figure}
      \lstinputlisting{include/binsearch.R}
      \caption{Mise en œuvre en R de l'algorithme
        \emph{binary search}}
      \label{fig:tri:binsearch}
    \end{figure}

<<echo=FALSE>>=
source("include/binsearch.R")
@
<<echo=TRUE>>=
x <- c(4, 5, 7, 9, 9, 11, 11, 12, 16, 19)
binsearch(7, x)
binsearch(10, x)
binsearch(21, x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre récursive de l'algorithme
  \emph{binary search}.
  \begin{sol}
    La mise en œuvre récursive la plus simple de l'algorithme
    \emph{binary search}, à la figure
    \autoref{fig:tri:rbinsearch}, utilise une fonction
    auxiliaire. Remarquez comment une fonction récursive (\code{fun}
    dans le cas présent) doit toujours --- normalement dès le départ
    --- contenir un critère d'arrêt des récursions. Autrement, le
    processus se répète à l'infini.

    \begin{figure}
      \lstinputlisting{include/rbinsearch.R}
      \caption{Mise en œuvre récursive en R de l'algorithme
        \emph{binary search}}
      \label{fig:tri:rbinsearch}
    \end{figure}

<<echo=FALSE>>=
source("include/rbinsearch.R")
@
<<echo=TRUE>>=
x <- c(4, 5, 7, 9, 9, 11, 11, 12, 16, 19)
rbinsearch(7, x)
rbinsearch(10, x)
rbinsearch(21, x)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre récursive de la fonction
  factorielle.
  \begin{sol}
    Voir la \autoref{fig:presentation:scheme_vs_s}.
<<echo=TRUE>>=
factorial(0)
factorial(1)
factorial(5)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre récursive de la suite de Fibonacci.
  \begin{sol}
    L'algorithme de base pour calculer un élément de la suite
    de Fibonnacci de manière récursive est très lent parce que
    plusieurs valeurs sont calculées à de multiples reprises.
<<echo=TRUE>>=
fib <- function(n)
    if (n <= 1) n else fib(n - 1) + fib(n - 2)
fib(0)
fib(1)
fib(2)
fib(5)
fib(10)
# fib(30)            # déjà lent
# fib(35)            # long
# fib(40)            # à vos risques et périls
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme \emph{Bucketsort} de
  \citet[chapitre~6]{Stephens:algorithms:2013} permettant de trier des
  entiers entre $1$ et $x_{\max}$. La fonction prend en argument le
  vecteur des données à trier, la valeur de $x_{\max}$ et le nombre de
  compartiments. Utiliser la fonction \icode{sort} pour trier les
  compartiments.

  \begin{sol}
    La principale difficulté réside dans le fait que certains
    compartiments peuvent demeurer vides (\code{NULL}). Or,
    \icode{sort} ne peut prendre \code{NULL} en argument. Il faut donc
    faire un test avant de trier les données.
<<echo=TRUE, eval=FALSE>>=
bucketsort <- function(x, max, nbuckets)
{
    ## création des compartiments
    buck <- vector("list", nbuckets)
    span <- max/nbuckets

    ## répartition des données dans les compartiments
    for (i in seq_along(x))
    {
        j <- ceiling(x[i]/span)
        buck[[j]] <- c(buck[[j]], x[i])
    }

    ## tri des données dans chaque compartiment; on
    ## effectue le tri seulement s'il y a des données
    ## dans le compartiment
    for (i in seq_len(nbuckets))
        if (!is.null(buck[[i]]))
            buck[[i]] <- sort(buck[[i]])

    ## retourner le vecteur trié
    unlist(buck)
}
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{ex:tri:100metres}
  Le fichier \code{100metres.dat} distribué avec cet ouvrage contient
  la date et le temps des 31 meilleurs résultats enregistrés au
  100~mètres homme entre 1964 et 2005. Les dates se trouvent dans la
  première colonne du fichier et les temps, dans la seconde. Les
  données sont reproduites au \autoref{tab:tri:100metres}.

  La commande \icode{scan} utilisée avec l'argument \code{what =
    list("", 1)} permet d'importer ces données dans R. Le résultat
  sera une liste de deux éléments: un vecteur de chaines de caractères
  contenant les dates des records; un vecteur numérique contenant
  les temps.

  Extraire du second vecteur de la liste les records du monde
  seulement, c'est-à-dire la première fois que chaque temps a été
  enregistré.
  \begin{table}
    \centering
    \caption{Données du fichier \code{100metres.dat}: records du monde
      au 100~mètres homme entre 1964 et 2005}
    \label{tab:tri:100metres}
    %% https://tex.stackexchange.com/a/9205
    \newcolumntype{C}{>{\FormatNo} c }
    \def\FormatNo\ignorespaces#1\\{%
      \ignorespaces\makebox[\widthof{00,00}][r]{#1}\tabularnewline}
    \begin{tabular}{lC}
      \toprule
      \text{Date} & \multicolumn{1}{c}{Temps (sec.)} \\
      \midrule
<<echo=FALSE, results=tex>>=
x <- scan("100metres.dat", what = list("", 1))
cat(mapply(paste,
           x[[1]],
           "&",
           formatC(x[[2]], digits = 2, format = "f", dec = ","),
           "\\\\"))
@
      \bottomrule
    \end{tabular}
  \end{table}
  \begin{sol}
    D'abord, recréons le vecteur des temps à partir des données du
    fichier \code{100metres.dat}.
<<echo=TRUE, eval=TRUE>>=
x <- scan("100metres.dat", what = list("", 1))
temps <- x[[2]]
names(temps) <- x[[1]]
@
    Ensuite, nous pouvons identifier les premiers records en
    calculant les minimums cumulatifs avec \icode{cummin}, puis en
    conservant une seule occurrence de chaque temps. Une première
    expression retourne les temps, mais sans les dates.
<<echo=TRUE, eval=TRUE>>=
unique(cummin(temps))
@
    Nous pouvons récupérer les dates en retrouvant les records dans le
    vecteur.
<<echo=TRUE, eval=TRUE>>=
temps[match(unique(cummin(temps)), temps)]
@
  \end{sol}
\end{exercice}

\begin{Filesave}{solutions}
\endgroup                               % fin de \lstset local
\end{Filesave}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
