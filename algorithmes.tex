%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Algorithmes et algorithmique}
\label{chap:algorithmes}

\def\scriptfilename{\currfilebase.R}

\begin{objectifs}
\item Expliquer les algorithmes classiques de tri et de recherche;
  comparer leurs avantages et inconvénients.
\item Exprimer une méthode de résolution de problème sous la forme
  d'un algorithme à l'aide de pseudocode.
\item Effectuer la mise en oeuvre d'un algorithme donné dans le
  langage R.
\end{objectifs}

Marianne et Alexandre doivent fournir une solution logicielle à un
problème donné. Sitôt la lecture de l'énoncé du problème complétée,
ils se précipitent sur le clavier pour coder leur solution. Rapidement
bloqués, pensant qu'ils butent sur un problème de syntaxe ou
d'utilisation d'une fonction, ils demandent de l'aide. Lorsqu'on leur
demande qu'est-ce qu'ils essaient de faire, quelle est la nature de leur
solution, ils ne peuvent répondre que par un long silence.

Dans mon rôle de professeur, j'ai été témoin de la scène ci-dessus à
de nombreuses reprises. Marianne et Alexandre font une erreur commune
chez les programmeurs --- et pas que chez les débutants: commencer à
coder sans avoir au préalable suffisamment réfléchi à la solution. Il
leur manque un plan clair des étapes à suivre pour résoudre le
problème. Or, ce plan, ou la recette à suivre --- nous reviendrons sur
cette analogie culinaire dans la suite --- pour transformer les
entrants d'un problème en une solution, c'est l'algorithme. Travailler
sans algorithme, c'est comme naviguer sans boussole.

Si programmer requiert des algorithmes, l'étude de la programmation
doit donc nécessairement s'accompagner de notions de base
d'\index{algorithmique}algorithmique, la science qui étudie les
algorithmes et les structures de données. L'algorithmique est une
discipline riche en techniques ingénieuses et en analyses
mathématiques poussées. Connaitre ses principes de base et étudier
certains algorithmes classiques vous permettra de mieux planifier vos
méthodes de résolution de problème. En effet, un bon algorithme permet
de résoudre en quelques secondes un problème qui pourrait autrement
prendre des années.

L'étude des algorithmes s'accompagne habituellement de celle des
structures de données ou, en d'autres termes, de la manière
d'organiser les données dans un ordinateur. Comme nous le verrons au
\autoref{chap:donnees}, il existe bien différentes structures de
données en R, mais leur réelle mise en œuvre demeure tout à fait
transparente pour les programmeuses et les programmeurs. C'est
pourquoi nous ferons l'impasse sur des notions que l'on retrouve dans
tous les ouvrages classiques d'algorithmique, comme le tableau
(\emph{array}), la liste chainée (\emph{list}), l'arbre (\emph{tree})
ou la table de hachage (\emph{hashtable}).

Le présent chapitre est inspiré de \citet{Sussman:scheme:1996},
\citet{Knuth:ACP:vol1:1997} et \citet{Stephens:algorithms:2013}. Ce
dernier, en particulier propose une excellente introduction aux
notions d'algorithmique rédigée dans un style clair et direct.


\section{Définition et analogie}
\label{sec:algorithmes:definition}

Un \index{algorithme}\emph{algorithme} est une procédure de calcul
permettant de résoudre un problème bien spécifié. L'algorithme
explique, de manière non ambigüe et dans un nombre d'opérations fini,
comment, à partir d'entrants, obtenir l'extrant solution du problème.

Pour se mériter un algorithme, un problème doit renfermer une dose
minimale de complexité: personne n'écrit un algorithme pour extraire
le quatrième élément d'un vecteur de données. On suppose que cela fait
partie de la définition de vecteur et que vous savez comment effectuer
l'opération dès lors que vous connaissez le langage de programmation
sous-jacent.

Dans la même veine, un algorithme ne dépend pas du langage de
programmation employé car il fournit les étapes pour résoudre un
problème, non pas leur mise en œuvre. En d'autres termes, un
algorithme explique \emph{ce qu'il faut faire} pour résoudre un
problème et non \emph{comment le faire}.

Illustrons le concept d'algorithme par l'un de ses plus illustres
représentants: l'\Index{Euclide@Euclide (algorithme)}algorithme
d'Euclide (c.~300 av. J.-C.), une procédure de calcul du plus grand
commun diviseur (PGCD) de deux nombres entiers $m$ et $n$.
L'algorithme repose sur l'idée que le PGCD de $m$ et $n$ est aussi le
PGCD de $n$ et du reste de la division de $m$ par $n$.

\begin{algorithme}[Algorithme d'Euclide]
  \label{algo:algorithmes:euclide}
  Calculer le plus grand commun diviseur de deux entiers positifs $m$
  et $n$ avec, sans perte de généralité, $n < m$.
  \begin{enumerate}
  \item Diviser $m$ par $n$ et poser $r$ égal au reste de la division.
    (Nous avons alors $0 \leq r < n$.)
  \item Si $r = 0$, retourner la valeur $n$.
  \item Poser $m \leftarrow n$ et $n \leftarrow r$, puis retourner à
    l'étape 1.
  \end{enumerate}
\end{algorithme}

Suivons les étapes de l'\index{Euclide@Euclide (algorithme)}algorithme
d'Euclide avec $m = 544$ et $n = 119$. À l'étape~1, nous déterminons
que $544/119 = 4 + 68/119$, donc nous posons $r \leftarrow 68$.
Puisque $r \neq 0$, l'étape~2 de l'algorithme ne s'applique pas. Nous
passons donc à l'étape~3 et nous posons $m \leftarrow 119$ et
$n \leftarrow 68$. De retour à l'étape~1, nous déterminons cette fois
que $r \leftarrow 51$, ce qui mène encore à l'étape~3 et
$m \leftarrow 68$ et $n \leftarrow 51$. Après un autre cycle, nous en
sommes à $m \leftarrow 51$ et $n \leftarrow 17$. Cette fois, nous
posons $r \leftarrow 0$ à l'étape~1 et la procédure s'arrête ensuite à
l'étape~2. Le plus grand commun diviseur de $544$ et $119$ est $17$.

Selon \citet[section~1.1]{Knuth:ACP:vol1:1997}, un algorithme devrait
réunir cinq caractéristiques.\footnote{%
  Liste adaptée de la version française fournie par
  \citet{Wikipedia:Algorithme}.}
\begin{enumerate}
\item \emph{Finitude}. Un algorithme doit toujours se terminer après
  un nombre fini d’étapes. Ce nombre peut toutefois devenir très
  grand.
\item \emph{Définition précise}. Chaque étape d'un algorithme doit
  être définie précisément; les actions à réaliser doivent être
  spécifiées rigoureusement et sans ambigüité pour chaque cas.
\item \emph{Entrées}. Un algorithme comporte aucune, une ou plusieurs
  \emph{entrées}, des quantités fournies à l'algorithme avant qu'il ne
  commence ou qui sont allouées dynamiquement durant son exécution.
  Ces entrées proviennent d'un ensemble d'objets bien spécifié. Par
  exemple, l'\autoref{algo:algorithmes:euclide} comporte deux entrées,
  les nombres $m$ et $n$, provenant de l'ensemble des entiers
  positifs.
\item \emph{Sorties}. Un algorithme comporte une ou plusieurs
  \emph{sorties}: des quantités ayant une relation spécifiée avec les
  entrées. L'\autoref{algo:algorithmes:euclide} a une seule sortie,
  soit la valeur $n$ de l'étape~2, le plus grand commun diviseur des
  entrées.
\item \emph{Efficacité}. On s'attend généralement d'un algorithme
  qu'il soit \emph{efficace} dans le sens où toutes les opérations
  qu'il doit accomplir sont suffisamment élémentaires pour pouvoir
  être en principe réalisées dans une durée finie par une personne
  munie de papier et d'un crayon.
\end{enumerate}

Pour bien comprendre la nature et la portée d'un algorithme, il est
assez utile de le comparer à une recette de cuisine. Dans une recette,
les entrées sont les ingrédients, la procédure les diverses étapes et
la sortie, le plat préparé.

Comme un algorithme, une recette repose sur un certain nombre
d'instructions élémentaires qui se passent d'explication, comme
saisir, mijoter, mélanger, etc. La recette est indépendante des
ustensiles utilisés comme l'algorithme l'est du langage de
programmation.

Surtout, surtout, une recette explique les étapes à suivre pour
obtenir le plat voulu, mais, sauf peut-être pour certaines opérations
plus délicates, elle n'explique pas \emph{comment} réaliser chaque
étape. S'il faut ajouter du lait dans un mélange à gateau, la recette
n'indique pas de sortir le lait du réfrigérateur, de vérifier la date
de péremption et de verser le lait dans la tasse à mesurer jusqu'à la
ligne correpondant à la quantité voulue. Un algorithme ne contient pas
plus d'instructions pour vérifier la validité des entrées ou pour
effectuer des opérations de base comme les opérations arithmétiques,
la lecture de données, l'indiçage d'un vecteur, etc.

En revanche, on s'attend généralement d'un algorithme, qui est destiné
à un ordinateur, qu'il soit plus précis qu'une recette. En effet, un
ordinateur éprouverait beaucoup de difficulté avec une instruction
comme «saler et poivrer au goût»!

\tipbox{C'est une erreur commune dans la rédaction d'un algorithme de
  fournir des détails de mise en œuvre superflus, de surcroit dans un
  langage de programmation bien précis. Lorsque vous écrirez un
  algorithme, demandez-vous si vous êtes en train d'expliquer comment
  mesurer une quantité de lait avec une tasse à mesurer de marque
  ACME.}


\section{Pseudocode}
\label{sec:algorithmes:pseudocode}

Puisqu'il s'agissait du premier exemple d'algorithme complet, j'ai
choisi de présenter l'\autoref{algo:algorithmes:euclide} dans un
format très près du langage naturel.

Une autre manière très populaire d'exprimer les algorithmes consiste à
utiliser du \index{pseudocode}\emph{pseudocode}, un «langage»
similaire à un langage de programmation, mais toujours sans référence
à un langage en particulier. L'écriture en pseudocode permet parfois
de mieux prendre la mesure de la structure et des détails d'un
algorithme avant d'en attaquer la mise en œuvre.

Il n'existe pas réellement de normes de composition pour le
pseudocode.

Voici de nouveau l'\index{Euclide@Euclide (algorithme)}algorithme
d'Euclide, présenté cette fois en pseudocode. Portez-y une attention
toute particulière puisqu'il ne s'agit pas d'une transcription directe
de l'\autoref{algo:algorithmes:euclide}. Vérifiez que les deux
versions de l'algorithme retournent bien le même résultat.

\begin{algorithme}[Algorithme d'Euclide, version en pseudocode]
  \label{algo:algorithmes:euclide:pseudo}
  Calculer le plus grand commun diviseur de deux entiers positifs $m$
  et $n$ avec, sans perte de généralité, $n < m$.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
PGCD(entier m, entier n)
  Tant que (n \neq 0)
    r \leftarrow m mod n
    m \leftarrow n
    n \leftarrow r
  Fin Tant que
  Retourner m
Fin PGCD
\end{Verbatim}
\end{Schunk}
\end{algorithme}

\tipbox{L'opération \index{modulo}modulo, notée en mathématiques
  $m \mod n$, représente le reste de la division de $m$ par $n$. Par
  exemple, tel que calculé précédemment, $544 \mod 119 = 68$.}

L'\autoref{algo:algorithmes:euclide:pseudo} reprend quelques unes des
conventions les plus usuelles pour le pseudocode.

La procédure de calcul faisant l'objet de l'algorithme est rédigée
sous forme d'une fonction\footnote{%
  C'est la terminologie de R. Une unité de code qui effectue un
  traitement donné porte divers noms selon le langage de
  programmation: fonction, routine, sous-routine, méthode, procédure,
  sous-procédure.}. %
L'algorithme débute par la \index{signature}\emph{signature} de la
fonction (son nom avec le nom et le type de tous les arguments). Le
code est indenté (décalé vers la droite) après la signature de la
fonction pour montrer qu'il fait partie du corps de la fonction.

Le bloc délimité par les instructions \code{Tant que
  (\meta{condition})} et \code{Fin Tant que} forme une
\index{boucle}\emph{boucle} dont le contenu --- lui aussi indenté ---
est exécuté tant et aussi longtemps que la \meta{condition} est vraie.

L'instruction \code{Retourner} met immédiatement fin à la fonction,
ici en retournant la valeur \code{m}.

Enfin, on présente le pseudocode comme du code informatique dans une
police non proportionnelle qui préserve l'alignement vertical des
caractères.


\section{Évaluation conditionnelle}
\label{sec:algorithmes:if-else}

Plusieurs algorithmes, même les plus simples, nécessitent de pouvoir
effectuer des opérations différentes selon le résultat d'un test. Par
exemple, pour effectuer le banal calcul de la valeur absolue d'un
nombre, nous devons vérifier si le nombre est positif, négatif ou nul
pour retourner un résultat différent en fonction de la règle suivante:
\begin{equation*}
  \lvert x \rvert =
  \begin{cases}
    x, & \text{si } x > 0 \\
    0, & \text{si } x = 0 \\
    -x, & \text{si } x < 0.
  \end{cases}
\end{equation*}

De telles constructions requièrent des \emph{instructions
  conditionnelles} qui permettent d'effectuer différents calculs selon
le résultat d'une condition booléenne (vraie ou fausse). Il en existe
quatre grands types.

\begin{itemize}
\item Les instructions conditionnelles à un volet de la forme
  \begin{quote}
    Si \meta{condition}, alors \meta{conséquence}
  \end{quote}
  Dans cette construction, la \meta{conséquence} est évaluée seulement
  lorsque la \meta{condition} est vraie. Dans le cas contraire, il ne
  se passe rien et le déroulement de l'algorithme se poursuit
  normalement. Nous avons utilisé une telle instruction conditionnelle
  à l'étape~2 de l'\autoref{algo:algorithmes:euclide}. La locution
  «alors» est souvent omise dans les algorithmes comme, d'ailleurs,
  dans la syntaxe de plusieurs langages de programmation.
\item Les instructions conditionnelles à deux volets de la forme
  \begin{quote}
    Si \meta{condition}, alors \meta{conséquence}, \\
    sinon \meta{alternative}
  \end{quote}
  Cette construction permet d'effectuer un choix entre deux actions:
  ou bien la \meta{condition} est vraie et la \meta{conséquence} est
  évaluée, ou bien la \meta{condition} est fausse et c'est alors
  l'\meta{alternative} qui est évaluée. Le déroulement de l'algorithme
  se poursuit après l'exécution de l'une ou l'autre des deux actions.
\item Les instructions conditionnelles imbriquées de la forme
  \begin{quote}
    Si \meta{condition$_1$}, alors \meta{conséquence$_1$}, \\
    sinon si \meta{condition$_2$}, alors \meta{conséquence$_2$}, \\
    sinon \meta{alternative}
  \end{quote}
  Une instruction conditionnelle imbriquée permet de choisir entre
  trois actions: la \meta{conséquence$_1$} est évaluée lorsque la
  \meta{condition$_1$} est vraie; la \meta{conséquence$_2$} est évaluée
  lorsque la \meta{condition$_1$} est fausse et que la
  \meta{condition$_2$} est vraie; l'\meta{alternative} est évaluée
  lorsque la \meta{condition$_1$} et la \meta{condition$_2$} sont toutes
  les deux fausses. Pour choisir entre plus de trois actions
  possibles, il suffit d'ajouter des clauses «sinon si\dots, alors\dots».
\item Une variante de l'instruction précédente qui facilite la lecture
  lorsqu'il y a un grand nombre d'actions possibles:
  \begin{quote}
    Selon que \\
    \meta{condition$_1$}, alors \meta{action$_1$}; \\
    \meta{condition$_2$}, alors \meta{action$_2$}; \\
    \meta{condition$_3$}, alors \meta{action$_3$}; \\
    \dots \\
    autrement, \meta{action par défaut}
  \end{quote}
  Seule l'\meta{action} correspondant à la \meta{condition} vraie est
  exécutée. Si aucune \meta{condition} n'est vraie, c'est
  l'\meta{action par défaut} qui est exécutée. La terminologie
  française que j'utilise ci-dessus est plutôt rare dans la
  littérature. Dans les langages de programmation, le mot-clé utilisé
  pour ce type de construction est généralement \icode{switch},
  \code{case} ou \code{cond}.
\end{itemize}

Afin d'illustrer ce qui précède, exprimons le calcul de la valeur
absolue sous forme d'algorithme. Je fournis d'un coup les versions en
langage naturel et en pseudocode.

\begin{algorithme}
  \label{algo:algorithmes:abs}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x > 0$, retourner $x$; sinon si $x = 0$, retourner $0$;
      sinon retourner $-x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x > 0)
    Retourner x
  Sinon si (x = 0)
    Retourner 0
  Sinon
    Retourner -x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithme}

Pouvons-nous simplifier un peu tout cela? Vous aurez sans doute
remarqué que le cas $x = 0$ ne nécessite pas vraiment de traitement
particulier. Il peut être combiné avec le cas $x > 0$ ou avec le cas
$x < 0$ sans changer le résultat. C'est une leçon que vous devez
retenir: un algorithme simple et efficace ne correspond pas toujours
directement à une formule mathématique.

Voici une version simplifiée --- et à la logique inversée --- de
l'algorithme du calcul de la valeur absolue.

\begin{algorithmebis}
  \label{algo:algorithmes:abs:simplifie}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x < 0$, retourner $-x$; sinon retourner $x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x < 0)
    Retourner -x
  Sinon
    Retourner x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithmebis}

Nous pouvons aussi voir la fonction valeur absolue comme une fonction
identité (qui retourne son argument inchangé), sauf lorsque l'argument
est négatif. Ceci résulte en une autre version de l'algorithme qui se
passe d'une clause «sinon».\footnote{%
  Pensez-y: la clause «sinon» n'est jamais nécessaire lorsque la
  \meta{condition} d'une instruction conditionnelle à deux volets
  contient une instruction «Retourner».}

\begin{algorithmebis}
  \label{algo:algorithmes:abs:simplifie}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x < 0$, retourner $-x$.
    \item Retourner $x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x < 0)
    Retourner -x
  Retourner x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithmebis}

Jusqu'à maintenant, nous avons réussi à énoncer la \meta{condition}
des instructions conditionnelles uniquement à partir d'opérateurs
mathématiques simples comme $<$, $=$ et $>$. Pour construire des
conditions composées, il faut avoir recours aux opérateurs logiques
ET, OU et NON.
\begin{itemize}
\item \meta{e$_1$} ET \meta{e$_2$} est vraie lorsque les expressions
  \meta{e$_1$} et \meta{e$_2$} sont toutes deux vraies; sinon la
  condition est fausse.
\item \meta{e$_1$} OU \meta{e$_2$} est vraie lorsque l'une ou l'autre
  des expressions \meta{e$_1$} et \meta{e$_2$} est vraie; la condition
  est fausse lorsque \meta{e$_1$} et \meta{e$_2$} sont toutes deux
  fausses.
\item NON \meta{e} est vraie lorsque l'expression \meta{e} est fausse,
  et vraie autrement.
\end{itemize}

Par exemple, la condition que l'on écrit mathématiquement $5 < x < 10$
s'exprime ainsi en algorithmique: $x > 5$ ET $x < 10$.


\section{Itération et récursion}
\label{sec:algorithmes:iteration}

La plupart des tâches que nous confions à des ordinateurs sont
répétitives. Après tout, c'est ce dans quoi ils excellent puisque,
contrairement aux humains, ils ne se lassent jamais de répéter
toujours la même opération.

Il existe deux grands types de processus répétitifs: les processus
\emph{itératifs} (ou qui utilisent
l'\index{iteration@itération}itération) et les processus
\emph{récursifs} (ou qui utilisent la
\index{recursion@récursion}\index{recursivite@récursivité|see{récursion}}récursion).

Sortons un instant du contexte de la programmation informatique pour
illustrer chaque type de processus. Nous voulons indiquer à une
personne la procédure à suivre pour peinturer une clôture longue de
$n$ planches. (Pour simplifier, nous allons omettre de peinturer les
supports horizontaux.)

Dans l'approche itérative, nous supposons que les planches sont
numérotées de $1$ à $n$, puis nous indiquons à la personne d'appliquer
de la peinture sur la planche $i$, pour $i$ allant de $1$ à $n$.
Transcrites en pseudocode, les instructions vont comme suit.
\begin{Schunk}
\begin{Verbatim}
Peinturer(n)
  Pour i de 1 à n
    AppliquerPeintureSurPlanche(i)
  Fin Pour
Fin Peinturer
\end{Verbatim}
\end{Schunk}

La \autoref{fig:algorithmes:peinture-iter} illustre le processus itératif.

\begin{figure}
  \centering
  \setlength{\unitlength}{0.99mm}
  \input{include/peinture-newsavebox}
  \input{include/peinture-savebox}
  \input{include/peinture-iter}
  \caption{Illustration d'un processus itératif de peinture d'une
    clôture}
  \label{fig:algorithmes:peinture-iter}
\end{figure}

L'approche récursive est plus difficile à bien saisir. Une vieille
blague dit que pour comprendre la récursion, il faut d'abord
comprendre la récursion! Dans cette approche, les instructions pour
peinturer une clôture de $n$ planches sont à l'effet que la personne
doit appliquer de la peinture sur la première planche et peinturer une
clôture de $n - 1$ planches, et ce, tant qu'il y a des planches à
peinturer. Examinez bien le pseudocode correspondant ci-dessous.
\begin{Schunk}
\begin{Verbatim}
Peinturer(n)
  Si (n = 0)
    Travail terminé
  AppliquerPeintureSurPlanche(1) ET Peinturer(n - 1)
Fin Peinturer
\end{Verbatim}
\end{Schunk}

La personne qui suit les instructions récursives ne peut commencer à
appliquer de la peinture tant qu'elle n'a pas rencontré la condition
d'arrêt (l'extrémité de la clôture) puisque la description du travail
à effectuer dépend d'elle-même. Une fois arrivée au critère d'arrêt,
la personne dispose finalement de toutes les informations pour faire
son travail, qu'elle effectue finalement à rebours. Les processus
récursifs se caractérisent par ces phases d'\index{expansion}expansion
(ou d'accumulation d'information) et de \index{contraction}contraction
(ou d'exécution des instructions). La
\autoref{fig:algorithmes:peinture-recursive} illustre le processus
récursif.

\begin{figure}
  \centering
  \setlength{\unitlength}{0.99mm}
  \input{include/peinture-savebox}
  \input{include/peinture-recursive}
  \caption[Illustration d'un processus récursif de peinture d'une
  clôture]{Illustration d'un processus récursif de peinture d'une
    clôture. La séparation d'une planche symbolise la mise en attente
    de cette étape.}
  \label{fig:algorithmes:peinture-recursive}
\end{figure}

Nous pouvons aussi comparer les deux types de processus en observant
ce qui se passerait si la personne devait interrompre son travail pour
le confier à quelqu'un d'autre. Dans l'approche itérative, elle
pourrait simplement indiquer qu'elle en était à appliquer de la
peinture sur la planche $m$ dans le processus de peinturer une clôture
de $n$ planches. Le travail pourrait ensuite se poursuivre à partir de
la planche $m + 1$. Dans l'approche récursive, cependant, la personne
ne pourrait uniquement dire qu'elle en était à peinturer une clôture
de $m$ planches, car elle aurait aussi bien pu se trouver dans la
phase d'expansion que dans celle de contraction. Elle devrait donc
aussi fournir des informations --- qu'elle a mémorisées --- sur
l'«état» dans lequel elle se trouvait au moment d'interrompre son
travail.

À ce stade, vous pourriez vous demander pourquoi donc parler de
\index{recursion@récursion}récursion puisque ça semble si compliqué,
voire inefficace. Le fait est que la solution de plusieurs problème
s'exprime beaucoup plus simplement de manière récursive que de manière
itérative. Pensez au tri d'une main de cartes: il s'agit de placer la
plus petite carte au début de la main, puis de trier le reste de la
main, et ainsi de suite jusqu'à ce que la main soit triée au complet.
L'\index{Euclide@Euclide (algorithme)}algorithme d'Euclide est
également récursif. Examinez de nouveau
l'\autoref{algo:algorithmes:euclide}: l'étape~2 n'est rien d'autre que
le critère d'arrêt et l'étape~3, le rappel de la procédure avec des
arguments différents.

Dans l'absolu, les procédures récursives sont moins efficaces en
termes de temps de calcul et de consommation de ressources, notamment
parce qu'elles nécessitent une \index{pile}pile (\emph{stack}) pour
accumuler les informations durant la phase d'expansion. En pratique,
toutefois, ces inconvénients tendent à diminuer ou à disparaitre avec
l'optimisation des compilateurs de plusieurs langage de programmation.
De plus, la propriété de
\index{recursion@récursion!terminale}récursion terminale
(\emph{tail-recursion}) de certains langages, dont
\index{Scheme}Scheme, fait en sorte que certaines procédures
récursives sont en tous points équivalentes à des procédures
itératives. Nous n'irons pas plus loin, mais si le sujet vous
intéresse, je vous recommande de lire la section~1.2.1 de
\citet{Sussman:scheme:1996}. L'article de
\citet{Wikipedia:Recursion_terminale} constitue également un bon point
de départ pour explorer le sujet plus en profondeur.

Je ne pourrais prétendre avoir écrit un ouvrage d'introduction à la
programmation sans traiter de l'exemple classique quand il s'agit de
comparer \index{iteration@itération}itération et
\index{recursion@récursion}récursion: le calcul de la
\Index{factorielle}factorielle. La fonction factorielle est définie
par
\begin{equation*}
  n! = n \cdot (n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1.
\end{equation*}
Or, puisque
\begin{equation*}
  n! = n \cdot [(n - 1) \cdot (n - 2) \dots 3 \cdot 2 \cdot 1] =
  n \cdot (n - 1)!,
\end{equation*}
la fonction est récursive et une manière toute naturelle de calculer
la factorielle d'un nombre utilise la récursion. Exprimons ceci sous
forme d'algorithme. Le pseudocode sied un peu mieux aux algorithmes
récursifs.

\begin{algorithme}[Factorielle, approche récursive]
  Calculer la \index{factorielle}factorielle d'un entier positif $n$.
  \begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
factorial(entier n)
  Si (n = 1)
    Retourner 1
  Retourner n \times factorial(n - 1)
Fin factorial
\end{Verbatim}
  \end{Schunk}
\end{algorithme}

La \autoref{fig:algorithmes:factorial} illustre le processus de calcul
récursif de la valeur de $6!$. Remarquez comme la structure est
similaire à celle du processus de peinture d'une clôture de la
\autoref{fig:algorithmes:peinture-recursive}.

\begin{figure}
  \centering
  \begin{minipage}{0.67\linewidth}
\begin{Verbatim}[commandchars=\\\{\}]
factorial(6)
6 \times factorial(5)
6 \times (5 \times factorial(4))
6 \times (5 \times (4 \times factorial(3)))
6 \times (5 \times (4 \times (3 \times factorial(2))))
6 \times (5 \times (4 \times (3 \times (2 \times factorial(1)))))
6 \times (5 \times (4 \times (3 \times (2 \times 1))))
6 \times (5 \times (4 \times (3 \times 2)))
6 \times (5 \times (4 \times 6))
6 \times (5 \times 24)
6 \times 120
720
\end{Verbatim}
  \end{minipage}
  \caption{Processus récursif du calcul de $6!$}
  \label{fig:algorithmes:factorial}
\end{figure}

Nous pouvons également voir $n!$ comme le résultat du produit de $1$
par $2$, puis le produit du résultat par $3$, puis par $4$, et ainsi
de suite jusqu'à $n$. Avec cette approche, nous devons enregistrer le
résultat courant du produit ainsi qu'un
\index{compteur}\emph{compteur} qui nous permet de savoir où nous en
sommes dans le calcul. Cela devrait vous rappeler l'approche itérative
de la peinture d'une clôture, car c'est bien ce dont il s'agit: le
calcul de la \index{factorielle}factorielle de manière itérative.
Exprimons cette fois l'algorithme en langage naturel.

\begin{algorithme}[Factorielle, approche itérative]
  Calculer la \index{factorielle}factorielle d'un entier positif $n$.
  \begin{enumerate}
  \item Poser $p \leftarrow i \leftarrow 1$.
  \item Si $i = n$, retourner la valeur $p$.
  \item Augmenter le compteur $i$: $i \leftarrow i + 1$.
  \item Poser $p \leftarrow p \times i$, puis retourner à l'étape 2.
  \end{enumerate}
\end{algorithme}

La \autoref{fig:algorithmes:fact-iter} illustre le processus de calcul
itératif de la valeur de $6!$. Sa structure est cette fois similaire à
celle de \autoref{fig:algorithmes:peinture-iter}. Remarquez comment
les valeurs de $p$ et de $i$ enregistrent l'état du processus, ce qui
nous permettrait de l'interrompre et de le relancer à tout moment.

\begin{figure}
  \centering
  \begin{minipage}{0.25\linewidth}
\begin{Verbatim}[commandchars=\\\{\}]
factorial(6)
i \leftarrow 1; p \leftarrow 1
i \leftarrow 2; p \leftarrow 2
i \leftarrow 3; p \leftarrow 6
i \leftarrow 4; p \leftarrow 24
i \leftarrow 5; p \leftarrow 120
i \leftarrow 6; p \leftarrow 720
720
\end{Verbatim}
  \end{minipage}
  \caption{Processus récursif du calcul de $6!$}
  \label{fig:algorithmes:fact-iter}
\end{figure}


\section{Nombre d'opérations}
\label{sec:algorithmes:bigO}

Supposons que vous devez calculer, pour un jeu de données quelconque,
l'écart moyen des données supérieures à $d$ par rapport à cette
valeur. Le résultat est l'\emph{espérance résiduelle empirique} des
données évaluée à $d$. L'algorithme de haut niveau suivant permet
d'effectuer ce calcul.

\begin{algorithme}
  \label{algo:algorithmes:emrl}
  Calculer l'espérance résiduelle empirique à $d$ de données $x_1, x_2,
  \dots, x_n$.
  \begin{enumerate}
  \item Sélectionner les données supérieures à $d$.
  \item Soustraire $d$ de chaque valeur retenue à l'étape 1.
  \item Retourner la moyenne des valeurs obtenues à l'étape 2.
  \end{enumerate}
\end{algorithme}

Nous pouvons aussi concevoir une variante de l'algorithme ci-dessus en
y apportant une toute petite modification.

\begin{algorithmebis}
  \label{algo:algorithmes:emrl:bis}
  Calculer l'espérance résiduelle empirique à $d$ de données $x_1, x_2,
  \dots, x_n$.
  \begin{enumerate}
  \item Sélectionner les données supérieures à $d$.
  \item Effectuer la moyenne des valeurs obtenues à l'étape 1.
  \item Retourner la différence entre la moyenne obtenue à l'étape 2
    et $d$.
  \end{enumerate}
\end{algorithmebis}

Mathématiquement, les deux approches sont tout à fait équivalentes.
Cependant, avec l'\autoref{algo:algorithmes:emrl}, nous effectuons une
soustraction pour chaque valeur supérieure à $d$ que compte le jeu de
données. Avec l'\autoref{algo:algorithmes:emrl:bis}, nous n'effectuons
qu'une seule soustraction. Si le jeu de données compte un million
d'entrées supérieures à $d$, c'est un million de soustractions contre
une seule. En temps de calcul, cela ne représente qu'un écart de
quelques centièmes de secondes sur un ordinateur moderne, mais ces
fractions de secondes peuvent finir par faire une différence
importante lorsque la taille des jeux de données augmente ou lorsque
l'opération se répète de nombreuses fois.

Le dénombrement du nombre d'opérations requis par un algorithme est un
aspect important de leur analyse. Il se fait généralement en notation
$O(f(n))$ qui signifie «de l'ordre de $f(n)$», où $f(n)$ est une
fonction d'un paramètre $n$ qui mesure la taille du problème. Dans
l'exemple ci-dessus, $n$ est le nombre d'entrées dans le jeu de
données. Pour un algorithme de calcul du produit de deux matrices, $n$
pourrait être le nombre de lignes des matrices.

Attardons-nous à un second exemple intéressant: l'élévation d'une
valeur $b$ à la puissance $n$. L'approche la plus intuitive
consisterait à utiliser la relation
\begin{equation*}
  b^n = b (b (b \cdots (b))) = b \cdot b^{n - 1},
\end{equation*}
ce qui mène à un premier algorithme.

\begin{algorithme}
  \label{algo:algorithmes:puissance}
  Élever un nombre $b$ à la puissance entière positive $n$.
  \begin{Schunk}
\begin{Verbatim}
Puissance(nombre réel b, entier positif n)
  Si (n = 0)
    Retourner 1
  Retourner b * Puissance(b, n - 1)
Fin Puissance
\end{Verbatim}
  \end{Schunk}
\end{algorithme}

Vous aurez tout de suite identifié que
l'\autoref{algo:algorithmes:puissance} est récursif. Le nombre
d'opérations effectué avec cet algorithme est directement
proportionnel à $n$. Par exemple, il requiert $5$ opérations pour
élever un nombre à la puissance $6$. On dit donc que l'ordre de
grandeur de l'algorithme est $O(n)$.

L'\autoref{algo:algorithmes:puissance} peut convenir lorsque $n$ est
petit, mais peut-on faire mieux pour une «grande» valeur de $n$?
Imaginez que vous ne disposez que d'une calculatrice munie des
opérations arithmétiques de base et du carré, et que vous devez élever
un nombre à la puissance, disons, $21$. Comment feriez-vous pour
réduire le nombre d'opérations à entrer au clavier?

\notebox{Cet exemple est moins fantaisiste qu'il n'y parait! Jusqu'au
  milieu des années 1990, les étudiants en actuariat ne disposaient
  que de ce type de calculatrice pour les examens professionnels. Il
  s'agissait d'un modèle de Texas Instruments affectueusement surnommé
  «TI-zéro».}

Vous avez pensé à un algorithme? Votre idée consiste fort probablement
à diviser la puissance par deux autant de fois que possible et à
élever au carré par la suite. Pour $n = 21$, cela donne
\begin{align*}
  b^{21}
  &= b (b^{20}) \\
  & = b (b^{10})^2 \\
  &= b ((b^5)^2)^2 \\
  & = b ((b (b^4))^2)^2 \\
  &= b ((b (b^2)^2)^2)^2.
\end{align*}
Ce calcul se traduit en un nouvel algorithme récursif comme suit.

\begin{algorithmebis}
  \label{algo:algorithmes:puissance:bis}
  Élever un nombre $b$ à la puissance entière positive $n$.
  \begin{Schunk}
\begin{Verbatim}
Puissance(nombre réel b, entier positif n)
  Si (n = 0)
    Retourner 1
  Si (n est pair)
    Retourner (Puissance(b, n/2))^2
  Si (n est impair)
   Retourner b * Puissance(b, n - 1)
Fin Puissance
\end{Verbatim}
  \end{Schunk}
\end{algorithmebis}

Là où l'\autoref{algo:algorithmes:puissance} requiert $20$ opérations
pour élever un nombre à la puissance $21$,
l'\autoref{algo:algorithmes:puissance:bis} n'en demande que $6$. Comme
la puissance est divisée par deux à répétition, le nombre d'opérations
est proportionnel au logarithme (en base deux) de $n$. Pour vous en
convaincre, observez que le calcul de $b^{2n}$ effectue une seule
opération de plus que le calcul de $b^n$. L'ordre de grandeur de
l'algorithme est donc $O(\log n)$.

La mesure d'ordre de grandeur est très approximative. Par exemple, un
processus nécessitant $n^2$ étapes, un processus en nécessitant
$1000n^2$ et un autre en nécessitant $3n^2 + 5n + 17$ ont tous un
ordre de grandeur $O(n^2)$ puisque les constantes de sont pas prises
en compte.

Quelques ordres de grandeur surviennent plus souvent dans l'étude des
algorithmes. En voici une liste partielle, question de vous offrir un
peu de perspective si vous lisez que la performance d'un algorithme
d'ordre $O(n^3)$ est tout à fait acceptable.

\begin{itemize}
\item $O(1)$. Un algorithme d'ordre $O(1)$ prend toujours le même
  temps pour effectuer ses calculs, peu importe la taille du problème.
  Il va sans dire que de tels algorithmes sont excessivement rares. Il
  effectuent en général des tâches très simples.
\item $O(\log n)$. Tel que mentionné précédemment, l'ordre de grandeur
  $O(\log n)$ survient dès lors que la taille du problème est divisée
  par deux à chaque étape.
\item $O(\sqrt{n})$. Les algorithmes d'ordre $O(\sqrt{n})$ sont rares.
  La fonctions racine carrée croit lentement, mais néanmoins plus
  rapidement que la fonction logarithme.
\item $O(n)$. Nous avons rencontré un exemple d'algorithme $O(n)$
  ci-dessus. Les algorithmes avec cette performance demeurent
  acceptables étant donné le rythme de croissance somme toute
  raisonnable de la fonction identité.
\item $O(n \log n)$. Les algorithmes qui répètent $n$ fois un calcul
  d'ordre $O(\log n)$ ont une performance d'ordre $O(n \log n)$.
  C'est le cas de plusieurs algorithmes de tri.
\item $O(n^2)$. Les algorithmes qui effectuent un calcul pour toutes
  les paires d'entrées ont une performance $O(n^2)$. Ici, ça commence
  à devenir lent.
\item $O(n!)$. Attention, danger. La fonction factorielle croit si
  rapidement qu'un algorithme ayant ce type de performance ne peut
  résoudre que de petits problèmes.
\end{itemize}

Pour en savoir plus sur les principes de base du dénombrement des
opérations d'un algorithme, consultez
\citet[chapitre~1]{Stephens:algorithms:2013}.


\section{Épilogue}
\label{sec:algorithmes:epilogue}

\citet{Kernighan:practice:1999} font remarquer, fort à propos:
\begin{quote}
  Tous les programmes reposent sur des algorithmes et des structures
  de données, mais très peu de programmes exigent d'en concevoir de
  nouveaux.
\end{quote}
Autrement dit, aussi complexe soit-il, un programme repose souvent sur
quelques algorithmes fondamentaux bien connus et bien établis. À ce
titre, les algorithmes de tri et de recherche jouent un rôle
particulièrement important: on estime que 25~\% du temps de calcul des
ordinateurs dans le monde est consacré au tri et à la recherche! Ce
n'est pas pour rien que Donald Knuth consacre un volume entier de son
œuvre monumentale \emph{The Art of Computer Programming} à ce seul
sujet \citep{Knuth:ACP:vol3:1997}.

Nous reviendrons sur les algorithmes classiques de tri et de recherche
au \autoref{chap:tri}.


\section{Exercices}
\label{sec:algorithmique:exercices}

\Opensolutionfile{solutions}[solutions-algorithmique]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:algorithmes}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:algorithmes}}

\begingroup
%% modifications locales au style des listings
\lstset{%
  frame=single,
  numbers=none,
  basicstyle=\normalfont\ttfamily\NoAutoSpacing}

\end{Filesave}

%  Pourquoi la clause «sinon» n'est jamais nécessaire lorsque la
%   \meta{condition} d'une instruction conditionnelle à deux volets
%   contient une instruction «Retourner».

%   Clauses logiques ET, OU, NON

%   Exprimer PGCD récursif en pseudocode

% Comparer graphiquement le rythme de croissance des fonctions $\log
% n$, $\sqrt{n}$, $n$, $n \log n$, $n^2$ et $n!$.

\begin{Filesave}{solutions}
\endgroup                               % fin de \lstset local
\end{Filesave}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
