%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Algorithmes et algorithmique}
\label{chap:algorithmes}

\def\scriptfilename{\currfilebase.R}

\begin{objectifs}
\item Expliquer les algorithmes classiques de tri et de recherche;
  comparer leurs avantages et inconvénients.
\item Exprimer une méthode de résolution de problème sous la forme
  d'un algorithme à l'aide de pseudocode.
\item Effectuer la mise en oeuvre d'un algorithme donné dans le
  langage R.
\end{objectifs}

Marianne et Alexandre doivent fournir une solution logicielle à un
problème donné. Sitôt la lecture de l'énoncé du problème complétée,
ils se précipitent sur le clavier pour coder leur solution. Rapidement
bloqués, pensant qu'ils butent sur un problème de syntaxe ou
d'utilisation d'une fonction, ils demandent de l'aide. Lorsqu'on leur
demande qu'est-ce qu'ils essaient de faire, quelle est la nature de leur
solution, ils ne peuvent répondre que par un long silence.

Dans mon rôle de professeur, j'ai été témoin de la scène ci-dessus à
de nombreuses reprises. Marianne et Alexandre font une erreur commune
chez les programmeurs --- et pas que chez les débutants: commencer à
coder sans avoir au préalable suffisamment réfléchi à la solution. Il
leur manque un plan clair des étapes à suivre pour résoudre le
problème. Or, ce plan, ou la recette à suivre --- nous reviendrons sur
cette analogie culinaire dans la suite --- pour transformer les
entrants d'un problème en une solution, c'est l'algorithme. Travailler
sans algorithme, c'est comme naviguer sans boussole.

Si programmer requiert des algorithmes, l'étude de la programmation
doit donc nécessairement s'accompagner de notions
d'\index{algorithmique}algorithmique, la science qui étudie les
algorithmes et les structures de données. L'algorithmique est une
discipline riche en techniques ingénieuses et en analyses
mathématiques poussées. Connaitre ses principes de base et étudier
certains algorithmes classiques vous permettra de mieux planifier vos
méthodes de résolution de problème. En effet, un bon algorithme permet
de résoudre en quelques secondes un problème qui pourrait autrement
prendre des années.

L'étude des algorithmes s'accompagne habituellement de celle des
structures de données ou, en d'autres termes, de la manière
d'organiser les données dans un ordinateur. Comme nous le verrons au
\autoref{chap:donnees}, il existe bien différentes structures de
données en R, mais leur réelle mise en œuvre demeure tout à fait
transparente pour les programmeuses et les programmeurs. C'est
pourquoi nous ferons l'impasse sur des notions que l'on retrouve dans
tous les ouvrages classiques d'algorithmique, comme le tableau
(\emph{array}), la liste chainée (\emph{list}), l'arbre (\emph{tree})
ou la table de hachage (\emph{hashtable}).

Le présent chapitre est inspiré de \emph{Essential Algorithms} de
\citet{Stephens:algorithms:2013}, un excellent ouvrage rédigé dans un
style clair et direct.

\section{Définition et analogie}
\label{sec:algorithmes:definition}

Un \index{algorithme}\emph{algorithme} est une procédure de calcul
permettant de résoudre un problème bien spécifié. L'algorithme
explique, de manière non ambigüe et dans un nombre d'opérations fini,
comment, à partir d'entrants, obtenir l'extrant solution du problème.

Pour se mériter un algorithme, un problème doit renfermer une dose
minimale de complexité: personne n'écrit un algorithme pour extraire
le quatrième élément d'un vecteur de données. On suppose que cela fait
partie de la définition de vecteur et que vous savez comment effectuer
l'opération dès lors que vous connaissez le langage de programmation
sous-jacent.

Dans la même veine, un algorithme ne dépend pas du langage de
programmation employé car il fournit les étapes pour résoudre un
problème, non pas leur mise en œuvre. En d'autres termes, un
algorithme explique \emph{ce qu'il faut faire} pour résoudre un
problème et non \emph{comment le faire}.

Illustrons le concept d'algorithme par l'un de ses plus illustres
représentants: l'algorithme d'Euclide (c.~300 av. J.-C.), une procédure
de calcul du plus grand commun diviseur (PGCD) de deux nombres entiers
$m$ et $n$. L'algorithme repose sur l'idée que le PGCD de $m$ et $n$
est aussi le PGCD de $n$ et du reste de la division de $m$ par $n$.

\begin{algorithme}[Algorithme d'Euclide]
  \label{algo:algorithmes:euclide}
  Calculer le plus grand commun diviseur de deux entiers positifs $m$
  et $n$ avec, sans perte de généralité, $n < m$.
  \begin{enumerate}
  \item Diviser $m$ par $n$ et poser $r$ égal au reste de la division.
    (Nous avons alors $0 \leq r < n$.)
  \item Si $r = 0$, retourner la valeur $n$.
  \item Poser $m \leftarrow n$ et $n \leftarrow r$, puis retourner à
    l'étape 1.
  \end{enumerate}
\end{algorithme}

Suivons les étapes de l'algorithme d'Euclide avec $m = 544$ et
$n = 119$. À l'étape~1, nous déterminons que $544/119 = 4 + 68/119$,
donc nous posons $r \leftarrow 68$. Puisque $r \neq 0$, l'étape~2 de
l'algorithme ne s'applique pas. Nous passons donc à l'étape~3 et nous
posons $m \leftarrow 119$ et $n \leftarrow 68$. De retour à l'étape~1,
nous déterminons cette fois que $r \leftarrow 51$, ce qui mène encore
à l'étape~3 et $m \leftarrow 68$ et $n \leftarrow 51$. Après un autre
cycle, nous en sommes à $m \leftarrow 51$ et $n \leftarrow 17$. Cette
fois, nous posons $r \leftarrow 0$ à l'étape~1 et la procédure
s'arrête ensuite à l'étape~2. Le plus grand commun diviseur de $544$
et $119$ est $17$.

Selon \citet[section~1.1]{Knuth:ACP:vol1:1997}, un algorithme devrait
réunir cinq caractéristiques.\footnote{%
  Liste adaptée de la version française fournie par
  \citet{Wikipedia:Algorithme}.}
\begin{enumerate}
\item \emph{Finitude}. Un algorithme doit toujours se terminer après
  un nombre fini d’étapes. Ce nombre peut toutefois devenir très
  grand.
\item \emph{Définition précise}. Chaque étape d'un algorithme doit
  être définie précisément; les actions à réaliser doivent être
  spécifiées rigoureusement et sans ambigüité pour chaque cas.
\item \emph{Entrées}. Un algorithme comporte aucune, une ou plusieurs
  \emph{entrées}, des quantités fournies à l'algorithme avant qu'il ne
  commence ou qui sont allouées dynamiquement durant son exécution.
  Ces entrées proviennent d'un ensemble d'objets bien spécifié. Par
  exemple, l'\autoref{algo:algorithmes:euclide} comporte deux entrées,
  les nombres $m$ et $n$, provenant de l'ensemble des entiers
  positifs.
\item \emph{Sorties}. Un algorithme comporte une ou plusieurs
  \emph{sorties}: des quantités ayant une relation spécifiée avec les
  entrées. L'\autoref{algo:algorithmes:euclide} a une seule sortie,
  soit la valeur $n$ de l'étape~2, le plus grand commun diviseur des
  entrées.
\item \emph{Efficacité}. On s'attend généralement d'un algorithme
  qu'il soit \emph{efficace} dans le sens où toutes les opérations
  qu'il doit accomplir sont suffisamment élémentaires pour pouvoir
  être en principe réalisées dans une durée finie par une personne
  munie de papier et d'un crayon.
\end{enumerate}

Pour bien comprendre la nature et la portée d'un algorithme, il est
assez utile de le comparer à une recette de cuisine. Dans une recette,
les entrées sont les ingrédients, la procédure les diverses étapes et
la sortie, le plat préparé.

Comme un algorithme, une recette repose sur un certain nombre
d'instructions élémentaires qui se passent d'explication, comme
saisir, mijoter, mélanger, etc. La recette est indépendante des
ustensiles utilisés comme l'algorithme l'est du langage de
programmation.

Surtout, surtout, une recette explique les étapes à suivre pour
obtenir le plat voulu, mais, sauf peut-être pour certaines opérations
plus délicates, elle n'explique pas \emph{comment} réaliser chaque
étape. S'il faut ajouter du lait dans un mélange à gateau, la recette
n'indique pas de sortir le lait du réfrigérateur, de vérifier la date
de péremption et de verser le lait dans la tasse à mesurer jusqu'à la
ligne correpondant à la quantité voulue. Un algorithme ne contient pas
plus d'instructions pour vérifier la validité des entrées ou pour
effectuer des opérations de base comme les opérations arithmétiques,
la lecture de données, l'indiçage d'un vecteur, etc.

En revanche, on s'attend généralement d'un algorithme, qui est destiné
à un ordinateur, qu'il soit plus précis qu'une recette. En effet, un
ordinateur éprouverait beaucoup de difficulté avec une instruction
comme «saler et poivrer au goût»!

\tipbox{C'est une erreur commune dans la rédaction d'un algorithme de
  fournir des détails de mise en œuvre superflus, de surcroit dans un
  langage de programmation bien précis. Lorsque vous écrirez un
  algorithme, demandez-vous si vous êtes en train d'expliquer comment
  mesurer une quantité de lait avec une tasse à mesurer de marque
  ACME.}


\section{Pseudocode}
\label{sec:algorithmes:pseudocode}

Puisqu'il s'agissait du premier exemple d'algorithme complet, j'ai
choisi de présenter l'\autoref{algo:algorithmes:euclide} dans un
format très près du langage naturel.

Une autre manière très populaire d'exprimer les algorithmes consiste à
utiliser du \index{pseudocode}\emph{pseudocode}, un «langage»
similaire à un langage de programmation, mais toujours sans référence
à un langage en particulier. L'écriture en pseudocode permet parfois
de mieux prendre la mesure de la structure et des détails d'un
algorithme avant d'en attaquer la mise en œuvre.

Il n'existe pas réellement de normes de composition pour le
pseudocode.

Voici de nouveau l'algorithme d'Euclide, présenté cette fois en
pseudocode. Portez-y une attention toute particulière puisqu'il ne
s'agit pas d'une transcription directe de
l'\autoref{algo:algorithmes:euclide}. Vérifiez que les deux versions
de l'algorithme retournent bien le même résultat.

\begin{algorithmebis}[Algorithme d'Euclide, version en pseudocode]
  \label{algo:algorithmes:euclide:pseudo}
  Calculer le plus grand commun diviseur de deux entiers positifs $m$
  et $n$ avec, sans perte de généralité, $n < m$.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
PGCD(entier m, entier n)
  Tant que (n \neq 0)
    r \leftarrow m mod n
    m \leftarrow n
    n \leftarrow r
  Fin Tant que
  Retourner m
Fin PGCD
\end{Verbatim}
\end{Schunk}
\end{algorithmebis}

\tipbox{L'opération \index{modulo}modulo, notée en mathématiques
  $m \mod n$, représente le reste de la division de $m$ par $n$. Par
  exemple, tel que calculé précédemment, $544 \mod 119 = 68$.}

L'\autoref{algo:algorithmes:euclide:pseudo} reprend quelques unes des
conventions les plus usuelles pour le pseudocode.

La procédure de calcul faisant l'objet de l'algorithme est rédigée
sous forme d'une fonction\footnote{%
  C'est la terminologie de R. Une unité de code qui effectue un
  traitement donné porte divers noms selon le langage de
  programmation: fonction, routine, sous-routine, méthode, procédure,
  sous-procédure.}. %
L'algorithme débute par la \index{signature}\emph{signature} de la
fonction (son nom avec le nom et le type de tous les arguments). Le
code est indenté (décalé vers la droite) après la signature de la
fonction pour montrer qu'il fait partie du corps de la fonction.

Le bloc délimité par les instructions \code{Tant que
  (\meta{condition})} et \code{Fin Tant que} forme une
\index{boucle}\emph{boucle} dont le contenu --- lui aussi indenté ---
est exécuté tant et aussi longtemps que la \meta{condition} est vraie.

L'instruction \code{Retourner} met immédiatement fin à la fonction,
ici en retournant la valeur \code{m}.

Enfin, on présente le pseudocode comme du code informatique dans une
police non proportionnelle qui préserve l'alignement vertical des
caractères.


\section{Évaluation conditionnelle}
\label{sec:algorithmes:if-else}

Plusieurs algorithmes, même les plus simples, nécessitent de pouvoir
effectuer des opérations différentes selon le résultat d'un test. Par
exemple, pour effectuer le banal calcul de la valeur absolue d'un
nombre, nous devons vérifier si le nombre est positif, négatif ou nul
pour retourner un résultat différent en fonction de la règle suivante:
\begin{equation*}
  \lvert x \rvert =
  \begin{cases}
    x, & \text{si } x > 0 \\
    0, & \text{si } x = 0 \\
    -x, & \text{si } x < 0.
  \end{cases}
\end{equation*}

De telles constructions requièrent des \emph{instructions
  conditionnelles} qui permettent d'effectuer différents calculs selon
le résultat d'une condition booléenne (vraie ou fausse). Il en existe
quatre grands types.

\begin{itemize}
\item Les instructions conditionnelles à un volet de la forme
  \begin{quote}
    Si \meta{condition}, alors \meta{conséquence}
  \end{quote}
  Dans cette construction, la \meta{conséquence} est évaluée seulement
  lorsque la \meta{condition} est vraie. Dans le cas contraire, il ne
  se passe rien et le déroulement de l'algorithme se poursuit
  normalement. Nous avons utilisé une telle instruction conditionnelle
  à l'étape~2 de l'\autoref{algo:algorithmes:euclide}. La locution
  «alors» est souvent omise dans les algorithmes comme, d'ailleurs,
  dans la syntaxe de plusieurs langages de programmation.
\item Les instructions conditionnelles à deux volets de la forme
  \begin{quote}
    Si \meta{condition}, alors \meta{conséquence}, \\
    sinon \meta{alternative}
  \end{quote}
  Cette construction permet d'effectuer un choix entre deux actions:
  ou bien la \meta{condition} est vraie et la \meta{conséquence} est
  évaluée, ou bien la \meta{condition} est fausse et c'est alors
  l'\meta{alternative} qui est évaluée. Le déroulement de l'algorithme
  se poursuit après l'exécution de l'une ou l'autre des deux actions.
\item Les instructions conditionnelles imbriquées de la forme
  \begin{quote}
    Si \meta{condition$_1$}, alors \meta{conséquence$_1$}, \\
    sinon si \meta{condition$_2$}, alors \meta{conséquence$_2$}, \\
    sinon \meta{alternative}
  \end{quote}
  Une instruction conditionnelle imbriquée permet de choisir entre
  trois actions: la \meta{conséquence$_1$} est évaluée lorsque la
  \meta{condition$_1$} est vraie; la \meta{conséquence$_2$} est évaluée
  lorsque la \meta{condition$_1$} est fausse et que la
  \meta{condition$_2$} est vraie; l'\meta{alternative} est évaluée
  lorsque la \meta{condition$_1$} et la \meta{condition$_2$} sont toutes
  les deux fausses. Pour choisir entre plus de trois actions
  possibles, il suffit d'ajouter des clauses «sinon si\dots, alors\dots».
\item Une variante de l'instruction précédente qui facilite la lecture
  lorsqu'il y a un grand nombre d'actions possibles:
  \begin{quote}
    Selon que \\
    \meta{condition$_1$}, alors \meta{action$_1$}; \\
    \meta{condition$_2$}, alors \meta{action$_2$}; \\
    \meta{condition$_3$}, alors \meta{action$_3$}; \\
    \dots \\
    autrement, \meta{action par défaut}
  \end{quote}
  Seule l'\meta{action} correspondant à la \meta{condition} vraie est
  exécutée. Si aucune \meta{condition} n'est vraie, c'est
  l'\meta{action par défaut} qui est exécutée. La terminologie
  française que j'utilise ci-dessus est plutôt rare dans la
  littérature. Dans les langages de programmation, le mot-clé utilisé
  pour ce type de construction est généralement \icode{switch},
  \code{case} ou \code{cond}.
\end{itemize}

Afin d'illustrer ce qui précède, exprimons le calcul de la valeur
absolue sous forme d'algorithme. Je fournis d'un coup les versions en
langage naturel et en pseudocode.

\begin{algorithme}
  \label{algo:algorithmes:abs}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x > 0$, retourner $x$; sinon si $x = 0$, retourner $0$;
      sinon retourner $-x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x > 0)
    Retourner x
  Sinon si (x = 0)
    Retourner 0
  Sinon
    Retourner -x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithme}

Pouvons-nous simplifier un peu tout cela? Vous aurez sans doute
remarqué que le cas $x = 0$ ne nécessite pas vraiment de traitement
particulier. Il peut être combiné avec le cas $x > 0$ ou avec le cas
$x < 0$ sans changer le résultat. C'est une leçon que vous devez
retenir: un algorithme simple et efficace ne correspond pas toujours
directement à une formule mathématique.

Voici une version simplifiée --- et à la logique inversée --- de
l'algorithme du calcul de la valeur absolue.

\begin{algorithmebis}
  \label{algo:algorithmes:abs:simplifie}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x < 0$, retourner $-x$; sinon retourner $x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x < 0)
    Retourner -x
  Sinon
    Retourner x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithmebis}

Nous pouvons aussi voir la fonction valeur absolue comme une fonction
identité (qui retourne son argument inchangé), sauf lorsque l'argument
est négatif. Ceci résulte en une autre version de l'algorithme qui se
passe d'une clause «sinon».\footnote{%
  Pensez-y: la clause «sinon» n'est jamais nécessaire lorsque la
  \meta{condition} d'une instruction conditionnelle à deux volets
  contient une instruction «Retourner».}

\begin{algorithmebis}
  \label{algo:algorithmes:abs:simplifie}
  Calculer la valeur absolue d'un nombre réel $x$.

  \noindent
  \begin{minipage}[t]{0.48\linewidth}
    \begin{enumerate}
    \item Si $x < 0$, retourner $-x$.
    \item Retourner $x$.
    \end{enumerate}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    \begin{Schunk}
\begin{Verbatim}
abs(réel x)
  Si (x < 0)
    Retourner -x
  Retourner x
Fin abs
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{algorithmebis}

Jusqu'à maintenant, nous avons réussi à énoncer la \meta{condition}
des instructions conditionnelles uniquement à partir d'opérateurs
mathématiques simples comme $<$, $=$ et $>$. Pour construire des
conditions composées, il faut avoir recours aux opérateurs logiques
ET, OU et NON.
\begin{itemize}
\item \meta{e$_1$} ET \meta{e$_2$} est vraie lorsque les expressions
  \meta{e$_1$} et \meta{e$_2$} sont toutes deux vraies; sinon la
  condition est fausse.
\item \meta{e$_1$} OU \meta{e$_2$} est vraie lorsque l'une ou l'autre
  des expressions \meta{e$_1$} et \meta{e$_2$} est vraie; la condition
  est fausse lorsque \meta{e$_1$} et \meta{e$_2$} sont toutes deux
  fausses.
\item NON \meta{e} est vraie lorsque l'expression \meta{e} est fausse,
  et vraie autrement.
\end{itemize}

Par exemple, la condition que l'on écrit mathématiquement $5 < x < 10$
s'exprime ainsi en algorithmique: $x > 5$ ET $x < 10$.


\section{Itération et récursivité}
\label{sec:algorithmes:iteration}

La plupart des tâches que nous confions à des ordinateurs sont
répétitives. Après tout, c'est ce dans quoi ils excellent puisque,
contrairement aux humains, ils ne se lassent jamais de répéter
toujours la même opération.

Il existe deux grands types de processus répétitifs: les processus
\emph{itératifs} (ou qui utilisent l'\index{itération}itération) et
les processus \emph{récursifs} (ou qui utilisent la
\index{recursivite@récursivité}récursivité).

Sortons un instant du contexte de la programmation informatique pour
illustrer chaque type de processus. Nous voulons indiquer à une
personne la procédure à suivre pour peinturer une clôture longue de
$n$ planches. (Pour simplifier, nous allons omettre de peinturer les
supports horizontaux.)

Dans l'approche itérative, nous supposons que les planches sont
numérotées de $1$ à $n$, puis nous indiquons à la personne d'appliquer
de la peinture sur la planche $i$, pour $i$ allant de $1$ à $n$.
Transcrites en pseudocode, les instructions vont comme suit.
\begin{Schunk}
\begin{Verbatim}
Peinturer(n)
  Pour i de 1 à n
    AppliquerPeintureSurPlanche(i)
  Fin Pour
Fin Peinturer
\end{Verbatim}
\end{Schunk}

La \autoref{fig:algorithmes:peinture-iter} illustre le processus itératif.

\begin{figure}
  \centering
  \setlength{\unitlength}{1.1mm}
  \input{include/peinture-newsavebox}
  \input{include/peinture-savebox}
  \input{include/peinture-iter}
  \caption{Illustration d'un processus itératif de peinture d'une
    clôture}
  \label{fig:algorithmes:peinture-iter}
\end{figure}

L'approche récursive est plus difficile à bien saisir. Une vieille
blague dit que pour comprendre la récursivité, il faut d'abord
comprendre la récursivité! Dans cette approche, les instructions pour
peinturer une clôture de $n$ planches sont à l'effet que la personne
doit appliquer de la peinture sur la première planche et peinturer une
clôture de $n - 1$ planches, et ce, tant qu'il y a des planches à
peinturer. Examinez bien le pseudocode correspondant ci-dessous.
\begin{Schunk}
\begin{Verbatim}
Peinturer(n)
  Si (n = 0)
    Travail terminé
  AppliquerPeintureSurPlanche(1) ET Peinturer(n - 1)
Fin Peinturer
\end{Verbatim}
\end{Schunk}

La personne qui suit les instructions récursives ne peut commencer à
appliquer de la peinture tant qu'elle n'a pas rencontré la condition
d'arrêt (l'extrémité de la clôture) puisque la description du travail
à effectuer dépend d'elle-même. Une fois arrivée au critère d'arrêt,
la personne dispose finalement de toutes les informations pour faire
son travail, qu'elle effectue finalement à rebours. Les processus
récursifs se caractérisent par ces phases d'\index{expansion}expansion
(ou d'accumulation d'information) et de \index{contraction}contraction
(ou d'exécution des instructions). La
\autoref{fig:algorithmes:peinture-recursive} illustre le processus
récursif.

\begin{figure}
  \centering
  \setlength{\unitlength}{1.0mm}
  \input{include/peinture-savebox}
  \input{include/peinture-recursive}
  \caption{Illustration d'un processus récursif de peinture d'une
    clôture}
  \label{fig:algorithmes:peinture-recursive}
\end{figure}

Nous pouvons aussi comparer les deux types de processus en observant
ce qui se passerait si la personne devait interrompre son travail pour
le confier à quelqu'un d'autre. Dans l'approche itérative, elle
pourrait simplement indiquer qu'elle en était à appliquer de la
peinture sur la planche $m$ dans le processus de peinturer une clôture
de $n$ planches. Le travail pourrait ensuite se poursuivre à partir de
la planche $m + 1$. Dans l'approche récursive, cependant, la personne
ne pourrait uniquement dire qu'elle en était à peinturer une clôture
de $m$ planches, car elle aurait aussi bien pu se trouver dans la
phase d'expansion que dans celle de contraction. Elle devrait donc
aussi fournir des informations --- qu'elle a mémorisées --- sur
l'«état» dans lequel elle se trouvait au moment d'interrompre son
travail.








\section{Nombre d'opérations}
\label{sec:algorithmes:bigO}




\subsection{Algorithme}
\label{sec:informatique:concepts:algorithme}

Vous avez probablement déjà trié une liste de mots à l'aide d'un
ordinateur. Pourtant, l'ordinateur n'a aucune connaissance du concept
d'ordre alphabétique. Et même s'il «connaissait» cet ordre, comment au
juste réalise-t-il l'opération de tri? Ce genre de questions relève
d'une pierre d'assise de l'informatique:
l'\index{algorithmique}algorithmique, la science qui étudie les
algorithmes et les structures de données.

Un \index{algorithme}\emph{algorithme} est une procédure de calcul
permettant de résoudre un problème bien spécifié. En cela,
l'algorithme explique comment, à partir d'entrants, obtenir l'extrant
solution du problème. Quand on y pense, ce n'est pas très différent
d'une recette culinaire où les entrants sont les ingrédients, la
procédure les étapes de la recette et les extrants, le mets.

À titre d'exemple, supposons que vous devez calculer, pour un jeu de
données quelconque, l'écart moyen des données supérieures à $12$ par
rapport à cette valeur. Un premier algorithme de très haut niveau
permettant de résoudre ce problème irait comme suit.

\begin{Schunk}
  \begin{enumerate}
  \item Sélectionner les données supérieures à $12$.
  \item Soustraire $12$ de chaque valeur retenue à la première étape.
  \item Effectuer la moyenne des valeurs obtenues à la seconde étape.
  \end{enumerate}
\end{Schunk}

Apportons une toute petite modification à l'algorithme ci-dessus.

\begin{Schunk}
  \begin{enumerate}
  \item Sélectionner les données supérieures à $12$.
  \item Effectuer la moyenne des valeurs obtenues à la première étape.
  \item Soustraire $12$ de la valeur retenue à la seconde étape.
  \end{enumerate}
\end{Schunk}

Mathématiquement, les deux approches sont tout à fait équivalentes.
Cependant, avec la première approche, nous effectuons une soustraction
pour chaque valeur supérieure à $12$ que compte le jeu de données. Avec
la seconde approche, nous n'effectuons qu'une seule soustraction. Si
le jeu de données compte un million d'entrées supérieures à $12$,
c'est un million de soustractions contre une seule. En temps de
calcul, cela ne représente qu'un écart de quelques centièmes de
secondes sur un ordinateur moderne, mais ces fractions de secondes
peuvent finir par faire une différence importante lorsque la taille
des jeux de données augmente ou lorsque l'opération se répète de
nombreuses fois.

Attardons-nous à un second exemple intéressant: l'élévation d'une
valeur $b$ à la puissance $n$. Un premier algorithme, écrit cette fois
en \index{pseudo-langage}\emph{pseudo-langage}, pourrait se lire
ainsi.

\begin{Schunk}
\begin{Verbatim}
Puissance(nombre réel b, entier n)
  Si n = 0, retourner 1.
  Retourner b * Puissance(b, n - 1).
Fin Puissance
\end{Verbatim}
\end{Schunk}

Cet algorithme est \index{algorithme!récursif}\emph{récursif}: la
procédure \code{Puissance} s'appelle elle-même à répétition jusqu'à
l'obtention du résultat désiré. Mathématiquement, l'algorithme revient
à calculer $b^n$ de la manière la plus simple et intuitive qui soit:
\begin{equation*}
  b^n = b (b (b \cdots (b))).
\end{equation*}
Cela peut convenir lorsque $n$ est petit, mais peut-on faire mieux
pour une «grande» valeur de $n$? Imaginez que vous ne disposez que
d'une calculatrice munie des opérations arithmétiques de base et du
carré, et que vous devez élever un nombre à la puissance, disons,
$21$. Comment feriez-vous pour réduire le nombre d'opérations à entrer
au clavier?

\notebox{Cet exemple est moins fantaisiste qu'il n'y parait! Jusqu'au
  milieu des années 1990, les étudiants en actuariat ne disposaient
  que de ce type de calculatrice pour les examens professionnels. Il
  s'agissait d'un modèle de Texas Instruments affectueusement surnommé
  «TI-0».}

Vous avez pensé à un «algorithme»? Votre idée consiste fort
probablement à diviser la puissance par deux autant de fois que
possible et à élever au carré par la suite. Dans notre exemple, cela
donne
\begin{align*}
  b^{21}
  &= b (b^{20}) \\
  & = b (b^{10})^2 \\
  &= b ((b^5)^2)^2 \\
  & = b ((b (b^4))^2)^2 \\
  &= b ((b (b^2)^2)^2)^2.
\end{align*}
Ce calcul se traduit en algorithme comme suit.

\begin{Schunk}
\begin{Verbatim}
Puissance(nombre réel b, entier n)
  Si n = 0, retourner 1.
    Si n est pair, retourner (Puissance(b, n/2))^2.
    Si n est impair, retourner b * Puissance(b, n - 1).
Fin Puissance
\end{Verbatim}
\end{Schunk}

Pour élever un nombre à la puissance $21$, le premier algorithme
requiert $20$ opérations et le second, seulement $6$. Le dénombrement
du nombre d'opérations requis par un algorithme est un aspect
important de leur analyse. Il se fait généralement en notation $O()$
qui signifie «de l'ordre de». Dans le premier algorithme de calcul de
$b^n$, le nombre d'opérations est directement proportionnel à $n$,
donc on dit que l'algorithme est $O(n)$. Dans le second algorithme où
la puissance est divisée par deux à répétition, le nombre d'opérations
est proportionnel au logarithme (en base deux) de $n$, d'où un
algorithme $O(\log n)$. Pour en savoir plus, consultez
\citet[chapitre~1]{Stephens:algorithms:2013}, qui explique à la fois
très clairement et de manière concise les principes de base du
dénombrement des opérations d'un algorithme.

\citet{Kernighan:practice:1999} font remarquer, fort à propos:
\begin{quote}
  Tous les programmes reposent sur des algorithmes et des structures
  de données, mais très peu de programmes exigent d'en concevoir de
  nouveaux.
\end{quote}
Autrement dit, aussi complexe soit-il, un programme repose souvent sur
quelques algorithmes fondamentaux bien connus et bien établis. À ce
titre, les algorithmes de tri et de recherche jouent un rôle
particulièrement important: on estime que 25~\% du temps de calcul des
ordinateurs dans le monde est consacré au tri et à la recherche! Ce
n'est pas pour rien que Donald Knuth consacre un volume entier de son
œuvre monumentale \emph{The Art of Computer Programming} à ce seul
sujet \citep{Knuth:ACP:vol1:1997}.

L'étude des algorithmes classiques de tri et de recherche fera l'objet
du \autoref{chap:algorithmique}.



\section{Algorithmes classiques}
\label{sec:algorithmique:tri}

Pour l'étude des algorithmes classiques, je m'en remets à l'excellent
ouvrage \emph{Essential Algorithms} de
\citet{Stephens:algorithms:2013}. Rédigé dans un style clair et
direct, le manuscrit va juste assez loin pour nos besoins dans les
différentes notions, sans pour autant sacrifier les détails
importants. Bref, un juste équilibre entre «algorithmique pour les
nuls» et un livre plus théorique.

Je vous invite donc à étudier les chapitres suivants de \emph{Essential
Algorithms}:
\begin{itemize}
\item chapitre 6, pages 131--138, 145 (à partir de la section
  \emph{Quicksort})--148 et 156--160;
\item chapitre 7, pages 163--168;
\item chapitre 9, pages 185--193.
\end{itemize}

Quelques remarques pour vous aider dans votre lecture.
\begin{itemize}
\item Partout où vous lirez \emph{array}, pensez tout simplement à un
  vecteur dans R.
\item Tel que mentionné au chapitre~1 de
  \citet{Stephens:algorithms:2013}, l'auteur a pris le parti d'indicer
  les vecteurs comme dans plusieurs langages de programmation, soit de
  $0$ à $n - 1$ pour un vecteur de longueur $n$. Vous devrez adapter
  les algorithmes en conséquence pour la programmation en R où les
  vecteurs sont plutôt indicés de $1$ à $n$.
\item Le livre fait ici et là référence au concept de \emph{library}.
  Une bibliothèque (le nom en français) est une collection de
  fonctions ou de sous-programmes que l'on peut utiliser dans nos
  programmes. Certains langages de programmation sont constitués d'un
  noyau assez restreint auquel on ajoute plusieurs fonctionnalités
  standards (le tri ou la recherche, par exemple) par le biais de
  bibliothèques. C'est en partie le cas de R, mais le système de base
  contient déjà un grand nombre de fonctionnalités.
\end{itemize}


\section{Exercices}
\label{sec:algorithmique:exercices}

\Opensolutionfile{solutions}[solutions-algorithmique]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:algorithmes}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:algorithmes}}

\begingroup
%% modifications locales au style des listings
\lstset{%
  frame=single,
  numbers=none,
  basicstyle=\normalfont\ttfamily\NoAutoSpacing}

\end{Filesave}

%  Pourquoi la clause «sinon» n'est jamais nécessaire lorsque la
%   \meta{condition} d'une instruction conditionnelle à deux volets
%   contient une instruction «Retourner».

% Clauses logiques ET, OU, NON

\begin{Filesave}{solutions}
\endgroup                               % fin de \lstset local
\end{Filesave}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
