%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Fonctions}
\label{chap:fonctions}

\def\scriptfilename{\currfilebase.R}
\SweaveOpts{echo=FALSE}

<<echo=FALSE, results=hide>>=
source(".Sweaveprofile")   # configuration
source("Stangle.R")        # lancement de Stangle
@
<<script>>=
## Copyright (C) 2019 Vincent Goulet
##
## Ce fichier fait partie du projet
## «Programmer avec R»
## https://gitlab.com/vigou3/programmer-avec-r
##
## Cette création est mise à disposition sous licence
## Attribution-Partage dans les mêmes conditions 4.0
## International de Creative Commons.
## https://creativecommons.org/licenses/by-sa/4.0/
@

\begin{objectifs}
\item Définir une fonction R, ses divers arguments et, le cas échéant,
  les valeurs par défaut de ceux-ci.
\item Utiliser et définir des fonctions R ayant un nombre variable
  d'arguments.
\item Utiliser la fonction \code{if} pour l’exécution conditionnelle
  d'expressions R.
\item Distinguer la construction \code{if ... else ...} de la fonction
  \code{ifelse}.
\item Concevoir une boucle dans R.
\item Choisir entre les opérateurs \code{for}, \code{while} et
  \code{repeat} lors de la construction d'une boucle R.
\item Employer les normes de programmation reconnues en matière de
  segmentation du code, de style et de documentation.
\end{objectifs}

Nous avons mentionné au début de la \autoref{sec:premiers:fondamentales}
qu'un langage de programmation doit fournir un mécanisme d'abstraction
pour utiliser les éléments composés. La possibilité qu'offre R
de définir des objets contenant des valeurs constitue une première
technique. La définition de \emph{fonctions} (le nom que nous
donnons dorénavant au concept de procédure) est une technique
d'abstraction encore plus puissante, puisqu'elle permet de faire
référence par un seul nom à toute une suite d'opérations.

\section{Programmation fonctionnelle}
\label{sec:fonctions:paradigme}

Nous adoptons en bonne partie avec le langage R le paradigme de la
programmation fonctionnelle. Tel qu'expliqué sommairement à la
\autoref{sec:informatique:concepts:paradigmes}, dans ce paradigme un programme
est constitué d'une suite d'appels de fonctions.

L'approche de programmation fonctionnelle dans R fait aussi en sorte
qu'une fonction est traitée comme n'importe quel autre objet. Entre
autres choses, cela signifie que:
\begin{itemize}
\item le contenu d'une fonction (son code source) est toujours
  accessible;
\item une fonction peut accepter en argument une autre fonction;
\item une fonction peut retourner une fonction comme résultat;
\item l'utilisateur peut définir de nouvelles fonctions.
\end{itemize}

Étudions un exemple très simple, pas véritablement utile en pratique
au-delà de ses vertus pédagogiques. Nous voulons élever un
nombre au carré. Pour faire ce calcul à répétition et de manière
abstraite --- c'est-à-dire, sans avoir à se demander à chaque fois
comment le calcul est fait ---, nous définissons une nouvelle
fonction \code{square}.
<<echo=TRUE>>=
square <- function(x) x * x
@

L'expression ci-dessus peut se lire ainsi:

\begin{center}
  \setlength{\unitlength}{7mm}
  \begin{picture}(18,4.2)
    \linethickness{1pt}

    \put(0,1){\code{square}}     \put(0,3.5){\code{square}}
    \put(2.2,1){est}             \put(2.3,3.5){\code{<-}}
    \put(3.2,1){une fonction}    \put(3.5,3.5){\code{function}}
    \put(6.6,1){
      \begin{minipage}[t]{5.714\unitlength} % ~= 40mm
        \centering
        qui prend en argument
        une valeur \code{x}
      \end{minipage}}           \put(8.9,3.5){\code{( x )}}
    \put(12.8,1){%
      \begin{minipage}[t]{4.571\unitlength} % ~= 32mm
        \centering
        et la multiplie par elle-même.
      \end{minipage}}           \put(14.4,3.5){\code{x * x}}

    \put(0.9,3.2){\vector(0,-1){1.6}}
    \put(2.6,3.2){\vector(0,-1){1.6}}
    \put(4.6,3.2){\vector(0,-1){1.6}}
    \put(9.7,3.2){\vector(0,-1){1.6}}
    \put(15.2,3.2){\vector(0,-1){1.6}}
  \end{picture}
\end{center}

Nous pouvons ensuite utiliser la fonction \code{square} de manière
intuitive comme n'importe quelle autre fonction dans R.
<<echo=TRUE>>=
square(5)
@

L'approche de programmation fonctionnelle fait en sorte que les appels
de fonctions peuvent être placés les uns à la suite des autres, comme
la composition de fonctions $g \circ f$ en mathématiques. Pour élever
un nombre à la puissance $4$, nous pouvons appliquer deux fois la
fonction \code{square} à un argument.
<<echo=TRUE>>=
square(square(5))
@


\section{Définition d'une fonction}
\label{sec:fonctions:definition}

Comme nous l'avons vu dans l'exemple ci-dessus, on définit une
nouvelle \index{fonction!définition}fonction dans R à l'aide de la
fonction \Icode{function}. La syntaxe exacte de la définition d'une
fonction est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
\meta{nom} <- function(\meta{arguments}) \meta{corps}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \meta{nom} est le nom de la fonction (les règles pour les noms
  de fonctions sont les mêmes que celles présentées à la
  \autoref{sec:premiers:objets:noms} pour tout autre objet).

  Nous souhaitons généralement attribuer un nom à une fonction, ne
  serait-ce que pour pouvoir la réutiliser. Cela dit, c'est tout à
  fait optionnel. En effet, l'appel à \icode{function} retourne déjà
  une fonction et si aucun nom n'est attribué à cet objet, on obtient
  ce qui est appelé une \index{fonction!anonyme}\emph{fonction
    anonyme}. Les fonctions anonymes sont particulièrement utiles avec
  les fonctions d'application qui seront étudiées au
  \autoref{chap:application}.

\item \meta{arguments} est la liste des arguments formels de la
  fonction, séparés par des virgules.

  Une fonction peut n'avoir aucun \index{fonction!argument
    formel}argument formel ou plusieurs. Il n'y a pas de limite
  pratique au nombre d'arguments formels que peut avoir une fonction.
  Les arguments peuvent être des symboles, des constructions de la
  forme \code{symbole = défaut}, ou encore l'argument formel spécial
  `\icode{...}'.

  Lorsqu'un symbole seul est utilisé comme argument, il indique le nom
  de celui-ci. L'objet de ce nom sera disponible à l'intérieur de la
  fonction.
<<echo=TRUE>>=
f <- function(x) 2 * x + 1
f(2)
@

  La construction \code{symbole = défaut} indique la valeur par défaut
  de l'argument \code{symbole}, c'est-à-dire la valeur de l'argument si
  aucune n'est spécifiée dans l'appel de la fonction.
<<echo=TRUE>>=
f <- function(x = 0) 2 * x + 1
f(2)
f()
@

  Enfin, l'argument spécial `\Icode{...}' peut contenir un nombre
  arbitraire d'éléments. La fonction y ayant recours se trouve donc à
  accepter un nombre variable d'arguments. On utilise généralement
  `\code{...}' pour passer des arguments tels quels à une autre fonction
  qui, elle, saura quoi faire de ceux-ci. Vous trouverez un
  meilleur exemple à la \autoref{sec:fonctions:exemples} que ce que nous
  pourrions faire ici en quelques lignes.

\item \meta{corps} est une expression ou un groupe d'expressions
  réunies par des accolades, tel qu'expliqué à la
  \autoref{sec:premiers:commandes:regroupement}.
\end{itemize}


\section{Retourner des résultats}
\label{sec:fonctions:resultats}

La plupart des fonctions sont écrites dans le but de retourner un
\index{fonction!résultat}résultat. Or, les règles d'interprétation
d'un regroupement d'expressions présentées à la
\autoref{sec:premiers:commandes:regroupement} s'appliquent ici au corps
de la fonction: une fonction retourne tout simplement le résultat de
sa \emph{dernière expression}.

Ainsi, on évitera que la dernière expression soit une affectation. En
effet, la fonction ne retournerait alors rien et nous ne pourrions
utiliser une construction de la forme \code{x <- f()} pour affecter le
résultat de la fonction à un objet.

\cautionbox{Il existe une fonction \icode{return} pour terminer
  immédiatement l'exécution d'une fonction et retourner un résultat;
  nous l'étudierons plus formellement avec les structures de contrôle
  à la \autoref{sec:fonctions:controle}. Cependant, l'utilisation de
  \code{return} à la toute fin d'une fonction est tout à fait inutile
  et c'est considéré comme du mauvais style en R.}

<<script, results=hide>>=
###
### PROGRAMMATION FONCTIONNELLE  `\labelline{fonctions:definition}`
###

## Les fonctions sont des objets comme les autres dans R. Cela
## signifie que:
##
## - le contenu d'une fonction (son code source) est toujours
##   accessible;
## - une fonction peut accepter en argument une autre
##   fonction;
## - une fonction peut retourner une fonction comme résultat;
## - l'utilisateur peut définir de nouvelles fonctions.
seq                        # contenu est le code source
mode(seq)                  # mode est "function"
rep(seq(5), 3)             # fonction argument d'une fonction
lapply(1:5, seq)           # idem
mode(ecdf(rpois(100, 1)))  # résultat de ecdf est une fonction
ecdf(rpois(100, 1))(5)     # évaluation en un point
c(seq, rep)                # vecteur de fonctions!

###
### DÉFINITION D'UNE FONCTION
###

## On définit une nouvelle fonction avec la syntaxe suivante:
##
##   <nom> <- function(<arguments>) <corps>
##
## où
##
## - 'nom' est le nom de la fonction;
## - 'arguments' est la liste des arguments, séparés par des
##    virgules;
## - 'corps' est le corps de la fonction, soit une expression
##   ou un groupe d'expressions réunies par des accolades { }.
##
## Une fonction retourne toujours la valeur de la *dernière*
## expression de celle-ci.
##
## Voici un exemple trivial.
square <- function(x) x * x
square(10)

## Supposons que l'on veut écrire une fonction pour calculer
##
##   f(x, y) = x (1 + xy)^2 + y (1 - y) + (1 + xy)(1 - y).
##
## Deux termes sont répétés dans cette expression. On a donc
##
##   a = 1 + xy
##   b = 1 - y
##
## et f(x, y) = x a^2 + yb + ab.
##
## Une manière élégante de procéder au calcul de f(x, y) qui
## adopte l'approche fonctionnelle fait appel à une fonction
## intermédiaire à l'intérieur de la première fonction. (Il y
## a ici des enjeux de «portée lexicale» sur lesquels nous
## reviendrons en détail au chapitre 4.)
f <- function(x, y)
{
    g <- function(a, b)
        x * a^2 + y * b + a * b
    g(1 + x * y, 1 - y)
}
f(2, 3)

### FONCTION ANONYME

## Comme le nom du concept l'indique, une fonction anonyme est
## une fonction qui n'a pas de nom. C'est parfois utile pour
## des fonctions courtes utilisées dans une autre fonction.
##
## Reprenons l'exemple précédent en généralisant les
## expressions des termes 'a' et 'b'. La fonction 'f'
## pourrait maintenant prendre en arguments 'x', 'y' et des
## fonctions pour calculer 'a' et 'b'.
f <- function(x, y, fa, fb)
{
    g <- function(a, b)
        x * a^2 + y * b + a * b
    g(fa(x, y), fb(x, y))
}

## Plutôt que de définir deux fonctions pour les arguments
## 'fa' et 'fb', on passe directement des fonctions anonymes
## en argument.
f(2, 3,
  function(x, y) 1 + x * y,
  function(x, y) 1 - y)

### VALEUR PAR DÉFAUT D'UN ARGUMENT

## La fonction suivante calcule la distance entre deux points
## dans l'espace euclidien à 'n' dimensions, par défaut par
## rapport à l'origine.
##
## Remarquez comment nous spécifions une valeur par défaut,
## l'origine, pour l'argument 'y'.
##
## (Note: la fonction 'sum'... somme tous les éléments d'un
## vecteur.)
dist <- function(x, y = 0) sum((x - y)^2)

## Quelques calculs de distances.
dist(c(1, 1))                # (1, 1) par rapport à l'origine
dist(c(1, 1, 1), c(3, 1, 2)) # entre (1, 1, 1) et (3, 1, 2)

### ARGUMENT '...'

## Nous illustrons l'utilisation de l'argument '...' de la
## manière suivante pour le moment. Nous utiliserons davantage
## cet argument avec les fonctions d'application.
##
## La fonction 'curve' prend en argument une expression
## mathématique et trace la fonction pour un intervalle donné.
curve(x^2, from = 0, to = 2)

## Nous souhaitons, pour une raison quelconque, que tous nos
## graphiques de ce type (et seulement de ce type) soient
## tracés en orange.
curve(x^2, from = 0, to = 2, col = "orange")

## Plutôt que de redéfinir entièrement la fonction 'curve'
## avec tous ses arguments (et il y en a plusieurs), nous
## pouvons écrire une petite fonction qui, grâce à l'argument
## '...', accepte tous les arguments de 'curve'.
ocurve <- function(...) curve(..., col = "orange")
ocurve(x^2, from = 0, to = 2)           #-*- `\labelline{fonctions:definition:fin}`
@

\gotorbox{Étudiez les lignes \reflines{fonctions:definition}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:fonctions:exemples} pour des exemples
  additionnels de définitions de fonctions et, surtout, d'utilisation
  des fonctions anonymes et de l'argument `\code{...}`.}


\section{Structures de contrôle}
\label{sec:fonctions:controle}

Comme bien d'autres machines conçues par les humains, les ordinateurs
ont toujours été mis à contribution pour les tâches répétitives et
fastidieuses. Ce n'est donc pas pour rien que tous les langages de
programmation prévoient un ou plusieurs mécanismes pour répéter une
procédure un certain nombre de fois ou jusqu'à ce qu'une condition
soit remplie.

La répétition de procédures, la sortie forcée d'un programme ou le
choix entre diverses procédures sont réalisés à l'aide de commandes
spéciales appelées %
\index{structures de contrôle}\emph{structures de contrôle}. %
On retrouve les structures de boucles dans la grande majorité des
langages de programmation, du moins chez les descendants de
\index{Fortran}Fortran et \index{Algol}d'Algol.


\subsection{Exécution conditionnelle}
\label{sec:fonctions:controle:if}

Les premières structures de contrôle que nous étudions sont les
structures d'exécution conditionnelle. La plupart des programmes
doivent pouvoir effectuer des tests pour choisir entre deux actions
possibles ou plus. Par exemple, le programme pourrait s'arrêter avec
un message d'erreur si les arguments fournis par l'utilisateur ne sont
pas valides, effectuer des calculs différents selon la valeur d'un
argument, ou retourner un résultat prédéfini si un argument satisfait
certaines conditions.

La structure \Indexcode{if}\Indexcode{else}\code{if ... else ...}
permet d'exécuter une expression ou une autre selon qu'une condition
est vraie ou fausse. La clause alternative est optionnelle. Les
syntaxes des deux formulations sont les suivantes:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
else
    \meta{alternative}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{condition} est une expression dont le résultat est une
  valeur \code{TRUE} ou \code{FALSE} \emph{unique}. C'est une erreur
  fréquente de construire un test de telle sorte que \meta{condition}
  est un vecteur, ce qui n'a guère de sens. Les fonctions \icode{any},
  \icode{all} (\autoref{sec:premiers:internes:tests}) et \icode{isTRUE}
  se révèlent utiles dans les clauses \code{if} pour réduire les
  vecteurs booléens à une valeur unique.
\item \meta{conséquence} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{TRUE}.
\item \meta{alternative} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{FALSE}.
\end{itemize}

\warningbox{Il tombe sous le sens que «vrai» est vrai, n'est-ce pas?
  Prenez donc garde de ne pas écrire des expressions qui reviennent à
  tester \verb|if (TRUE == TRUE)|. Oui, j'ai souvent rencontré
  de telles constructions!}

Pour choisir entre plus de deux possibilités, il est possible
d'emboiter des structures \code{if ... else ...} les unes dans les
autres.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition 1})
    \meta{conséquence 1}
else if (\meta{condition 2})
    \meta{conséquence 2}
velse
    \meta{alternative}
\end{Verbatim}
\end{Schunk}

Au-delà de trois ou quatre possibilités, il vaut souvent mieux
utiliser la fonction \Icode{switch}. Sa syntaxe est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
switch(\meta{expression}, \meta{cas.1} = \meta{action.1},
                          \meta{cas.2} = \meta{action.2}, ...)
\end{Verbatim}
\end{Schunk}
La fonction évalue d'abord \meta{expression}. Si le résultat est une
valeur numérique $j$, alors \meta{action.$j$} est exécutée. Si le
résultat de \meta{expression} est l'une des chaines de caractères
\meta{cas.1}, \meta{cas.2}, \dots, alors c'est l'action correspondante
qui est exécutée.
<<echo=TRUE>>=
switch(2, 2 + 3, mean(1:10), 5:1)
switch("foo", foo = 2 + 3, bar = mean(1:10))
@

Enfin, la fonction \Icode{ifelse} --- une sorte de version vectorielle
de la structure \code{if ... else ...} --- permet de calculer des
valeurs selon les résultats d'un test sur un vecteur. Sa syntaxe est
la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
ifelse(\meta{test}, \meta{oui}, \meta{non})
\end{Verbatim}
\end{Schunk}
Les arguments \meta{test}, \meta{oui} et \meta{non} sont trois
vecteurs de la même longueur
\begin{itemize}
\item \meta{test} est un vecteur booléen.
\item \meta{oui} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{TRUE} dans \meta{test}.
\item \meta{non} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{FALSE} dans \meta{test}.
\end{itemize}
<<echo=TRUE>>=
x <- c(-2, 3, -1, 0, 5, 1)
ifelse(x < 0, -x, x)
@

Une fois que l'on a compris son fonctionnement, la fonction
\icode{ifelse} peut apparaitre comme un outil de choix dans notre
arsenal de fonctions R, en particulier pour la programmation de
fonctions mathématiques définies par branches. En réalité, cependant,
\code{ifelse} est très lente. Dans la plupart des cas, il vaut mieux
lui préférer des constructions moins élégantes, mais bien plus
rapides. En particulier, la rubrique d'aide de la fonction souligne
que la structure \code{if ... else ...} est beaucoup plus efficace si
\meta{test} est un vecteur de longueur $1$.

\subsection{Boucles itératives}
\label{sec:fonctions:controle:boucles}

Il existe deux grandes manières de répéter des calculs en
programmation: par \index{iteration@itération}itération ou par
\index{recursivite@récursivité}récursivité. Une procédure itérative
répète un bloc d'instructions, habituellement avec un léger changement
d'état, jusqu'à ce qu'un nombre de répétitions soit atteint ou qu'une
condition soit satisfaite. C'est ce que l'on appelle communément une
\emph{boucle} (\emph{loop}). Très intuitives, les boucles itératives
sont particulièrement utilisées en programmation impérative.

La procédure récursive, quant à elle, est caractérisée par le fait
qu'elle s'invoque elle-même jusqu'à ce qu'une condition d'arrêt soit
satisfaite. Moins intuitive, mais généralement jugée plus élégante,
elle est particulièrement répandue en programmation fonctionnelle et
en intelligence artificielle.\footnote{%
  Si l'on définit plus largement l'itération comme la répétition d'un
  bloc d'instructions, alors la récursivité n'est qu'une forme
  d'itération. Il est toutefois d'usage en informatique de distinguer
  les procédures itératives des procédures récursives comme je le
  fais ici.}

Nous reviendrons sur la récursivité à la
\autoref{sec:fonctions:recursivite}. La présente section étudie les
structures de contrôles itératives de R. Elles sont de trois types: la
boucle à contrôle par dénombrement (boucle \code{for}), la boucle à
pré-condition «tant que» (boucle \code{while}) et la boucle à
condition d'arrêt (boucle \code{repeat}).

La boucle à dénombrement \Icode{for} sert pour répéter une procédure
un nombre prédéterminé de fois. La syntaxe de la boucle \code{for} est
la suivante, dans R:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
for (\meta{variable} in \meta{suite})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{variable} est un \emph{compteur} ou, plus spécifiquement,
  un \emph{itérateur} qui prend successivement les valeurs contenues
  dans \meta{suite}. La variable est habituellement --- mais pas
  nécessairement --- utilisée dans les calculs à l'intérieur de la
  boucle.
\item \meta{suite} est un vecteur de valeurs. À noter que \meta{suite}
  n'a pas à être composée de nombres consécutifs, ni même de nombres,
  en fait.
\item \meta{expression} est le contenu de la boucle à proprement
  parler. Comme d'habitude, si le contenu est constitué de plusieurs
  expressions, elles doivent être regroupées des accolades \verb={ }=.
\end{itemize}

La boucle à pré-condition \Icode{while} exécute une procédure tant
qu'une condition est satisfaite. La condition étant vérifiée avant
d'entrer dans la boucle, celle-ci peut ne jamais s'exécuter. La
syntaxe de la boucle \code{while} est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
while(\meta{condition})
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{condition} est une expression dont le résultat est une
  valeur \code{TRUE} ou \code{FALSE} unique.
\item \meta{expression} est une expression ou un groupe d'expressions
  entre accolades \verb={ }= qui sont exécutées tant que
  \meta{condition} est \code{TRUE}.
\end{itemize}

Plusieurs langages de programmation comportent une structure itérative
à post-condition «tant que» (boucle \code{do ... while}) ou «jusqu'à
ce que» (boucle \code{do ... until}), voire les deux. Dans R, la
boucle à post-condition prend plutôt la forme d'une boucle à condition
d'arrêt \Icode{repeat}. La syntaxe de cette boucle est on ne peut plus
simple:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
repeat
    \meta{expression}
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \meta{expression} est l'expression ou le groupe d'expressions à
  répéter. En pratique, pour éviter que la boucle ne se répète indéfiniment,
  \meta{expression} est toujours un groupe d'expressions comportant un
  test d'arrêt.
\end{itemize}

Le test d'arrêt d'une boucle \icode{repeat} utilise habituellement la
commande \icode{break} (\autoref{sec:fonctions:controle:flux}) pour
forcer la sortie de la boucle. Puisque le test se trouve à l'intérieur
de la boucle --- généralement à ou vers la fin ---, une boucle
\code{repeat} est toujours exécutée au moins une fois.

\subsection{Contrôle du flux}
\label{sec:fonctions:controle:flux}

Les commandes de contrôle du flux permettent d'infléchir le
déroulement normal d'une boucle.

\begin{ttscript}{break}
\item[\Icode{break}] Force la sortie de la boucle courante. La
  commande \code{break} peut être utilisée dans les boucles
  \icode{for} ou \icode{while}, mais elle est presque indissociable de
  la boucle \icode{repeat}. Si l'on assemble les morceaux des sections
  précédentes, une boucle \icode{repeat} est généralement construite
  ainsi:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\[\]]
repeat
{
    \meta[expression]
    if (\meta[condition])
        break
}
\end{Verbatim}
\end{Schunk}
\item[\Icode{next}] Force le passage à la prochaine itération de la
  boucle \icode{for}, \icode{while} ou \icode{repeat}. Comme
  \icode{break}, la commande est généralement utilisée à l'intérieur
  d'une structure conditionnelle.
\end{ttscript}

Bien qu'elles ne soient pas à proprement parler des commandes de
contrôle de flux, les trois fonctions ci-dessous permettent néanmoins
de contrôler l'exécution d'une fonction.

\begin{ttscript}{warning}
\item[\Icode{return}] Force la sortie immédiate de la fonction et
  retourne l'objet en argument.
\item[\Icode{stop}] Force la sortie immédiate de la fonction avec le
  message d'\index{erreur}erreur donné en argument.
\item[\Icode{warning}] Envoie le message
  d'\index{avertissement}avertissement donné en argument à R. L'effet
  dépend de la valeur de \code{options("warn")}. Par défaut, tous les
  avertissements sont affichés à la console après l'exécution de la
  fonction.
\end{ttscript}

<<script, results=hide>>=
###
### STRUCTURES DE CONTRÔLE  `\labelline{fonctions:controle}`
###

### EXÉCUTION CONDITIONNELLE

## Il est quelque peu délicat d'illustrer l'utilisation de la
## fonction 'if' à l'extérieur d'une fonction. Nous aurons
## l'occasion de l'utiliser plusieurs fois dans les exemples
## de fonctions itératives, plus loin.
##
## Pour l'instant, contentons-nous de ces deux petits exemples
## qui démontrent un usage adéquat de 'if'.
x <- c(-1, 2, 3)
if (any(x < 0)) print("il y a des nombres négatifs")
if (all(x > 0)) print("tous les nombres sont positifs")

## Première erreur fréquente dans l'utilisation de 'if': la
## condition en argument n'est pas une valeur unique.
##
## Portez bien attention au message d'avertissement de R: le
## test a été effectué, mais uniquement avec la première
## valeur du vecteur booléen 'x < 0'. Comme, dans le présent
## exemple, la première valeur de 'x' est négatif,
## l'expression 'print' est exécutée.
if (x < 0)  print("il y a des nombres négatifs")

## Seconde erreur fréquente: tester que vrai est vrai. (Ce
## n'est pas une «erreur» au sens propre puisque la syntaxe
## est valide, mais c'est un non-sens sémantique, une forme de
## pléonasme comme «monter en haut» ou «deux jumeaux».)
##
## Voici un exemple de construction avec un test inutile. Le
## résultat de 'any' est déjà TRUE ou FALSE, alors pas besoin
## de vérifier si TRUE == TRUE ou si FALSE == TRUE.
if (any(x < 0) == TRUE) print("il y a des nombres négatifs")

## Détail intéressant sur la structure 'if ... else ...': il
## est possible de l'utiliser comme une fonction normale,
## c'est-à-dire d'affecter le résultat de la structure à une
## variable.
##
## D'abord, le style de programmation le plus usuel:
## l'affectation est effectuée à l'intérieur des clauses 'if'
## et 'else'.
f <- function(y)
{
    if (y < 0)
        x <- "rouge"
    else
        x <- "jaune"
    paste("la couleur est:", x)
}
f(-2)
f(3)

## Ensuite, la version où le résultat de 'if ... else ...' est
## directement affecté dans la variable. C'est plus compact et
## très lisible si la conséquence et l'alternative sont des
## expressions courtes.
f <- function(y)
{
    x <- if (y < 0) "rouge" else "jaune"
    paste("la couleur est:", x)
}
f(-2)
f(3)

## De l'inefficacité de 'ifelse'.
##
## Supposons que l'on veut une fonction *vectorielle* pour calculer
##
##   f(x) = x + 2, si x < 0
##        = x^2,   si x >= 0.
##
## On se tourne naturellement vers ifelse() pour ce genre de
## calcul. Voyons voir le temps de calcul.
x <- sample(-10:10, 1e6, replace = TRUE)
system.time(ifelse(x < 0, x + 2, x^2))

## Solution alternative n'ayant pas recours à ifelse(). C'est
## plus long à programmer, mais l'exécution est néanmoins plus
## rapide.
f <- function(x)
{
   y <- numeric(length(x)) # contenant
   w <- x < 0              # x < 0 ou non
   y[w] <- x[w] + 2        # calcul pour les x < 0
   w <- !w                 # x >= 0 ou non
   y[w] <- x[w]^2          # calcul pour les x >= 0
   y
}
system.time(f(x))

### BOUCLES ITÉRATIVES ET CONTRÔLE DU FLUX

## Méthode du point fixe
##
## Nous allons illustrer l'utilisation des boucles avec la
## méthode du point fixe. On dit qu'une valeur x est un «point
## fixe» d'une fonction f si cette valeur satisfait l'équation
##
##   x = f(x).
##
## La méthode numérique de recherche du point fixe d'une
## fonction f est simple et puissante: elle consiste à choisir
## une valeur de départ, puis à évaluer successivement f(x),
## f(f(x)), f(f(f(x))), ... jusqu'à ce que la valeur change
## «peu».
##
## L'algorithme est donc très simple:
##
## 1. Choisir une valeur de départ x[0].
## 2. Pour n = 1, 2, 3, ...
##    2.1 Calculer x[n] = f(x[n - 1])
##    2.2 Si |x[n] - x[n - 1]|/|x[n]| < TOL, passer à
##        l'étape 3.
## 3. Retourner la valeur x[n].
##
## Avant de poursuivre votre lecture, tentez d'identifier le
## meilleur type de boucle ('for', 'while' ou 'repeat') à
## utiliser pour programmer cet algorithme.

## Comme première illustration, supposons que nous avons
## besoin d'une fonction pour calculer la racine carrée d'un
## nombre, c'est à dire la valeur positive de y satisfaisant
## l'équation y^2 = x. Cette équation peut se réécrire sous
## forme de point fixe ainsi:
##
##   y = x/y.
##
## La méthode du point fixe ne converge pas avec cette
## fonction (l'algorithme oscille perpétuellement entre deux
## valeurs).
##
## Une variante de l'équation y^2 = x fonctionnera mieux (en
## fait, on peut démontrer que l'algorithme converge toujours
## pour cette fonction):
##
##   y = (y - x/y)/2.
##
## Voici une première mise en oeuvre de notre fonction 'sqrt'
## utilisant la méthode du point fixe. Puisqu'il faut au
## minimum vérifier si la valeur initiale est un point fixe,
## nous utilisons une boucle 'repeat'.
sqrt <- function(x, start = 1, TOL = 1E-10)
{
    repeat
    {
        y <- (start + x/start)/2
        if (abs(y - start)/y < TOL)
            break
        start <- y
    }
    y
}
sqrt(9, 1)
sqrt(225, 1)
sqrt(3047, 50)

## Formidable. Toutefois, si nous voulions utiliser la méthode
## du point fixe pour résoudre une autre équation, il faudrait
## écrire une nouvelle fonction qui serait pour l'essentiel
## identique, sinon pour le calcul de la fonction
## (mathématique) f(x) pour laquelle nous cherchons le point
## fixe.
##
## Créons donc une fonction de point fixe générale qui prendra
## f(x) en argument.
fixed_point <- function(FUN, start, TOL = 1E-10)
{
    repeat
    {
        x <- FUN(start)
        if (abs(x - start)/x < TOL)
            break
        start <- x
    }
    x
}

## Nous pouvons ensuite écrire une nouvelle fonction 'sqrt'
## utilisant 'fixed_point'. Nous y ajoutons un test de
## validité de l'argument, pour faire bonne mesure.
sqrt <- function(x)
{
    if (x < 0)
        stop("cannot compute square root of negative value")

    fixed_point(function(y) (y + x/y)/2, start = 1)
}
sqrt(9)
sqrt(25)
sqrt(3047)

## Suppression de la fonction pour éviter qu'elle n'entre en
## conflit avec celle de R.
rm("sqrt")                              #-*- `\labelline{fonctions:controle:fin}`
@

\gotorbox{Étudiez les lignes \reflines{fonctions:controle}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:fonctions:exemples}.}


\section{Récursivité}
\label{sec:fonctions:recursivite}

En tant que langage de programmation fonctionnel, R admet tout
naturellement les procédures récursives. Lorsque la fonction récursive
s'invoque elle-même, nous pouvons remplacer le nom de la fonction par
\Icode{Recall}. Cela rend l'appel récursif indépendant du nom de la
fonction, ce qui peut s'avérer bien utile en cas de changement du nom
de la fonction.

Par exemple, nous pouvons réécrire ainsi la mise en œuvre récursive de
la fonction factorielle de la \autoref{fig:presentation:scheme_vs_s},
à la \autopageref{fig:presentation:scheme_vs_s}:
\begin{Schunk}
\begin{Sinput}
factorial <- function(n)
    if (n == 1) 1 else n * Recall(n - 1)
\end{Sinput}
\end{Schunk}

\warningbox{Le temps système requis pour la création des
  environnements lors de chaque appel de fonction
  (\autoref{chap:implementation}) rend les fonctions récursives peu
  efficaces en R.}


\section{Syndrome de la plaque à biscuits}
\label{sec:fonctions:syndrome}

La suite de Fibonacci est une suite de nombres entiers très connue.
Les deux premiers termes de la suite sont $0$ et $1$ et tous les
autres sont la somme des deux termes précédents. Mathématiquement, les
valeurs de la suite de Fibonacci sont données par la fonction
\begin{align*}
  f(0) &= 0 \\
  f(1) &= 1 \\
  f(n) & = f(n - 1) + f(n - 2), \quad n \geq 2.
\end{align*}
Le quotient de deux termes successifs converge vers
$\phi = (1 + \sqrt{5})/2$, le nombre d'or.\footnote{%
  On prête au nombre d'or toutes sortes de propriétés, certaines même
  d'ordre mystique. Il est en tout cas au cœur d'un des romans les
  plus vendus de tous les temps, \emph{Da~Vinci Code} (Dan Brown,
  2003).} %

Le calcul du $n${\ieme} terme de la suite de Fibonacci se prête tout
naturellement à une mise en œuvre récursive, tel qu'expliqué dans
\citet[chapitre~9]{Stephens:algorithms:2013}.

Nous nous penchons ici sur un problème légèrement différent: calculer
les $n$ premiers termes de la suite de Fibonacci. Il est plus simple
de procéder par itération pour résoudre ce problème. La fonction
\code{fibonacci0}, dont la définition se trouve à la
\autoref{fig:application:fibonacci0}, propose une première solution.

\begin{figure}
\begin{Verbatim}[frame=single]
fibonacci0 <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- c(0, 1)
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
\end{Verbatim}
  \caption{Première version d'une fonction pour calculer les $n$
    premiers termes de la suite de Fibonacci}
  \label{fig:application:fibonacci0}
\end{figure}

Avant d'aller plus loin, quelques commentaires sur \code{fibonacci0}.
\begin{itemize}
\item La fonction n'étant valide que pour un argument \code{nterm}
  supérieur ou égal à $1$, elle affiche un message d'erreur si ce
  n'est pas le cas.
\item La fonction intercepte le cas trivial \code{nterm == 1} dès le
  départ.
\item Lors de sa création, l'objet \code{x} contient déjà le résultat
  du cas \code{nterm == 2}. La fonction devra donc éviter de faire
  d'autres calculs pour ce cas.
\item En créant la suite de la boucle \icode{for} avec
  \code{seq\_len}, la boucle ne s'exécute pas lorsque \code{nterm ==
    2} puisque le résultat \code{seq\_len(0)} est un vecteur vide.
\item La seule expression de la boucle \code{for} ajoute
  successivement un terme au vecteur \code{x}.
\end{itemize}

<<echo=FALSE>>=
fibonacci0 <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- c(0, 1)
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
@
<<echo=TRUE>>=
fibonacci0(1)
fibonacci0(2)
fibonacci0(5)
@

Bien que valide --- comme les exemples d'utilisation de la fonction le
démontrent --- la fonction \code{fibonacci0} souffre d'un gros défaut:
la taille de l'objet \code{x} doit constamment augmenter pour stocker
une nouvelle valeur de la suite de Fibonacci.

Tentons une analogie alimentaire pour cette manière de procéder. Pour
ranger des biscuits frais sortis du four, vous prenez un premier
biscuit et vous le rangez dans un plat ne pouvant contenir qu'un seul
biscuit. Arrivés au second biscuit, constatant que le contenant n'est
pas assez grand, vous sortez un plat pouvant contenir deux biscuits,
vous changez le premier biscuit de plat et vous y rangez aussi le
second biscuit. Arrivés au troisième biscuit, le petit manège
recommence, et ainsi de suite jusqu'à ce que le plateau de biscuits
soit épuisé. C'est ce que je nomme, non sans un sourire en coin, le
Syndrome de la plaque à
biscuits{\texttrademark}\index{syndrome@Syndrome de la plaque à
  biscuits}\index{biscuits|see{Syndrome de la plaque à biscuits}}.

Le manège décrit ci-dessus se reproduit à l'identique dans la mémoire
de l'ordinateur, l'odeur des biscuits chauds en moins. En effet,
l'ordinateur doit constamment allouer de la nouvelle mémoire et
déplacer les termes déjà sauvegardés au fur et à mesure que le vecteur
\code{x} grandit. Vous aurez compris qu'une telle façon de faire est à
éviter absolument lorsque c'est possible --- et ça l'est la plupart du
temps.

Quand nous savons quelle sera la longueur finale d'un objet, comme
c'est le cas dans cet exemple, il vaut mieux créer un contenant vide
de la bonne longueur et le remplir par la suite. La fonction
\code{fibonacci} de la \autoref{fig:application:fibonacci} évite le
Syndrome.

\begin{figure}
\begin{Verbatim}[frame=single]
fibonacci <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- numeric(nterm)  # création du contenant
    x[2] <- 1            # x[1] vaut déjà 0
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
\end{Verbatim}
  \caption{Fonction pour calculer les $n$ premiers termes de la suite
    de Fibonacci ne souffrant pas du Syndrome de la plaque à
    biscuits{\texttrademark}}
  \label{fig:application:fibonacci}
\end{figure}

<<echo=FALSE>>=
fibonacci <- function(nterm)
{
    if (nterm < 1)
        stop("'nterm' doit être supérieur ou égal à 1")
    if (nterm == 1)
        return(0)
    x <- numeric(nterm)  # création du contenant
    x[2] <- 1            # x[1] vaut déjà 0
    for (i in seq_len(nterm - 2))
        x[i + 2] <- x[i + 1] + x[i]
    x
}
@
<<echo=TRUE>>=
fibonacci(1)
fibonacci(2)
fibonacci(5)
@

Avons-nous vraiment gagné en efficacité? Le code informatique de la
\autoref{sec:application:exemples} permet de vérifier que la seconde
fonction est de trois à cinq fois plus rapide que la première!


\section{Bonnes pratiques de la programmation informatique}
\label{sec:fonctions:pratiques}

De manière générale, le développement et la maintenance de code
informatique repose sur la contribution de plusieurs personnes. En
effet, il est plutôt rare, dans le milieu professionnel, d'être appelé
à concevoir un programme informatique à partir d'une page blanche et
en complète autarcie, c'est-à-dire sans que quiconque n'ait à
interagir avec le code à un stade ou à un autre. Une grande part du
travail de programmation consiste à corriger, à mettre à jour ou à
améliorer du code existant. Dans ce contexte, l'adhésion à un certain
nombre de normes et de bonnes pratiques permet de faciliter le travail
de tous les intervenants et de réduire les risques d'erreurs. Cette
section présente quelques unes de ces bonnes pratiques à adopter en
matière de style de programmation, de présentation du code et de
documentation.

\tipbox{Je me suis efforcé de respecter les bonnes pratiques
  ci-dessous dans le code informatique des sections d'exemples. Prêtez
  donc attention à la manière dont le code qui vous est fourni est
  construit et présenté.}

\subsection{Style}
\label{sec:fonctions:pratiques:style}

Il en va du code informatique comme de la prose: si le style peut
varier d'un auteur à l'autre, l'œuvre doit toujours être à la fois
agréable à lire et facile à comprendre. Bref, les meilleurs
programmeurs préfèrent la \emph{lisibilité} de leur code aux effets de
style qui n'auraient pour seul mérite d'afficher leur maitrise du
langage.

Tout programmeur devrait constamment garder en tête les trois
objectifs suivants en effectuant son travail: simplicité, clarté,
concision. Ces objectifs entrent souvent en conflit les uns avec les
autres! Tout l'art de la bonne programmation consiste donc à trouver
un juste équilibre entre les trois pôles.

\citet{Kernighan:practice:1999},
\citet{Oualline:C:1997,Oualline:C++:2003},
\citet{Kernighan:style:1978} proposent d'excellents chapitres sur le
style en programmation. Je ne saurais être aussi exhaustif que ces
auteurs établis. Néanmoins, je vous incite à porter une attention
particulière aux quelques points de style livrés en vrac, ci-dessous.

\begin{itemize}
\item Utilisez des noms de variables significatifs. Ne soyez pas ce
  collègue qui nomme les variables d'un programme \code{x}, \code{xx}
  et \code{xxx} (cas vécu). Attention, toutefois, de ne pas pousser le
  concept trop loin. Ici comme ailleurs, la clarté peut provenir de la
  concision; la terminologie\footnote{%
    Vous remarquerez que je préfère utiliser l'anglais pour les
    noms d'objets, question d'uniformité avec les identificateurs du
    langage. Chose certaine, évitez à tout prix les accents dans les
    noms d'objets.}
  \begin{Schunk}
\begin{Verbatim}
xlen <- length(x)
\end{Verbatim}
  \end{Schunk}
  est aussi claire que
  \begin{Schunk}
\begin{Verbatim}
length_of_x <- length(x)
\end{Verbatim}
  \end{Schunk}
  et bien plus simple à utiliser au fil d'un programme.

  Certains noms d'objets sans réelle signification sont tellement
  usuels qu'il est contre productif de leur préférer des versions plus
  explicites. Pensons, ici, à \code{x} comme premier argument d'une
  fonction R ou à \code{i}, \code{j} et \code{k} comme compteurs dans
  les boucles \icode{for}.

  Quant à la composition des noms d'objets formés de plusieurs mots,
  divers styles s'affrontent: \code{variable.name},
  \code{variable\_name}, \code{variableName}, \code{VariableName},
  etc. Assurez-vous simplement de suivre le standard en vigueur dans
  votre équipe de travail, le cas échéant, et, par-dessus tout, soyez
  constant. Ma préférence, qui concorde avec une grande partie du
  code source de R, va aux noms d'objets courts et entièrement en
  minuscules.
  %
\item Dès qu'elles sont disponibles, utilisez les fonctions internes
  de R au lieu de reprogrammer certaines procédures. Non seulement
  bénéficierez-vous de l'optimisation des fonctions internes, mais
  votre code gagnera également en lisibilité. Comparez
  \begin{Schunk}
\begin{Verbatim}
sum(x)/length(x)
\end{Verbatim}
  \end{Schunk}
  à
  \begin{Schunk}
\begin{Verbatim}
mean(x)
\end{Verbatim}
  \end{Schunk}
  %
\item Connaitre sur le bout des doigts la priorité des opérateurs du
  \autoref{tab:premiers:operateurs}, c'est bien; rendre explicite l'ordre
  des opérations dans une expression à l'aide de parenthèses, c'est
  mieux. N'hésitez pas à utiliser des parenthèses dès que l'ombre d'un
  doute pourrait planer sur l'ordre des opérations. D'ailleurs, à ce
  propos, \citet{Oualline:C:1997} ramène la quinzaine de règles de
  priorité des opérations (du langage C) à seulement deux:
  \begin{enumerate}
  \item La multiplication et la division précèdent l'addition et la
    soustraction.
  \item Placer tout le reste entre parenthèses.
  \end{enumerate}
  %
\item Évitez les expressions logiques complexes, surtout celles
  reposant sur la double négation. Par exemple, pour exécuter une
  expression si un vecteur contient des données manquantes, la
  condition
  \begin{Schunk}
\begin{Verbatim}
if (any(is.na(x)))
\end{Verbatim}
  \end{Schunk}
  est beaucoup plus facile à déchiffrer que la version équivalente
  d'un point de vue logique
  \begin{Schunk}
\begin{Verbatim}
if (!all(!is.na(x)))
\end{Verbatim}
  \end{Schunk}
  En revanche, s'il s'agit plutôt d'exécuter une expression quand un
  vecteur ne contient aucune donnée manquante, alors
  \begin{Schunk}
\begin{Verbatim}
if (all(!is.na(x)))
\end{Verbatim}
  \end{Schunk}
  est plus simple que
  \begin{Schunk}
\begin{Verbatim}
if (!any(is.na(x)))
\end{Verbatim}
  \end{Schunk}

  De plus, le conseil précédent sur la priorité des opérations est
  particulièrement indiqué avec les opérations logiques. Sauriez-vous
  confirmer, sans consulter le \autoref{tab:premiers:operateurs}, l'ordre
  des opérations dans l'expression logique suivante?\footnote{%
    C'est \code{(!p) | (q \& r)}.}
  \begin{Schunk}
\begin{Verbatim}
!p | q & r
\end{Verbatim}
  \end{Schunk}
  %
\item Lorsque vous les connaitrez, utilisez les fonctions
  d'application (\autoref{chap:application}) plutôt que des boucles
  explicites. Une expression ayant recours à une fonction
  d'application est plus concise et plus simple à décoder. Comparez
  \begin{Schunk}
\begin{Verbatim}
z <- numeric(n)
for (i in seq_len(n))
    z[i] <- mean(x[[i]])
\end{Verbatim}
  \end{Schunk}
  et
  \begin{Schunk}
\begin{Verbatim}
z <- sapply(x, mean)
\end{Verbatim}
  \end{Schunk}

  Encore ici, évitez de pousser la logique trop loin. Si une boucle
  est plus naturelle et plus simple à comprendre qu'une fonction
  d'application, optez pour la boucle. En particulier, une
  fonction d'application \icode{sapply} à l'intérieur d'une autre
  fonction \code{sapply}, ce n'est généralement ni plus efficace, ni
  plus simple à déchiffrer qu'une double boucle \icode{for}.
  %
\item Adoptez la
  \link{https://fr.wikipedia.org/wiki/Philosophie_d\%27Unix}{philosophie
    Unix}, notamment le précepte qui appelle à créer des programmes
  qui effectuent une seule chose et qui le font bien. Lorsqu'une
  fonction devient «longue» --- cela dépend du contexte, mais
  généralement dès une vingtaine de lignes en R --- il convient de la
  scinder en plusieurs blocs logiques.
  %
\item Enfin, utilisez \icode{return} uniquement pour provoquer la
  sortie anticipée d'une fonction, habituellement à l'intérieur d'une
  clause \code{if}. En d'autres termes, \code{return} n'a pas sa
  place, en R, à la toute fin d'une fonction.
\end{itemize}

\subsection{Présentation du code}
\label{sec:fonctions:pratiques:presentation}

Le code bien mis en forme est plus facile et agréable à consulter. Il
existe plusieurs chapelles dans le monde des programmeurs quant à la
«bonne façon» de présenter et, surtout, d'indenter le code
informatique.

Voyons d'abord ce qui rallie tout le monde.

En premier lieu, veillez à limiter la longueur des lignes de code à
environ 80 caractères. Ce standard remonte à l'époque des terminaux en
format texte qui ne pouvaient afficher de l'information que sur 80
colonnes. Pourquoi s'y tenir encore aujourd'hui, alors que nos écrans
d'ordinateur sont très larges? Parce que les longues lignes de texte
sont difficiles à suivre, notre œil ayant tendance à sauter à la ligne
inférieure en se déplaçant de la gauche vers la droite\footnote{%
  C'est pourquoi les journaux et les magazines sont composés en
  colonnes de texte étroites.}. %
Profitez donc plutôt de l'espace horizontal à l'écran pour afficher
des fenêtres côte-à-côte.

Si de multiples niveaux d'indentation (voir plus bas) font en sorte
qu'il manque de place à droite pour écrire du code, le problème n'est
peut-être pas tant la limite sur la longueur des lignes que la
conception même du programme. Simplifiez l'algorithme ou scindez le
programme en plusieurs fonctions.

Ensuite, aérez le code avec des lignes blanches entre les blocs
logiques et, surtout, avec des espaces. Les espaces en programmation
jouent le même rôle que dans du texte normal: elles facilitent la
lecture. En particulier, utilisez des espaces dans les circonstances
suivantes:
\begin{itemize}
\item de part et d'autre du symbole d'affectation \icode{<-}; ces
  espaces sont ajoutées automatiquement avec les raccourcis clavier
  des éditeurs spécialisés GNU~Emacs\index{Emacs}
  (\autoref{sec:emacs+ess:commandes:script}) et \index{RStudio}RStudio
  (\autoref{sec:rstudio:commandes});
\item de part et d'autre de tous les opérateurs\footnote{%
    Sauf peut-être la division: je préfère \code{(x + y)/z} à \code{(x
      + y) / z}.};
\item après les virgules;
\item avant la parenthèse ouvrante \code{(}, sauf dans les appels de
  fonction.
\end{itemize}
Comparez les deux blocs de code de la
\autoref{fig:collaboration:espaces}. Vous serez sans doute d'accord
que celui qui respecte les indications ci-dessus s'avère bien plus
lisible.

\begin{figure}
  \begin{minipage}{0.48\linewidth}
\begin{Verbatim}[frame=single]
f<-function(x,y)
{
    if(y<0)
        y<--y
    x*(1+x*y)^2
}
\end{Verbatim}
  \end{minipage}
  \hfill
  \begin{minipage}{0.48\linewidth}
\begin{Verbatim}[frame=single]
f <- function(x, y)
{
    if (y < 0)
        y <- -y
    x * (1 + x * y)^2
}
\end{Verbatim}
  \end{minipage}
  \caption[Blocs de code sans et avec les espaces appropriées]{Blocs
    de code sans (à gauche) et avec (à droite) les espaces
    appropriées. Le code de droite est plus lisible.}
  \label{fig:collaboration:espaces}
\end{figure}

Passons maintenant au dossier chaud parmi les programmeurs:
\index{indentation}l'indentation du code et la position des accolades.
Tous s'entendent au moins sur un point: il est absolument essentiel
d'indenter les blocs de code pour mettre la structure d'un programme
en évidence. En clair, cela signifie que toute expression --- ou
groupe d'expressions entre accolades --- doit être placée en retrait de
la marge de gauche dès lors qu'elle fait partie d'une structure de
contrôle ou de la définition d'une fonction. Le code de la
\autoref{fig:collaboration:espaces} est correctement indenté.

\importantbox{Ne pas du tout indenter son code est passible de la
  peine capitale, d'excommunication, de bannissement de la Terre du
  Milieu\dots\ choisissez votre châtiment.}

La source des insolubles débats se situe, comme souvent, dans les
détails: le nombre d'espaces dont il convient d'indenter le code et la
position des accolades, surtout l'accolade ouvrante. À titre
d'exemples, l'éditeur GNU~Emacs\index{Emacs} reconnaît et supporte au
moins les styles d'indentation suivants:

\vspace{\topsep}\noindent
\begin{minipage}{\linewidth}
  \begin{minipage}[t]{0.48\linewidth}
    C++
    \begin{Schunk}
\begin{Verbatim}
for (i in 1:10)
{
    expression
}
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    K\&R (1TBS\footnotemark)
    \begin{Schunk}
\begin{Verbatim}
for (i in 1:10){
     expression
}
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{minipage}
\footnotetext{\emph{One True Bracing Style}. C'est dire
  combien les amateurs de ce style le tiennent en haute estime.}

\vspace{\topsep}\noindent
\begin{minipage}{\linewidth}
  \begin{minipage}[t]{0.48\linewidth}
    Whitesmith
    \begin{Schunk}
\begin{Verbatim}
for (i in 1:10)
     {
     expression
     }
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\linewidth}
    GNU
    \begin{Schunk}
\begin{Verbatim}
for (i in 1:10)
  {
    expression
  }
\end{Verbatim}
    \end{Schunk}
  \end{minipage}
\end{minipage}
\vspace{\topsep}

Le code source de R est entièrement composé dans un style analogue aux
style C++, ci-dessus, ou RRR du \index{Emacs!mode ESS}mode ESS de Emacs:
\begin{itemize}
\item le code est indenté de quatre (4) espaces;
\item les accolades ouvrante et fermante sont placées sur leurs
  propres lignes.
\end{itemize}
Ce style peut être  considéré comme standard pour la programmation en
R.

En définitive, le style d'indentation utilisé n'a pas tellement
d'importance. Ce qui compte, c'est de se conformer au style en vigueur
dans son domaine et de demeurer constant au fil de son code.

\tipbox{Les bons éditeurs pour programmeurs permettent de configurer
  le niveau d'indentation. Consultez la documentation de votre
  éditeur.}

\subsection{Commentaires}
\label{sec:fonctions:pratiques:commentaires}

Les \index{commentaires}commentaires dans le code servent à guider le
lecteur --- peut-être vous-même, quelque temps après la rédaction ---
dans la lecture d'un programme. Le niveau de détails que devraient
comporter les commentaires fait, comme le style d'indentation, l'objet
de vifs débats.

Certains affirment qu'un bon programme se passe d'explications et que,
par conséquent, les commentaires sont en grande partie inutiles. Or,
comme le mentionne \citet{Oualline:C:1997}, un programme sans
commentaires constitue une bombe en attente d'exploser. Un jour ou
l'autre, quelqu'un devra modifier ledit programme et l'absence de
commentaires rendra la tâche beaucoup plus ardue que nécessaire.

À l'autre bout du spectre, on trouve les tenants du tout, tout
commenter, jusqu'à l'évidence.
\begin{Schunk}
\begin{Verbatim}
## calculer la somme de x
z <- sum(x)
\end{Verbatim}
\end{Schunk}
Cette pratique s'avère plus souvent qu'autrement contre productive:
non seulement force-t-elle le programmeur à passer du temps à rédiger
des commentaires sans véritable utilité, mais elle surcharge également
le code, le rendant de ce fait plus difficile à lire.

Comme bien des choses en ce monde, la meilleure solution se trouve
dans le juste milieu: commentez ni trop, ni trop peu. Les quelques
préceptes suivants, dont certains sont tirés de
\citet{Kernighan:practice:1999}, devraient vous aider à trouver un
juste équilibre.

\begin{itemize}
\item Documentez non pas ce que \emph{fait} le programme, mais
  \emph{pourquoi} il le fait. Lire qu'un bloc de code effectue tel
  calcul s'avère de peu de secours si l'on ne sait pas dans quel but
  le calcul est effectué.
\item N'enfoncez pas de portes ouvertes. Indiquer que l'expression
  \code{i <- i + 1} incrémente le compteur \code{i} n'est pas utile.
  Les commentaires doivent fournir de l'information qui ne saute pas
  aux yeux ou qui se trouve éparpillée dans le code.
\item Définissez ce que fait chaque fonction, la nature de ses
  arguments et la valeur retournée. Si une fonction R fait partie d'un
  paquetage, vous devrez nécessairement placer ces informations dans
  l'obligatoire rubrique d'aide de la fonction. Autrement, placez ces
  informations en commentaires avant la définition de la fonction.
  Vous devriez pouvoir expliquer ce que fait une fonction en une
  phrase.
\item Éclairez les zones d'ombre, ne les rendez pas plus opaques. Des
  commentaires confus, imprécis ou qui entrent carrément en
  contradiction avec le code nuisent davantage qu'ils n'aident. Soyez
  concis et gardez toujours à l'esprit de fournir au lecteur des
  informations justes et pertinentes.
\item Ne documentez pas du mauvais code, réécrivez-le. Si les
  commentaires sont beaucoup plus longs que le code auxquels ils se
  rapportent, c'est probablement qu'il est temps de réviser le code.
\end{itemize}

À moins qu'une rubrique d'aide en bonne et due forme n'accompagne une
fonction, sa définition devrait toujours être précédée d'un bloc de
commentaires contenant au minimum:
\begin{enumerate}
\item la \index{signature}\emph{signature} de la fonction (son nom
  suivi, entre parenthèses, de tous les arguments avec leur valeur par
  défaut, le cas échéant);
\item une courte description de ce que fait la fonction;
\item la liste des arguments, de leur signification et des valeurs
  admissibles;
\item la valeur retournée par la fonction.
\end{enumerate}
Il s'agit de la structure générale des rubriques d'aide de R. La
\autoref{fig:fonctions:doc} fournit un exemple de documentation pour
une fonction simple.

\tipbox{Le fichier \code{gabarit-documentation-fonction.R} livré avec
  présent document contient un gabarit que vous pouvez utiliser pour
  insérer rapidement dans vos fichiers de script la structure de base
  de la documentation d'une fonction.}

\begin{figure}
\begin{Verbatim}[frame=single]
###
### square(x)
###
##  Élévation au carré.
##
##  Arguments
##
##  x: vecteur de nombres réels.
##
##  Valeur
##
##  Vecteur de nombres réels contenant les carrés
##  des arguments.
##
square <- function(x) x * x
\end{Verbatim}
  \caption{Exemple de documentation pour une fonction simple}
  \label{fig:fonctions:doc}
\end{figure}

Dans R, le symbole numéro \code{\#} --- ou carré --- marque le début
d'un commentaire, et ce, peu importe où le symbole se trouve sur la
ligne. Il est possible de combiner les \code{\#} pour développer une
forme de hiérarchie dans les commentaires ou pour délimiter
différentes sections d'un fichier de script. Pour les fichiers
d'exemples du présent document, j'ai utilisé la
\link{https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html}{%
  convention de l'éditeur \index{Emacs}GNU~Emacs}.
\begin{itemize}
\item Les commentaires qui débutent par trois carrés, «\code{\#\#\#}»,
  sont toujours alignés sur la marge de gauche. Ils ne sont utilisés
  qu'à l'extérieur des fonctions. Ils marquent soit des sections, soit
  des entêtes de fonctions.
\item Les commentaires qui débutent par deux carrés, «\code{\#\#}»,
  sont alignés sur le niveau d'indentation courant. Lorsqu'ils
  apparaissent à l'intérieur d'une fonction, ils décrivent le rôle du
  bloc de code qui suit ou l'état de la fonction à ce stade. À
  l'extérieur des fonctions, ils marquent des sous-sections du code
  source.
\item Les commentaires qui débutent par un seul carré, «\code{\#}»,
  sont alignés sur une colonne à droite du code source. Ils servent à
  clarifier, \emph{très succinctement}, ce qu'effectue une ligne de
  code.
\end{itemize}

L'éditeur \index{RStudio}RStudio, de son côté, utilise par défaut les
niveaux de titres du langage de balisage
\link{https://daringfireball.net/projects/markdown/syntax}{Markdown},
dont la hiérarchie est exactement l'inverse de celle de Emacs. Ainsi,
les commentaires de premier niveau sont ceux qui débutent par un seul
carré, \code{\#}; les commentaires de deuxième niveau débutent par
deux carrés, \code{\#\#}, etc.

<<script, results=hide>>=
###
### BONNES PRATIQUES DE LA PROGRAMMATION INFORMATIQUE  `\labelline{fonctions:pratiques}`
###

## Afin d'illustrer l'utilité de bien présenter et de
## commenter le code, nous allons prendre une fonction dans un
## état assez pitoyable et l'améliorer graduellement.
##
## La fonction 'rgamma_ar' sert à générer des nombres
## aléatoires de la distribution gamma dont le paramètre de
## forme se trouve dans l'intervalle (0, 1) par la méthode de
## simulation dite d'«acceptation-rejet».
##
## L'algorithme de simulation d'un nombre 'x' issu d'une
## distribution Gamma(a, 1), 0 < a < 1, est le suivant:
##
## 1. Simuler u, v d'une distribution U(0, 1).
## 2. Calculer y = G^{-1}(u), où
##
##      G^{-1}(x) = ((a + e)/e * x)^(1/a),
##                            si 0 <= x <= e/(a + e)
##                = - log(((1/a) + (1/e)) * (1 - x),
##                            si e/(a + e) < x <= 1.
## 3. Si
##
##      v <= exp(-y),    si 0 <= y <= 1
##        <= y^(a - 1),  si y > 1,
##
##    alors retourner x = y. Sinon retourner à l'étape 1.

### PRÉSENTATION DU CODE

## La première version du code ne respecte pas les règles de
## base d'indentation et d'«aération» du code. Résultat: un
## fouillis difficile à consulter.
##-!- rgamma_ar<-function(n,shape,rate=1,scale=1/rate)
##-!- { if(shape<=0|shape>=1)
##-!- stop("valeur de shape inadmissible")
##-!-   ratio<-function(x)
##-!-      if(x<=1) exp(-x)else x^(shape-1)
##-!- Ginv<-function(x) {
##-!-   k<-1+shape*exp(-1)
##-!-   if(x<=1/k) (k*x)^(1/shape)
##-!-   else -log(((1/shape)+exp(-1))*(1-x))   }
##-!-
##-!-   i<-0
##-!-   while(i<n) {
##-!-     y<-Ginv(runif(1))
##-!-     if(runif(1)<=ratio(y))
##-!-     {x<-c(x,y)
##-!-         i<-i+1
##-!-  }
##-!- x*scale
##-!- }

## Réviser seulement l'indentation permet déjà d'y voir plus
## clair. Tous les bons éditeurs de texte pour programmeurs
## sont capables d'indenter le code pour vous, que ce soit à
## la volée ou de manière asynchrone.
##
## Vous pouvez arriver au résultat ci-dessous avec RStudio en
## sélectionnant le code ci-dessus et en exécutant l'option du
## menu Code|Reindent Lines.
##
## Dans Emacs, l'indentation se fait automatiquement au fur et
## à mesure que l'on entre du code ou, autrement, en appuyant
## sur la touche de tabulation.
##-!- rgamma_ar<-function(n,shape,rate=1,scale=1/rate)
##-!- {
##-!-     if(shape<=0|shape>=1)
##-!-         stop("valeur de shape inadmissible")
##-!-     ratio<-function(x)
##-!-         if(x<=1) exp(-x)else x^(shape-1)
##-!-     Ginv<-function(x)
##-!-     {
##-!-         k<-1+shape*exp(-1)
##-!-         if(x<=1/k)
##-!-             (k*x)^(1/shape)
##-!-         else
##-!-             -log(((1/shape)+exp(-1))*(1-x))
##-!-     }
##-!-
##-!-     i<-0
##-!-     while(i<n)
##-!-     {
##-!-         y<-Ginv(runif(1))
##-!-         if(runif(1)<=ratio(y))
##-!-         {
##-!-             x<-c(x,y)
##-!-             i<-i+1
##-!-         }
##-!-         x*scale
##-!-     }

## La simple indentation du code nous permet déjà de découvrir
## un bogue dans le code: il manque une accolade fermante } à
## la fin de la fonction.
##
## En examinant le code de plus près, nous réalisons que
## l'expression 'x * scale', qui sert à retourner le résultat
## de la fonction, devrait se trouver à l'extérieur de la
## boucle 'while'. En fait, l'accolade fermante manquante est
## celle qui termine la clause 'if' à l'intérieur de la boucle.
##
## Corrigeons déjà le code.
rgamma_ar<-function(n,shape,rate=1,scale=1/rate)
{
    if(shape<=0|shape>=1)
        stop("valeur de shape inadmissible")
    ratio<-function(x)
        if(x<=1) exp(-x)else x^(shape-1)
    Ginv<-function(x)
    {
        k<-1+shape*exp(-1)
        if(x<=1/k)
            (k*x)^(1/shape)
        else
            -log(((1/shape)+exp(-1))*(1-x))
    }

    i<-0
    while(i<n)
    {
        y<-Ginv(runif(1))
        if(runif(1)<=ratio(y))
        {
            x<-c(x,y)
            i<-i+1
        }
    }
    x*scale
}

## Les normes usuelles de présentation du code informatique
## exigent également d'aérer le code avec des espaces autour
## des opérateurs et des structures de contrôle, après les
## virgules, etc. Comme pour du texte normal, les espaces
## rendent le code plus facile à lire.
##
## Dans RStudio, vous pouvez parvenir à la présentation
## ci-dessous avec la commande du menu Code|Reformat Code.
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    i <- 0
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
        {
            x <- c(x, y)
            i <- i + 1
        }
    }
    x * scale
}

### STYLE

## Il y a quelque chose à redire sur le style de cette
## fonction? Pourtant, les noms d'objets sont raisonnables, le
## coeur de la fonction n'est pas inutilement placé dans une
## clause 'else' après le test de validité de l'argument
## 'shape', deux calculs plus lourds sont relégués à des
## fonctions internes...
##
## Si vous y regardez de très près, vous constaterez que la
## fonction ci-dessus souffre du Syndrome de la plaque à
## biscuits(TM).
##
## En effet, les valeurs acceptées dans la simulation sont
## placées à la suite du vecteur 'x' dans l'expression 'x <-
## c(x, y)', le faisant constamment croître.
##
## Pour régler ce problème, il faut définir un contenant et y
## placer les valeurs simulées au fur et à mesure qu'elles
## sont acceptées.
##
## Nous en profitons pour combiner les opérations, assez
## communes, d'affectation et d'incrémentation du compteur.
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    x <- numeric(n)
    i <- 0
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }
    x * scale
}

### COMMENTAIRES

## Dernier élément manquant dans notre code: les commentaires.
##
## Vous trouverez ci-dessous un modèle de documentation du
## code inspiré de la struture des rubriques d'aide de R.

###
### rgamma_ar(n, shape, rate = 1, scale = 1/rate)
###
##  Simule des observations de la distribution gamma avec
##  paramètre de forme entre 0 et 1 par la méthode
##  d'acceptation-rejet.
##
##  Arguments
##
##  n: nombre d'observations à simuler;
##  shape: paramètre de forme de la distribution;
##    0 < shape < 1;
##  rate: autre façon de spécifier l'échelle de la
##    distribution;
##  scale: paramètre d'échelle de la distribution (strictement
##    positif).
##
##  Valeur
##
##  Vecteur d'observations d'une distribution gamma.
##
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    ## Vérification de la validité de 'shape'
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ## Fonction pour calculer la valeur du ratio f(x)/(c g(x))
    ## utilisé dans le test d'acceptation-rejet.
    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    ## Fonction pour générer une valeur y à partir d'un nombre
    ## uniforme u.
    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    ## La méthode d'acceptation-rejet commande d'utiliser une
    ## boucle 'while' puisque nous ne savons pas d'avance
    ## combien de valeurs simulées seront acceptées.
    x <- numeric(n)  # contenant pour les valeurs simulées
    i <- 0           # compteur du nombre de valeurs acceptées
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }

    ## Les valeurs dans 'x' proviennent d'une distribution
    ## Gamma(shape, 1). Il faut les retourner sur la bonne
    ## échelle.
    x * scale
}                                       #-*- `\labelline{fonctions:pratiques:fin}`
@

\gotorbox{Le fichier de script \code{\scriptfilename} reproduit à la
  \autoref{sec:fonctions:exemples} contient, aux lignes
  \reflines{fonctions:pratiques}, un long exemple d'amélioration du
  style et de la présentation du code d'une fonction, ainsi qu'un
  exemple de documentation d'une fonction. Vous y trouverez même un
  cas de Syndrome de la plaque à biscuits{\texttrademark}.}


\section{Exemples}
\label{sec:fonctions:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:fonctions:exercices}

\Opensolutionfile{solutions}[solutions-fonctions]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:fonctions}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:fonctions}}

\end{Filesave}

\begin{exercice}
  Pour chacun des exercices b)--g) de
  l'\autoref{ex:premiers:moyennes}, composer une fonction R pour
  effectuer le calcul demandé. Nommer les fonctions %
  \code{amean}, %
  \code{gmean}, %
  \code{hmean}, %
  \code{pscal}, %
  \code{norm1} et %
  \code{normINF}, %
  dans l'ordre.
  \begin{sol}
    \begin{enumerate}
      \stepcounter{enumi}
    \item
<<echo=TRUE, eval=FALSE>>=
amean <- function(x) sum(x)/length(x)
@
    \item
<<echo=TRUE, eval=FALSE>>=
gmean <- function(x) prod(x)^(1/length(x))
@
    \item
<<echo=TRUE, eval=FALSE>>=
hmean <- function(x) 1/prod(1/x)
@
    \item
<<echo=TRUE, eval=FALSE>>=
pscal <- function(x, y) sum(x * y)
@
    \item
<<echo=TRUE, eval=FALSE>>=
norm1 <- function(x, y) sum(abs(x - y))
@
    \item
<<echo=TRUE, eval=FALSE>>=
normINF <- function(x, y) max(abs(x - y))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{ex:fonctions:prodmat}
  Le produit matriciel entre deux matrices
  $\mat{A} = [a_{ij}]_{m \times p}$ et
  $\mat{B} = [b_{ij}]_{p \times n}$ est une matrice $m \times n$ dont
  l'élément en position $(i, j)$ est
  \begin{equation*}
    \sum_{k = 1}^p a_{ik} b_{kj}.
  \end{equation*}

  Sans utiliser l'opérateur \code{\%*\%}, écrire une fonction
  \code{prod\_mat} qui effectuera le produit matriciel entre deux
  matrices seulement si les dimensions de celles-ci le permettent.
  Cette fonction aura deux arguments (\code{A} et \code{B}) et devra
  tout d'abord vérifier si le produit matriciel est possible. Si
  celui-ci est impossible, la fonction retourne un message d'erreur.
  Utiliser une structure de contrôle \code{if ... else ...} et deux
  boucles. Comparer le résultat avec celui de l'opérateur
  \code{\%*\%}.
  \begin{sol}
\begin{Schunk}
\begin{Verbatim}
prod_mat <- function(A, B)
{
    if (ncol(A) != nrow(B))
        stop("dimensions incompatibles")

    res <- matrix(0, nrow = nrow(A),
                  ncol = ncol(B))
    for (i in seq_len(nrow(A)))
    {
        for (j in seq_len(ncol(B)))
        {
            res[i, j] <- sum(A[i, ] * B[, j])
        }
    }
    res
}
\end{Verbatim}
\end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}[nosol]
  \label{ex:fonctions:rstudio-tab-width}
  Configurer votre éditeur de texte pour indenter le code R de quatre
  (4) caractères. Dans RStudio, ouvrir le panneau des options
  globales, sélectionner la catégorie \code{Code} et inscrire la
  valeur \code{4} dans le champs \code{Tab width} (voir la
  \autoref{fig:fonctions:rstudio-tab-width}).
  \begin{figure}
    \centering
    \includegraphics{images/rstudio-tab-width}
    \caption{Réglage de RStudio pour une indentation du code
      de quatre caractères}
    \label{fig:fonctions:rstudio-tab-width}
  \end{figure}
\end{exercice}

\begin{exercice}
  Présenter le code ci-dessous selon les normes d'espacement,
  d'indentation et de positionnement des accolades mentionnées à la
  \autoref{sec:fonctions:pratiques}. Pour ajuster
  automatiquement l'indentation avec RStudio, sélectionner le bloc de
  code et choisir dans les menus \code{Code|Reformat Code}.

\begin{Schunk}
\begin{Verbatim}
f <- function(x){
  if(all(x>=0)|| all(x<=0))
  { stop("all x are the same sign")
  }
  if (sum(diff(sign(x[x!=0]))!=0)>1)
  warning("more than one sign change")
 r<-polyroot(x)
i<-1/Re(r)[abs(Im(r))< .Machine$double.eps^0.5]-1
i[i > -1]
}
\end{Verbatim}
\end{Schunk}
\begin{sol}
  La présentation correcte comporte des espaces autour de tous les
  opérateurs, une indentation de quatre (4) caractères et des
  accolades ouvrante et fermante placées sur leur propre ligne.
\begin{Schunk}
\begin{Verbatim}[fontsize=\relsize{-1}]
tri <- function(x)
{
    if (all(x >= 0) || all(x <= 0))
    {
        stop("all x are the same sign")
    }
    if (sum(diff(sign(x[x != 0])) != 0) > 1)
        warning("more than one sign change")
    r <- polyroot(x)
    i <- 1/Re(r)[abs(Im(r)) < .Machine$double.eps^0.5] - 1
    i[i > -1]
}
\end{Verbatim}
\end{Schunk}
\end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
