%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de données de R et fonctions d'application}
\label{chap:donnees}

\def\scriptfilename{\currfilebase.R}
\SweaveOpts{echo=FALSE}

<<echo=FALSE, results=hide>>=
source(".Sweaveprofile")   # configuration
source("Stangle.R")        # lancement de Stangle
@
<<script>>=
## Copyright (C) 2019 Vincent Goulet
##
## Ce fichier fait partie du projet
## «Programmer avec R»
## https://gitlab.com/vigou3/programmer-avec-r
##
## Cette création est mise à disposition sous licence
## Attribution-Partage dans les mêmes conditions 4.0
## International de Creative Commons.
## https://creativecommons.org/licenses/by-sa/4.0/
@

\begin{objectifs}
\item Créer et manipuler les structures de données suivantes de R:
  vecteur, matrice, tableau, liste, tableau de données, facteur et
  date.
\item Extraire des données des divers types d'objet ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Utiliser les fonctions d'application pour effectuer des
  sommaires ou réduire des structures de données de R.
\end{objectifs}

Ce chapitre regroupe deux sujets bien distincts d'un point de vue
conceptuel, mais intimement reliés d'un point de vue fonctionnel: les
structures de données de R et les fonctions d'application
correspondantes.

Une structure de données est une manière d'organiser les données dans
un ordinateur afin de pouvoir les traiter efficacement. L'étude des
structures de données va généralement de pair avec celle des
algorithmes puisqu'elles en influencent directement la performance. Le
bon choix de structure de données peut faire la différence entre un
programme performant et un autre trop lent ou inapte à traiter des
grandes quantités de données.

Le modèle de données de R repose sur des structures abstraites et
spécialisées appelées \emph{objets}. Jusqu'ici, nous n'avons étudié
que le vecteur simple (\emph{atomic}). Il existe d'autres structures
de données en R, mais leur mise en œuvre demeure tout à fait
transparente pour les programmeuses et les programmeurs. Nous ferons
donc l'impasse sur les notions de tableau (\emph{array}), de liste
chainée (\emph{linked list}), d'arbre (\emph{tree}) ou de table de
hachage (\emph{hashtable}) dont traitent habituellement les ouvrages
d'algorithmique et de programmation.

Le vecteur, la matrice, le tableau et la liste sont les types d'objets
les plus fréquemment utilisés en programmation en R. Le facteur, le
tableau de données (\emph{data frame}) et la date sont davantage des
structures de données spécialisées pour l'analyse de données.

Vous savez déjà que certains types de calculs répétitifs sont
automatiquement pris en charge par R via la couche d'abstraction de
l'\index{arithmetique@arithmétique vectorielle}arithmétique
vectorielle (\autoref{sec:bases:vecteurs:arithmetique}). Pour les cas
où l'arithmétique vectorielle ne s'applique pas, un large pan des
calculs répétitifs peut être réduit à quelques fonctions abstraites
dites d'\emph{application} (\emph{mapping}, un autre concept hérité du
\index{Lisp}Lisp). Les fonctions d'\index{application}application
permettent de masquer, par une nouvelle couche d'abstraction, les
calculs répétitifs sur les dimensions des matrices et des tableaux,
ainsi que ceux sur les éléments d'un vecteur ou d'une liste. De plus,
elles se prêtent tout naturellement à la programmation vectorielle.


\section{Objets R}
\label{sec:donnees:objets}

Cette section passe en revue certains détails sur les objets R que
nous avons jusqu'à maintenant laissé dans l'ombre par souci de
simplicité.

Tout dans le langage R est un objet: les variables contenant des
données, les fonctions, les opérateurs, même le symbole représentant
le nom d'un objet est lui-même un objet. Les objets possèdent au
minimum un \emph{mode} et une \emph{longueur} et certains peuvent
être dotés d'un ou de plusieurs \emph{attributs}.

\subsection{Règles pour les noms d'objets}
\label{sec:donnees:objets:noms}

Les caractères permis pour les noms d'objets sont les lettres
minuscules a--z et majuscules A--Z, les chiffres 0--9, le point «.» et
le caractère de soulignement «\_». Selon l'environnement linguistique
de l'ordinateur, il peut être permis d'utiliser des lettres accentuées
dans les noms d'objet, mais je recommande fortement d'éviter cette
pratique qui nuit à la portabilité du code. Le nom d'un objet ne peut
débuter par un chiffre. Si le nom débute par un point, alors le second
caractère ne peut être un chiffre.

\warningbox{R est sensible à la casse, ce qui signifie que \code{foo},
  \code{Foo} et \code{FOO} sont trois objets distincts.}

Certains noms sont utilisés par le système R, aussi vaut-il mieux
éviter de les utiliser comme nom de variable ou de fonction. En
particulier, évitez:
\begin{quote}
  \code{c}, \code{q}, \code{t}, \code{C}, \code{D},
  \code{I}, \code{diff}, \code{length}, \code{mean},
  \code{pi}, \code{range}, \code{var}.
\end{quote}
De plus, certains mots sont réservés et il est interdit de les
utiliser comme nom d'objet. Les mots réservés pour le système sont:
\begin{quote}
  \code{break}, \code{else}, \code{for}, \code{function}, \code{if},
  \code{in}, \code{next}, \code{repeat}, \code{while}, \\
  \code{TRUE}, \code{FALSE}, \\
  \code{Inf}, \code{NaN}, \code{NULL}, \\
  \code{NA}, \verb|NA_integer_|, \verb|NA_real_|, \verb|NA_complex_|,
  \verb|NA_character_|, \\
  \code{...}, \code{..1}, \code{..2}, etc.
\end{quote}
Oui, l'argument spécial `\icode{...}' rencontré à la
\autoref{sec:bases:fonctions:definition} est un objet dans R!

Les variables \code{T}\index{T@\code{T}|see{\code{TRUE}}} et
\code{F}\index{F@\code{F}|see{\code{FALSE}}} prennent par défaut les
valeurs \icode{TRUE} et \icode{FALSE}, respectivement, mais peuvent
être réaffectées.
<<echo=TRUE>>=
T
F
@
\begin{Schunk}
\begin{Sinput}
> TRUE <- 3
\end{Sinput}
\begin{Soutput}
Error in TRUE <- 3 : membre gauche de l'assignation
(do_set) incorrect
\end{Soutput}
\end{Schunk}
<<echo=TRUE>>=
(T <- 3)
@
<<echo=FALSE>>=
rm(T)
@

\tipbox{Écrivez toujours les valeurs booléennes \code{TRUE} et
  \code{FALSE} au long pour éviter des bogues difficiles à détecter.}

\subsection{Modes et types de données}
\label{sec:donnees:objets:mode}

Le mode\Index{mode} prescrit ce qu'un objet peut contenir. À ce titre,
un objet ne peut avoir qu'un seul mode. Le \autoref{tab:donnees:modes}
contient la liste des principaux modes disponibles en R. À chacun de
ces modes correspond une fonction du même nom servant à créer un objet
de ce mode. Le mode d'un objet est obtenu avec la fonction
\Icode{mode}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
mode(v)
@

\begin{table}
  \centering
  \caption{Modes disponibles et contenus correspondants}
  \label{tab:donnees:modes}
  \begin{tabular}{ll}
    \toprule
    Mode              & Contenu de l'objet \\
    \midrule
    \icode{numeric}    & nombres réels \\
    \icode{complex}    & nombres complexes \\
    \icode{logical}    & valeurs booléennes \\
    \icode{character}  & chaines de caractères \\
    \icode{function}   & fonction \\
    \icode{list}       & liste \\
    \icode{expression} & expressions non évaluées \\
    \bottomrule
  \end{tabular}
\end{table}

Les objets de mode \code{numeric}, \code{complex},
\code{logical} et \code{character} sont des objets \emph{simples}
(\emph{atomic}) qui contiennent des données d'un seul type. En
revanche, les objets de mode \code{list} ou \code{expression} sont
des objets \emph{récursifs} qui peuvent contenir d'autres objets. Par
exemple, une liste peut contenir une ou plusieurs autres listes; nous
y reviendrons plus loin.

\tipbox{La fonction \Icode{typeof} permet d'obtenir une description
  plus précise de la représentation interne d'un objet (c'est-à-dire
  au niveau de la mise en {\oe}uvre en C). Le mode et le type d'un
  objet sont souvent identiques.}

\subsection{Longueur}
\label{sec:donnees:objets:longueur}

La longueur\Index{longueur} d'un objet est égale au nombre d'éléments
qu'il contient. La longueur d'un objet est obtenue avec la fonction
\Icode{length}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
length(v)
@

Au sens R du terme, la longueur d'une chaine de caractères est
toujours $1$. Un objet de mode \code{character} doit contenir
plusieurs chaines de caractères pour que sa longueur soit supérieure à
$1$. Il faut utiliser la fonction \Icode{nchar} pour obtenir le
nombre de caractères dans une chaine.
<<echo=TRUE>>=
v1 <- "actuariat"
length(v1)
nchar(v1)
@
<<echo=TRUE>>=
v2 <- c("a", "c", "t", "u", "a", "r", "i", "a", "t")
length(v2)
nchar(v2)
@

\tipbox{Il est permis --- et parfois utile --- de créer un objet de
  longueur nulle, c'est-à-dire un objet qui existe, mais qui est
  vide.}

\subsection{Valeurs spéciales}
\label{sec:donnees:objets:NA_et_al}

Les objets valeur manquante (\code{NA}), infini (\code{Inf},
\code{-Inf}), valeur indéterminée (\code{NaN}) et néant (\code{NULL})
permettent de représenter de manière intuitive des quantités souvent
utilisées dans les applications statistiques et en analyse de données.
Vous devriez connaitre les caractéristiques spéciales de ces objets
afin d'en tirer pleinement profit.

L'objet \code{NA} sert à représenter une donnée manquante. Chose
quelque peu surprenante, c'est un objet de mode \icode{logical}. Chose
encore plus surprenante, \code{NA} n'est cependant ni \code{TRUE}, ni
\code{FALSE}.
<<echo=TRUE>>=
mode(NA)
length(NA)
isTRUE(NA)
isFALSE(NA)
@
Toute opération, y compris la comparaison, impliquant la valeur
\code{NA} a comme résultat \code{NA}. Par conséquent, la valeur
\code{NA} n'est égale à aucune autre, \emph{pas même elle-même}! Pour
tester si une valeur est manquante, vous devez avoir recours à la
fonction \Icode{is.na}.
<<echo=TRUE>>=
x <- NA
x == NA
is.na(NA)
@

Les objets \code{Inf}, \code{-Inf} et \code{NaN} permettent de
représenter les valeurs mathématiques spéciales prévues dans la norme
IEEE~754 régissant la représentation interne des nombres dans un
ordinateur \citep{IEEE:754}. De manière intuitive, l'objet \icode{Inf}
représente $+\infty$, \code{-Inf} représente $-\infty$ et \icode{NaN}
(\emph{Not a Number}) représente une forme indéterminée du type
$\frac{0}{0}$ ou $\infty - \infty$. Utilisez les fonctions
\Icode{is.infinite}, \Icode{is.finite} et \Icode{is.nan} pour tester
de manière robuste ces valeurs.
<<echo=TRUE>>=
is.infinite(1/0)
is.finite(-1/0)
is.nan(0/0)
is.nan(Inf - Inf)
@

Enfin, l'objet spécial \icode{NULL} représente «rien», ou le vide. Son
mode est \code{NULL} et sa longueur est $0$. Il est toutefois
différent d'un objet vide: un objet de longueur $0$ est un contenant
vide, alors que \code{NULL} est «pas de contenant».
<<echo=TRUE>>=
mode(NULL)
length(NULL)
1 + NULL
@
Ajouter \code{NULL} à un objet n'ajoute rien. Par ailleurs, la seule
façon de tester si un objet est \code{NULL} est avec la fonction
\Icode{is.null}.
<<echo=TRUE>>=
c(3, NULL)
x <- NULL
x == NULL
is.null(NULL)
@


\subsection{Attributs}
\label{sec:donnees:objets:attributs}

Les attributs\Index{attribut} d'un objet sont des éléments
d'information additionnels attachés à cet objet. Le
\autoref{tab:attributs} fournit la liste des attributs les plus
fréquemment utilisés. À chacun des attributs du tableau correspond une
fonction du même nom servant à extraire l'attribut d'un objet.

\begin{table}
  \centering
  \caption{Attributs les plus usuels d'un objet}
  \label{tab:attributs}
  \begin{tabular}{ll}
    \toprule
    Attribut            & Utilisation \\
    \midrule
    \icode{class}    &
    affecte le comportement d'un objet \\
    \icode{dim}      &
    dimensions\index{dimension} des matrices et tableaux \\
    \icode{dimnames} &
    étiquettes\index{etiquette@étiquette} des dimensions des matrices
    et tableaux \\
    \icode{names}    &
    étiquettes des éléments d'un objet \\
    \bottomrule
  \end{tabular}
\end{table}

La fonction \Icode{attributes} permet d'extraire ou de modifier la
liste des attributs d'un objet, alors que la fonction \Icode{attr}
permet de travailler sur un seul attribut à la fois. Les programmeurs
peuvent ajouter à peu près n'importe quoi à la liste des attributs
d'un objet. Par exemple, nous pourrions vouloir attacher au résultat
d'un calcul la méthode de calcul utilisée.
<<echo=TRUE>>=
x <- 3
attr(x, "methode") <- "au pif"
attributes(x)
@

L'extraction d'un attribut qui n'existe pas retourne \icode{NULL},
alors qu'à l'inverse, affecter à un attribut la valeur \code{NULL}
efface cet attribut.
<<echo=TRUE>>=
attributes(x)
dim(x)
attr(x, "methode") <- NULL
attributes(x)
@

\gotorbox{Étudiez les lignes \reflines{donnees:objets}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### OBJETS R               `\labelline{donnees:objets}`
###

## NOMS D'OBJETS

## Quelques exemples de noms valides et invalides.
foo <- 5                   # valide
foo.123 <- 5               # valide
foo_123 <- 5               # valide
.foo <- 5                  # valide
##-!- 123foo <- 5                # invalide; commence par un chiffre
##-!- .123foo <- 5               # invalide; point suivi d'un chiffre

## Liste des objets dans l'espace de travail. Les objets dont
## le nom commence par un point sont cachés, comme à la ligne
## de commande Unix.
ls()                       # l'objet '.foo' n'est pas affiché
ls(all.names = TRUE)       # objets cachés aussi affichés

## R est sensible à la casse
foo <- 1
##-!- Foo
##-!- FOO

## MODES ET TYPES DE DONNÉES

## Le mode d'un objet détermine ce qu'il peut contenir. Les
## vecteurs simples ("atomic") contiennent des données d'un
## seul type.
mode(c(1, 4.1, pi))        # nombres réels
mode(c(2, 1 + 5i))         # nombres complexes
mode(c(TRUE, FALSE, TRUE)) # valeurs booléennes
mode("foobar")             # chaînes de caractères

## Par défaut, tous les nombres sont représentés en double
## précision dans R. Il n'y a donc pas de différence entre
## un nombre entier et un nombre réel.
typeof(486)                # nombre réel en double précision
typeof(0.3324)             # idem

## Il est possible de définir des «vrais» entiers dans R en
## faisant suivre la valeur immédiatement de la lettre «L»,
## sans espace. Le mode de ces valeurs est toujours "numeric",
## mais leur type (ou représentation interne) est "integer".
mode(486L)                 # nombre...
typeof(486L)               # ... entier

## La plupart des autres types d'objets sont récursifs. Voici
## quelques autres modes.
mode(seq)                  # une fonction
mode(list(5, "foo", TRUE)) # une liste
mode(expression(x <- 5))   # une expression non évaluée

## LONGUEUR

## La longueur d'un vecteur est égale au nombre d'éléments
## dans le vecteur.
(x <- 1:4)
length(x)

## Une chaîne de caractères ne compte que pour un seul
## élément.
(x <- "foobar")
length(x)

## Pour obtenir la longueur de la chaîne, il faut utiliser
## nchar().
nchar(x)

## Un objet peut néanmoins contenir plusieurs chaînes de
## caractères.
(x <- c("f", "o", "o", "b", "a", "r"))
length(x)

## La longueur peut être 0, auquel cas on a un objet vide,
## mais qui existe.
(x <- numeric(0))          # création du contenant
length(x)                  # l'objet 'x' existe...
x[1] <- 1                  # définition du permier élément

## Si un objet n'existe pas au préalable, il est impossible
## d'affecter directement la valeur d'un élément.
##-!- X[1] <- 1                  # impossible, 'X' n'existe pas

## VALEURS SPÉCIALES

## Donnée manquante. 'NA' est un nom réservé pour représenter
## une donnée manquante.
c(65, NA, 72, 88)          # traité comme une valeur
NA + 2                     # tout calcul avec 'NA' donne NA
is.na(c(65, NA))           # test si les données sont NA

## Il arrive souvent de vouloir indicer spécifiquement les
## données manquantes d'un vecteur (pour les éliminer ou pour
## les remplacer par une autre valeur, par exemple).
##
## Pour ce faire, on utilise la fonction 'is.na' et l'indiçage
## par un vecteur booléen.
x <- c(NA, 12, 55, NA, 4)  # vecteur contenant des NA
is.na(x)                   # positions des données manquantes
x[!is.na(x)]               # suppression des données manquantes
x[is.na(x)] <- 0; x        # remplacement des NA par des 0

## Valeurs infinies et indéterminée. 'Inf', '-Inf' et 'NaN'
## sont des noms réservés.
1/0                        # +infini
-1/0                       # -infini
0/0                        # indétermination
x <- c(65, Inf, NaN, 88)   # s'utilisent comme des valeurs
is.finite(x)               # quels sont les nombres réels?
is.nan(x)                  # lesquels sont indéterminés?

## Valeur "néant". 'NULL' est un nom réservé pour représenter
## le néant, rien.
mode(NULL)                 # le mode de 'NULL' est NULL
length(NULL)               # longueur nulle
c(NULL, NULL)              # du néant ne résulte que le néant

## ATTRIBUTS

## Les objets peuvent être dotés d'un ou plusieurs attributs.
data(cars)                 # jeu de données intégré
attributes(cars)           # liste de tous les attributs
attr(cars, "class")        # extraction d'un seul attribut

## L'attribut 'names' conserve les étiquettes des éléments
## d'un vecteur.
x <- 1:24                  # un vecteur
names(x) <- letters[1:24]  # attribution d'étiquettes
x                          # identification facilitée `\labelline{donnees:objets:fin}`
@


\section{Matrice et tableau}
\label{sec:donnees:matrice}

R étant un langage spécialisé dans les calculs mathématiques, il
supporte tout naturellement et de manière intuitive --- à une
exception près, comme nous le verrons --- les matrices et les
tableaux. Dans la terminologie de R, une matrice est un tableau
rectangulaire de nombres à deux dimensions, alors qu'un tableau
(\emph{array}) est la généralisation à plus de deux
dimensions.\footnote{%
  Il est donc correct de dire qu'une matrice est un tableau à deux
  dimensions.} %

Nous avons établi d'entrée de jeu à la \autoref{sec:bases:vecteurs}
qu'en R, tout est un vecteur. C'est aussi vrai pour les matrices et
tableaux, qui ne sont rien d'autre que des vecteurs dotés d'un
attribut \icode{dim}. Ces objets sont donc stockés, et peuvent être
manipulés, exactement comme des vecteurs simples.

Une \Index{matrice}matrice est un vecteur avec un attribut \icode{dim}
de longueur $2$. La présence de cet attribut change implicitement la
classe de l'objet et, de ce fait, son mode d'affichage (sous forme de
tableau rectangulaire) et son interaction avec plusieurs opérateurs et
fonctions, notamment les opérateurs d'indiçage. La fonction de base
pour créer une matrice est \Icode{matrix}.
<<echo=TRUE>>=
matrix(1:6, nrow = 2, ncol = 3)
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
@

Tel que mentionné précédemment, la généralisation d'une matrice à plus
de deux dimensions est un \Index{tableau}tableau. Le nombre de
dimensions du tableau est toujours égal à la longueur de l'attribut
\icode{dim}. La fonction de base pour créer des tableaux est
\Icode{array}.
<<echo=TRUE>>=
array(1:24, dim = c(3, 4, 2))
@

Formellement, un tableau peut aussi compter une seule dimension. Un
tel tableau comporte un attribut \code{dim} de longueur $1$, alors
qu'un vecteur simple n'a pas d'attribut \code{dim}.

\importantbox{%
  Vous aurez remarqué que les matrices et tableaux sont remplis en
  faisant d'abord varier la première dimension, puis la seconde, etc.
  Pour les matrices, cela revient à les remplir par colonne. Cette
  convention, héritée du Fortran, n'est pas des plus intuitives, mais
  elle a ses avantages dans plusieurs applications.

  La fonction \icode{matrix} possède un argument \code{byrow} qui
  permet d'inverser l'ordre de remplissage, mais il vaut mieux
  vous habituer à la convention de R que d'essayer constamment de la
  contourner.}

L'ordre de remplissage inhabituel des tableaux vous causera des maux
de tête si vous ne les visualisez pas correctement. Prenez le cas d'un
tableau de dimensions $3 \times 4 \times 5$: il vous faut voir le
tableau comme cinq matrices $3 \times 4$ (remplies par colonne!) les
unes \emph{derrière} les autres. Autrement dit, le tableau est un
prisme rectangulaire haut de $3$ unités, large de $4$ et profond de
$5$. Si l'on ajoute une quatrième dimension, cela revient à aligner
des prismes les uns derrière les autres, et ainsi de suite. La
\autoref{fig:donnees:tableaux} fournit une représentation schématique
des tableaux à trois et à quatre dimensions.

\begin{figure}[t]
  \centering
  \hspace*{\fill}
  \begin{minipage}[b]{0.4\linewidth}
    \setlength{\unitlength}{5mm}
    \begin{picture}(9,7)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.7}}\put(0.51,3.51){\makebox(0,0){\footnotesize 1}}
      \put(0.5,3){\vector(0,-1){2.5}}
      \put(1.5,3.5){\circle{0.7}}\put(1.51,3.51){\makebox(0,0){\footnotesize 2}}
      \put(2,3.5){\vector(1,0){2.5}}
      \put(6.3,0.3){\circle{0.7}}\put(6.31,0.31){\makebox(0,0){\footnotesize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
    \end{picture}
    \subcaption{trois dimensions}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \setlength{\unitlength}{5mm}
    \setlength{\unitlength}{3.5mm}
    \begin{picture}(14,12)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(6,7){\line(0,1){2}}
      \put(6,9){\line(1,0){5}}
      \put(11,9){\line(0,-1){4}}
      \put(11,5){\line(-1,0){3}}
      \multiput(7,9)(1,1){3}{\line(0,1){1}}
      \multiput(7,10)(1,1){3}{\line(1,0){5}}
      \multiput(12,10)(1,1){3}{\line(0,-1){4}}
      \multiput(12,6)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.8}}\put(0.51,3.51){\makebox(0,0){\scriptsize 1}}
      \put(0.5,2.9){\vector(0,-1){2.4}}
      \put(1.5,3.5){\circle{0.8}}\put(1.51,3.51){\makebox(0,0){\scriptsize 2}}
      \put(2.1,3.5){\vector(1,0){2.4}}
      \put(6.3,0.3){\circle{0.8}}\put(6.31,0.31){\makebox(0,0){\scriptsize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
      \put(7.3,0.3){\circle{0.8}}\put(7.31,0.31){\makebox(0,0){\scriptsize 4}}
      \put(7.7,0.7){\vector(1,1){6.3}}
    \end{picture}
    \subcaption{quatre dimensions}
  \end{minipage}
  \caption[Représentation schématique de tableaux]{Représentation
    schématique de tableaux. Les chiffres encerclés identifient
    l'ordre de remplissage.}
  \label{fig:donnees:tableaux}
\end{figure}

L'indiçage\Index{indiçage!matrice} des matrices et des tableaux se fait
avec les crochets \code{[~]}\indexcode{[}, comme pour les vecteurs
simples. D'ailleurs, l'ensemble des règles d'indiçage de la
\autoref{sec:bases:vecteurs:indicage} s'appliquent à l'identique aux
matrices et tableaux, sinon qu'il faut maintenant préciser des
indices pour chaque dimension, séparés par des virgules.
Par exemple, on extrait un élément d'une matrice en précisant sa
position dans chaque dimension de celle-ci.
<<echo=TRUE>>=
(m <- matrix(c(40, 80, 45, 21, 55, 32), nrow = 2))
m[1, 2]
@

Il est équivalent --- quoique moins usité --- d'utiliser la position
de l'élément dans le vecteur sous-jacent à la matrice.
<<echo=TRUE>>=
m[3]
@

Les indices négatifs suppriment des dimensions et les vecteurs
booléens sélectionnent des dimensions, comme d'habitude.
<<echo=TRUE>>=
m[-1, -2]
m[c(FALSE, TRUE), c(FALSE, TRUE, TRUE)]
@

En vertu de la cinquième règle d'indiçage de la
\autoref{sec:bases:vecteurs:indicage}, lorsqu'une dimension est
laissée vide dans les crochets, tous les éléments de cette dimension
sont extraits. C'est ainsi que nous pouvons extraire une ligne ou une
colonne entière, par exemple.
<<echo=TRUE>>=
m[2, ]
m[, 1]
m[-1, ]
m[, -2]
@

Les fonctions \Icode{rbind} et \Icode{cbind} permettent de fusionner
des matrices et des tableaux ayant au moins une dimension en commun.
La fonction \Icode{rbind} (\emph{row bind}) fusionne verticalement
(empile) deux matrices (ou plus) ayant le même nombre de colonnes.
<<echo=TRUE>>=
n <- matrix(1:9, nrow = 3)
rbind(m, n)
@

La fonction \Icode{cbind} (\emph{column bind}), quant à elle, fusionne
horizontalement (place côte à côte) deux matrices (ou plus) ayant le
même nombre de lignes.
<<echo=TRUE>>=
n <- matrix(1:4, nrow = 2)
cbind(m, n)
@

\videobox{\link{https://youtu.be/6P2cFe3DBfw}{Matrices et tableaux}}{%
  Visionnez la vidéo sur les
  \link{https://youtu.be/6P2cFe3DBfw}{matrices et tableaux} en
  complément de la présentation ci-dessus. Grâce à des représentations
  visuelles, elle facilite la compréhension des opérations de création
  et d'indiçage des matrices et des tableaux.}

\gotorbox{Étudiez les lignes \reflines{donnees:matrice}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### MATRICE ET TABLEAU  `\labelline{donnees:matrice}`
###

## Une matrice est un vecteur avec un attribut 'dim' de
## longueur 2 et une classe implicite "matrix". La manière
## naturelle de créer une matrice est avec la fonction
## 'matrix'.
(x <- matrix(1:12, nrow = 3, ncol = 4))
length(x)                  # longueur du vecteur sous-jacent
attributes(x)              # objet muni d'un attribut 'dim'
dim(x)                     # deux dimensions

## Les matrices sont remplies par colonne par défaut. L'option
## 'byrow' permet de les remplir par ligne, si nécessaire.
(x <- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE))

## Il n'est pas nécessaire de préciser les deux dimensions de
## la matrice s'il est possible d'en déduire une à partir de
## l'autre et de la longueur du vecteur de données. Les
## expressions ci-dessous sont toutes équivalentes.
matrix(1:12, nrow = 3, ncol = 4)
matrix(1:12, nrow = 3)
matrix(1:12, ncol = 4)

## À l'inverse, s'il n'y a pas assez de données pour remplir
## les dimensions précisées, les données seront recyclées,
## comme d'habitude.
matrix(1, nrow = 3, ncol = 4)
matrix(1:3, nrow = 3, ncol = 4)
matrix(1:4, nrow = 3, ncol = 4, byrow = TRUE)

## Dans l'indiçage des matrices et tableaux, l'indice de
## chaque dimension obéit aux règles usuelles d'indiçage des
## vecteurs.
x[1, 2]                    # élément en position (1, 2)
x[1, -2]                   # 1ère rangée sans 2e colonne
x[c(1, 3), ]               # 1ère et 3e rangées
x[-1, ]                    # supprimer 1ère rangée
x[, -2]                    # supprimer 2e colonne
x[x[, 1] > 2, ]            # lignes avec 1er élément > 2

## Indicer la matrice ou le vecteur sous-jacent est
## équivalent. Utiliser l'approche la plus simple selon le
## contexte.
x[1, 3]                    # l'élément en position (1, 3)...
x[7]                       # ... est le 7e élément du vecteur

## Détail additionnel sur l'indiçage des matrices et tableaux:
## il est aussi possible de les indicer avec une matrice.
## Chaque ligne de la matrice d'indiçage fournit alors la
## position d'un élément à sélectionner.
##
## Consulter au besoin la rubrique d'aide de la fonction '['
## (ou de 'Extract').
x[rbind(c(1, 1), c(2, 2))] # éléments x[1, 1] et x[2, 2]
x[cbind(1:3, 1:3)]         # éléments x[i, i] («diagonale»)
diag(x)                    # idem et plus explicite

## Quelques fonctions pour travailler avec les dimensions des
## matrices.
nrow(x)                    # nombre de lignes
dim(x)[1]                  # idem
ncol(x)                    # nombre de colonnes
dim(x)[2]                  # idem

## Les matrices et les tableaux étant des vecteurs, ils sont
## soumis aux règles usuelles de l'arithmétique vectorielle.
## Certains des opérations qui en résultent ne sont pas
## définies en algèbre linéaire usuelle.
(x <- matrix(1:4, 2))      # matrice 2 x 2
(y <- matrix(3:6, 2))      # autre matrice 2 x 2
5 * x                      # multiplication par une constante
x + y                      # addition matricielle
x * y                      # produit *élément par élément*
x %*% y                    # produit matriciel
x / y                      # division *élément par élément*
x * c(2, 3)                # produit par colonne

## La fonction 'rbind' ("row bind") permet d'«empiler» des
## matrices comptant le même nombre de colonnes.
##
## De manière similaire, la fonction 'cbind' ("column bind")
## permet de concaténer des matrices comptant le même nombre de
## lignes.
##
## Utilisées avec un seul argument, 'rbind' et 'cbind' créent
## des vecteurs ligne et colonne, respectivement. Ceux-ci sont
## rarement nécessaires.
x <- matrix(1:12, 3, 4)    # 'x' est une matrice 3 x 4
y <- matrix(1:8, 2, 4)     # 'y' est une matrice 2 x 4
z <- matrix(1:6, 3, 2)     # 'z' est une matrice 3 x 2

rbind(x, 99)               # ajout d'une ligne à 'x'
rbind(x, y)                # fusion verticale de 'x' et 'y'
cbind(x, 99)               # ajout d'une colonne à 'x'
cbind(x, z)                # concaténation de 'x' et 'z'
##-!- rbind(x, z)                # dimensions incompatibles
##-!- cbind(x, y)                # dimensions incompatibles
rbind(1:3)                 # vecteur ligne
cbind(1:3)                 # vecteur colonne

## Un tableau (array) est un vecteur avec plus de deux
## dimensions. Pour le reste, la manipulation des tableaux
## est en tous points identique à celle des matrices. Ne pas
## oublier: les tableaux sont remplis de la première dimension
## à la dernière!
(x <- array(1:60, 3:5))    # tableau 3 x 4 x 5
length(x)                  # longueur du vecteur sous-jacent
dim(x)                     # trois dimensions
x[1, 3, 2]                 # l'élément en position (1, 3, 2)...
x[19]                      # ... est le 19e élément du vecteur

## Le tableau ci-dessus est un prisme rectangulaire 3 unités
## de haut, 4 de large et 5 de profond. Indicer ce prisme avec
## un seul indice équivaut à en extraire des «tranches», alors
## qu'utiliser deux indices équivaut à en tirer des «carottes»
## (au sens géologique du terme). Il est laissé en exercice de
## généraliser à plus de dimensions...
x                          # les cinq matrices
x[, , 1]                   # tranche transversale
x[, 1, ]                   # tranche verticale
x[1, , ]                   # tranche horizontale
x[, 1, 1]                  # carotte de haut en bas
x[1, 1, ]                  # carotte de devant à derrière
x[1, , 1]                  # carotte de gauche à droite
x[1, 1, 1]                 # donnée unique  `\labelline{donnees:matrice:fin}`
@


\section{Application pour les matrices et les tableaux}
\label{sec:donnees:apply}

Une matrice \code{x} contient le nombre de réclamations en assurance
dommages de trois entreprises pour les cinq dernières années.
<<echo=FALSE>>=
set.seed(1)
ncontracts <- 3
nyears <- 5
x <- matrix(rpois(ncontracts * nyears, rgamma(ncontracts, 1.5)),
            nrow = ncontracts)
@
<<echo=TRUE>>=
x
@

Une analyste souhaite connaitre le nombre total de réclamations par
entreprise, d'une part, et par année, d'autre part. Cela consiste à
calculer les sommes par ligne et par colonne de la matrice, dans
l'ordre. Or, aucun opérateur usuel de R ne permet d'effectuer
directement de tels calculs. Notre analyste prend donc le temps de
concevoir les algorithmes des procédures qu'elle devrait suivre pour
effectuer ses calculs. (Par fantaisie, elle en écrit un en langage
naturel et l'autre en pseudocode.)

\begin{algorithme}
  Calculer les sommes par ligne d'une matrice $\mat{A}$.
  \begin{enumerate}
  \item Poser $n$ égal au nombre de lignes de $\mat{A}$.
  \item Définir un vecteur $\mat{s}$ de longueur $n$.
  \item Poser l'élément $i$ de $\mat{s}$ égal à la somme des éléments
    de la ligne $i$ de $\mat{A}$, $i = 1, 2, \dots, n$.
  \item Retourner $\mat{s}$.
  \end{enumerate}
\end{algorithme}

\begin{algorithme}
  Calculer les sommes par colonne d'une matrice $\mat{A}$.
  \begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
colsum(matrice A)
  n \leftarrow nombre de colonnes de A
  Sommes \leftarrow vecteur de longueur n
  Pour i = 1, 2, ..., n
    y \leftarrow colonne i de la matrice A
    Sommes[i] \leftarrow somme des éléments y
  Fin Pour
  Retourner Sommes
Fin colsum
\end{Verbatim}
  \end{Schunk}
\end{algorithme}

Vous pouvez vérifier que les résultats de ces algorithmes sont %
$\Sexpr{paste("(", paste(rowSums(x), collapse = ", "), ")", sep = "")}$ %
et
$\Sexpr{paste("(", paste(colSums(x), collapse = ", "), ")", sep = "")}$, %
dans l'ordre.

L'analyste réalise ensuite rapidement qu'elle devrait utiliser ce
genre de procédures pour tout calcul de sommaire par ligne ou par
colonne d'une matrice. Par exemple, pour calculer le nombre moyen de
réclamations par entreprise et par année, le seul changement qu'elle
devrait apporter aux algorithmes ci-dessus consisterait à remplacer la
somme des éléments (d'une ligne ou d'une colonne) par la moyenne. Elle
se dit alors que tout ce qu'elle souhaite, c'est pouvoir facilement
\emph{appliquer} une fonction quelconque sur l'une ou l'autre des deux
dimensions d'une matrice. Si vous avez bien suivi l'analyste dans son
raisonnement, vous avez compris le concept d'application!

La fonction d'application pour les matrices et les tableaux est la
bien nommée \icode{apply}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

La syntaxe complète de \icode{apply} est la suivante:
\begin{Schunk}
\begin{Verbatim}
apply(X, MARGIN, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est une matrice ou un tableau.
\item \code{MARGIN} est un vecteur d'entiers contenant la ou les
  dimensions de la matrice ou du tableau sur lesquelles la fonction
  doit s'appliquer.
\item \code{FUN} est la fonction à appliquer sur la ou les dimensions.
  La fonction reçoit les sous-ensembles de \code{X} sans que ceux-ci
  ne soient nommés. Les règles habituelles d'évaluation d'un appel de
  fonction s'appliquent: les données constituent le premier argument
  de \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\item `\code{...}' contient des arguments supplémentaires à passer à
  \code{FUN}, séparés par des virgules.
\end{itemize}

Le quatrième argument de \code{apply} est l'argument formel spécial
`\icode{...}' dont nous avons traité à la
\autoref{sec:bases:fonctions:definition}. Il devient très utile, ici,
lorsque la fonction \code{FUN} prend plus d'un argument.

Pour illustrer, reprenons l'exemple précédent en supposant maintenant
que les entreprises n'ont pas toutes cinq années de données.
<<echo=FALSE>>=
x[1, c(4, 5)] <- NA
x[2, c(1, 2)] <- NA
x[3, 5] <- NA
@
<<echo=TRUE>>=
x
@

Si l'analyste a recours aux mêmes expressions que ci-dessus pour
calculer les sommaires par ligne et par colonne, elle obtiendra des
résultats sans grand intérêt puisque, comme on le sait, tout calcul
avec des données manquantes retourne la valeur \code{NA}.
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
@

Fort heureusement, la fonction \code{sum} possède un argument
\code{na.rm} qui indique de supprimer les données manquantes avant
d'effectuer la somme. L'analyste spécifie donc cet argument de la
fonction \code{sum} dans l'argument `\icode{...}' de \code{apply}.
<<echo=TRUE>>=
apply(x, 1, sum, na.rm = TRUE)
apply(x, 2, sum, na.rm = TRUE)
@

\tipbox{Les sommaires les plus usuels pour les matrices sont la somme
  et la moyenne, par ligne et par colonne. Les fonctions
  \icode{rowSums}, \icode{colSums}, \icode{rowMeans} et
  \icode{colMeans} permettent de calculer plus directement ces
  sommaires.}

Lorsque l'on applique une fonction à un tableau à plus de deux
dimensions, l'objet passé à la fonction peut s'avérer être une matrice
ou un tableau, selon le contenu de l'argument \code{MARGIN}. Par
exemple, si \code{X} est un tableau à trois dimensions et que la
longueur de \code{MARGIN} est $1$, on applique \code{FUN} sur les
«tranches» de \code{X} (des matrices). Si la longueur de \code{MARGIN}
est $2$, on applique plutôt \code{FUN} à des «carottes» tirées de
\code{X} (des vecteurs).

Illustrons ces propos à partir du tableau
$3 \times 4 \times 2$ suivant.
<<echo=FALSE>>=
x <- array(sample(0:10, 24, rep = TRUE), c(3, 4, 2))
@
<<echo=TRUE>>=
x
@

Les expressions ci-dessous calculent, dans l'ordre:
\begin{enumerate}
\item les sommes des trois tranches horizontales (de l'avant vers
  l'arrière) dans le tableau;
\item les sommes des quatre tranches verticales (du haut vers le bas);
\item les sommes des deux tranches transversales (de la gauche vers la
  droite);
\item les sommes des douze carottes horizontales;
\item les sommes des huit carottes verticales.
\item les sommes des six carottes transversales;
\end{enumerate}
<<echo=TRUE>>=
apply(x, 1, sum)
apply(x, 2, sum)
apply(x, 3, sum)
apply(x, c(1, 2), sum)
apply(x, c(2, 3), sum)
apply(x, c(1, 3), sum)
@

\videobox{\link{https://youtu.be/1sNAMWiPs4E}{Fonction \code{apply}}}{%
  La vidéo sur la \link{https://youtu.be/1sNAMWiPs4E}{fonction
    \icode{apply}} fournit une très utile représentation visuelle des
  opérations d'application sur les matrices et les tableaux.}

\tipbox{Truc mnémotechnique: la ou les dimensions figurant dans
  l'argument \code{MARGIN} sont celles retenues par le passage de
  \icode{apply}. En d'autres termes, les dimensions du résultat de
  \code{apply} sont \code{dim(X)[\code{MARGIN}]}.}

\gotorbox{Étudiez les lignes \reflines{donnees:apply}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### APPLICATION POUR LES MATRICES ET LES TABLEAUX  `\labelline{donnees:apply}`
###

## La fonction 'apply' applique une fonction sur une ou
## plusieurs dimensions d'une matrice ou d'un tableau.
##
## Création d'une matrice et d'un tableau à trois dimensions
## pour les exemples.
m <- matrix(sample(1:100, 20), nrow = 4, ncol = 5)
a <- array(sample(1:100, 60), dim = 3:5)

## Les fonctions 'rowSums', 'colSums', 'rowMeans' et
## 'colMeans' sont des raccourcis pour des utilisations
## fréquentes de 'apply'.
apply(m, 1, sum)           # sommes par ligne
rowSums(m)                 # idem, plus lisible
apply(m, 2, mean)          # moyennes par colonne
colMeans(m)                # idem, plus lisible

## Puisqu'il n'existe pas de fonctions comme 'rowMax' ou
## 'colProds', il faut utiliser 'apply'.
apply(m, 1, max)           # maximums par ligne
apply(m, 2, prod)          # produits par colonne

## L'argument '...' de 'apply' permet de passer des arguments
## à la fonction FUN.
f <- function(x, y) x + 2 * y # fonction à deux arguments
apply(m, 1, f, y = 2)         # argument 'y' passé dans '...'

## Lorsque 'apply' est utilisée sur un tableau, son résultat
## est de dimensions dim(X)[MARGIN], d'où le truc
## mnémotechnique donné dans le texte du chapitre.
apply(a, c(2, 3), sum)     # le résultat est une matrice
apply(a, 1, prod)          # le résultat est un vecteur

## L'utilisation de 'apply' avec les tableaux peut rapidement
## devenir confondante si l'on ne visualise pas les calculs
## qui sont réalisés.
##
## Reprenons ici les exemples du chapitre en montrant comment
## calculer le premier élément de chaque utilisation de
## 'apply'.
##
## Au besoin, réviser l'indiçage des tableaux au chapitre 3.
(x <- array(sample(0:10, 24, rep = TRUE), c(3, 4, 2)))
apply(x, 1, sum)      # sommes des 3 tranches horizontales
sum(x[1, , ])         # équivalent pour la première somme

apply(x, 2, sum)      # sommes des 4 tranches verticales
sum(x[, 1, ])         # équivalent pour la première somme

apply(x, 3, sum)      # sommes des 2 tranches transversales
sum(x[, , 1])         # équivalent pour la première somme

apply(x, c(1, 2), sum) # sommes des 12 carottes horizontales
sum(x[1, 1, ])         # équivalent pour la première somme

apply(x, c(2, 3), sum) # sommes des 6 carottes verticales
sum(x[, 1, 1])         # équivalent pour la première somme

apply(x, c(1, 3), sum) # sommes des 8 carottes transversales
sum(x[1, , 1])         # équivalent pour la première somme  `\labelline{donnees:apply:fin}`
@


\section{Liste}
\label{sec:donnees:liste}

La liste\Index{liste} est la structure de données la plus générale et
polyvalente du langage R. Si les éléments d'un vecteur simple doivent
tous être du même mode, ceux de la liste peuvent être de n'importe
quel mode, y compris le mode \icode{list}. Par conséquent, il est
possible d'emboîter des listes, d'où le qualificatif de
\emph{récursif} pour ce type d'objet.

La liste est la structure de données par excellence pour réunir dans
un objet plusieurs types d'objets différents. La fonction de base pour
créer des listes est \Icode{list}.
<<echo=TRUE>>=
(x <- list(size = c(1, 5, 2), user = "Joe", new = TRUE))
@ %

(Dans l'exemple ci-dessus, le premier élément de la liste est un
vecteur de mode \code{numeric}, le second un vecteur de mode
\code{character} et le troisième, un vecteur de mode \code{logical}.)

\tipbox{Nommez les éléments des listes puisqu'il peut s'avérer
  difficile autrement de les identifier. De plus, comme nous le
  verrons ci-dessous, il est très simple d'extraire les éléments d'une
  liste par leur étiquette.}

L'indiçage\Index{indiçage!liste} des listes recèle quelques subtilités
auxquelles il faut porter une attention particulière. Tout d'abord, il
existe trois opérateurs d'indiçage: les crochets simples usuels
\code{[~]}, les crochets doubles \code{[[~]]} et le signe de dollar
\code{\$} (ces deux derniers opérateurs figurent au
\autoref{tab:bases:operateurs}, mais nous n'en avions pas parlé
jusqu'ici).

\begin{itemize}
\item Les crochets simples\indexcode{[} fonctionnent avec la liste
  comme avec tout vecteur. Le résultat de l'indiçage avec \code{[~]}
  est une liste. Quand on y pense, c'est le seul résultat logique
  lorsque l'on indice une liste avec un vecteur. Par conséquent, le
  résultat de l'extraction d'un seul élément d'une liste avec les
  crochets simples est non pas l'objet en question, mais bien une
  liste d'un élément contenant l'objet. C'est rarement ce que l'on
  souhaite obtenir.
<<echo=TRUE>>=
x[1]
x[-2]
x[c(1, 3)]
@
%
\item Les crochets doubles\Indexcode{[[} permettent d'extraire un, et
  un seul, élément d'une liste à l'aide d'un entier positif ou d'une
  chaine de caractères. Le résultat est l'objet «sorti» de la liste.
<<echo=TRUE>>=
x[[1]]
x[["size"]]
@

  Petite fonctionnalité peu employée, mais élégante des crochets
  doubles: si l'indice est un vecteur d'entiers positifs, R utilisera
  les valeurs de celui-ci pour indicer récursivement la liste. Autrement
  dit, R sélectionnera la composante de la liste correspondant au
  premier élément du vecteur, puis l'élément de la composante
  correspondant au second élément du vecteur, et ainsi de suite.
<<echo=TRUE>>=
x[[c(1, 2)]]
@
%
\item Finalement, l'autre façon --- la meilleure, en fait --- de
  sélectionner un seul élément d'une liste est par son étiquette avec
  l'opérateur \Icode{\$}.
<<echo=TRUE>>=
x$size
@
\end{itemize}

Mentionnons en terminant la fonction \Icode{unlist} qui convertit une
liste en un vecteur simple. Elle est surtout utile pour concaténer les
éléments d'une liste lorsque ceux-ci sont des vecteurs simples,
idéalement de même mode, car il y aura autrement conversion forcée.
Attention: cette fonction est destructrice si la structure interne de
la liste est importante.
<<echo=TRUE>>=
unlist(x)
@

\gotorbox{La liste est une structure de données très importante en R.
  Prenez le temps de bien étudier les lignes
  \reflines{donnees:liste} du fichier de script
  \code{\scriptfilename} reproduit à la
  \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### LISTE  `\labelline{donnees:liste}`
###

## La liste est l'objet le plus général en R. C'est un objet
## récursif qui peut contenir des objets de n'importe quel
## mode (y compris la liste) et de n'importe quelle longueur.
(x <- list(joueur = c("V", "C", "C", "M", "A"),
           score = c(10, 12, 11, 8, 15),
           expert = c(FALSE, TRUE, FALSE, TRUE, TRUE),
           niveau = 2))
is.vector(x)               # liste est un vecteur...
is.recursive(x)            # ... récursif...
length(x)                  # ... de quatre éléments...
mode(x)                    # ... de mode "list"

## Comme tout autre vecteur, une liste peut être concaténée
## avec un autre vecteur avec la fonction 'c'.
y <- list(TRUE, 1:5)       # liste de deux éléments
c(x, y)                    # liste de six éléments

## Pour initialiser une liste d'une longueur donnée, on
## utilise la fonction 'vector'.
vector("list", 5)

## Les crochets simples [ ] permettent d'extraire un ou
## plusieurs éléments d'une liste. Le résultat est toujours
## une liste, même si l'on extrait un seul élément.
x[c(1, 2)]                 # deux premiers éléments
x[1]                       # premier élément: une liste

## Lorsque l'on veut extraire un, et un seul, élément d'une
## liste et obtenir l'objet lui-même (et non une liste
## contenant l'objet), il faut utiliser les crochets doubles
## [[ ]].
x[[1]]                     # comparer avec ci-dessus

## Jolie fonctionnalité: les crochets doubles permettent
## d'indicer récursivement la liste, c'est-à-dire d'extraire
## un objet de la liste, puis un élément de l'objet, et ainsi
## de suite.
x[[1]][2]                  # 2e élément du 1er élément
x[[c(1, 2)]]               # idem, par indiçage récursif

## Les éléments d'une liste étant généralement nommés (c'est
## une bonne habitude à prendre!), il est souvent plus simple
## et, surtout, plus sûr d'extraire les éléments d'une liste
## par leur étiquette avec l'opérateur $.
x$joueur                   # équivalent à x[[1]]
x$joueur[2]                # équivalent à x[[c(1, 2)]]
x[["expert"]]              # aussi valide, mais peu usité
x$level <- 1               # aussi pour l'affectation

## Une liste peut contenir n'importe quoi...
x[[5]] <- matrix(1, 2, 2)  # ... une matrice...
x[[6]] <- list(0:5, TRUE)  # ... une autre liste...
x[[7]] <- seq              # ... même le code d'une fonction!
x                          # eh ben!
x[[c(6, 1, 3)]]            # de quel élément s'agit-il?

## Il est possible de supprimer un élément d'une liste en lui
## affectant la valeur 'NULL'.
x[[7]] <- NULL; length(x)  # suppression du 7e élément

## Il est parfois utile de convertir une liste en un simple
## vecteur. Les éléments de la liste sont alors «déroulés», y
## compris la matrice en position 5 dans notre exemple (qui
## n'est rien d'autre qu'un vecteur, on s'en souviendra).
unlist(x)                    # remarquer la conversion
unlist(x, recursive = FALSE) # ne pas appliquer aux sous-listes
unlist(x, use.names = FALSE) # éliminer les étiquettes  `\labelline{donnees:liste:fin}`
@


\section{Application pour les listes et les vecteurs}
\label{sec:donnees:lapply}

Les idées de la \autoref{sec:donnees:apply} se transposent sans mal
aux listes et aux vecteurs. En effet, il n'y a pas d'arithmétique
vectorielle qui tienne pour les listes. Pour effectuer une opération
sur chaque élément d'une liste, il faut utiliser une procédure
itérative, procédure que R masque avec des fonctions d'application.

La fonction d'application de base pour les listes et les vecteurs est
\Icode{lapply}. Elle applique une fonction \code{FUN} à tous les
éléments d'un vecteur ou d'une liste \code{X} et retourne le résultat
sous forme de liste. La syntaxe de \code{lapply} est similaire à celle
de \icode{apply}, l'argument \code{MARGIN} en moins:
\begin{Schunk}
\begin{Verbatim}
lapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur ou une liste.
\item \code{FUN} est la fonction à appliquer à chacun des éléments de
  \code{X}. Ceux-ci ne sont pas nommés lorsqu'ils sont passés à la
  fonction. Les règles habituelles d'évaluation d'un appel de fonction
  s'appliquent: les données constituent le premier argument de
  \code{FUN}, à moins que des arguments nommés dans `\code{...}'
  n'aient préséance.
\end{itemize}

Vous avez déjà rencontré dans les exemples la fonction \icode{sample}
qui permet de tirer un échantillon aléatoire parmi un ensemble de
valeurs. Le premier argument de \code{sample} est \code{x}, l'ensemble
de valeurs. Le second argument est \code{size}, la taille de
l'échantillon. Les expressions ci-dessous permettent, dans l'ordre: de
créer une liste formée de quatre vecteurs aléatoires de taille $5$,
$6$, $7$ et $8$; de calculer la somme de chacun de ces vecteurs; de
trier chacun des vecteurs.
<<echo=TRUE>>=
(x <- lapply(5:8, sample, x = 1:10))
lapply(x, sum)
lapply(x, sort)
@

Sœur siamoise de \code{lapply}, la fonction \Icode{sapply} retourne,
lorsque c'est possible, son résultat sous forme de vecteur ou de
matrice. Le résultat est donc \emph{simplifié} par rapport à celui de
\code{lapply}, d'où le nom de la fonction. La syntaxe ne change pas:
\begin{Schunk}
\begin{Verbatim}
sapply(X, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item Si les résultats de l'application sont tous des vecteurs de
  longueur $1$, alors \code{sapply} retourne un vecteur.
\item Si les résultats de l'application sont des vecteurs de la même
  longueur supérieure à $1$, alors \code{sapply} retourne une
  matrice, remplie comme toujours par colonne.
\item Si les résultats de l'application sont des vecteurs de longueurs
  différentes, alors \code{sapply} est identique à \code{lapply}.
\end{itemize}
<<echo=TRUE>>=
(x <- lapply(rep(5, 3), sample, x = 1:10))
sapply(x, sum)
sapply(x, sort)
@

\tipbox{La fonction \icode{sapply} est souvent utile pour rendre
  vectorielle une fonction \code{f} qui ne le serait pas autrement. Il
  y a deux stratégies possibles: appliquer la fonction \code{f} à un
  vecteur avec \code{sapply}, ou modifier \code{f} pour y intégrer un
  appel à \code{sapply}.}

\importantbox{Outre l'\index{arithmetique@arithmétique
    vectorielle}algèbre vectorielle, l'application avec \icode{lapply}
  et \icode{sapply} constitue le principal moyen d'effectuer des
  calculs répétitifs dans R. On ne saurait donc trop insister sur
  l'importance de ces deux fonctions.}

Autre membre de la famille des fonctions d'application sur les listes
et les vecteurs, \Icode{mapply} est une version multidimensionnelle de
\code{sapply}. Sa syntaxe est, pour l'essentiel:
\begin{Schunk}
\begin{Verbatim}
mapply(FUN, ...)
\end{Verbatim}
\end{Schunk}
Le résultat de \code{mapply} est l'application de la fonction
\code{FUN} aux premiers éléments de tous les arguments contenus dans
`\code{...}', puis à tous les seconds éléments, et ainsi de suite.

Par exemple, si \code{v} et \code{w} sont des vecteurs,
\code{mapply(FUN, v, w)} retourne sous forme de liste, de vecteur ou
de matrice, selon le cas, \code{FUN(v[1], w[1])}, \code{FUN(v[2],
  w[2])}, \code{FUN(v[3], w[3])}, etc.

\gotorbox{Étudiez les lignes \reflines{donnees:lsmapply}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### APPLICATION POUR LES LISTES ET LES VECTEURS  `\labelline{donnees:lsmapply}`
###

## FONCTIONS 'lapply' ET 'sapply'

## La fonction 'lapply' applique une fonction à tous les
## éléments d'un vecteur ou d'une liste et retourne une liste,
## peu importe les dimensions des résultats.
##
## La fonction 'sapply' retourne un vecteur ou une matrice, si
## possible.
##
## Somme «interne» des éléments d'une liste.
(x <- list(1:10, c(-2, 5, 6), matrix(3, 4, 5)))
##-!- sum(x)                     # erreur
lapply(x, sum)             # sommes internes (liste)
sapply(x, sum)             # sommes internes (vecteur)

## Création de la suite 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ..., 1,
## 2, ..., 9, 10.
lapply(1:10, seq)          # résultat sous forme de liste
unlist(lapply(1:10, seq))  # résultat sous forme de vecteur

## Soit une fonction calculant la moyenne pondérée d'un
## vecteur. Cette fonction prend en argument une liste de deux
## éléments: 'donnees' et 'poids'.
fun <- function(x)
    sum(x$donnees * x$poids)/sum(x$poids)

## Nous pouvons maintenant calculer la moyenne pondérée de
## plusieurs ensembles de données réunis dans une liste
## itérée.
(x <- list(list(donnees = 1:7,
                poids = (5:11)/56),
           list(donnees = sample(1:100, 12),
                poids = 1:12),
           list(donnees = c(1, 4, 0, 2, 2),
                poids = c(12, 3, 17, 6, 2))))
sapply(x, fun)             # aucune boucle explicite!

## EXEMPLES ADDITIONNELS SUR L'UTILISATION DE L'ARGUMENT
## '...' AVEC 'lapply' ET 'sapply'

## Aux fins des exemples ci-dessous, créons d'abord une liste
## formée de nombres aléatoires.
##
## L'expression ci-dessous fait usage de l'argument '...' de
## 'lapply'. Pouvez-vous la décoder? Nous y reviendrons plus
## loin, ce qui compte pour le moment c'est simplement de
## l'exécuter.
x <- lapply(c(8, 12, 10, 9), sample, x = 1:10, replace = TRUE)

## Soit maintenant une fonction qui calcule la moyenne
## arithmétique des données d'un vecteur 'x' supérieures à une
## valeur 'y'.
##
## Vous remarquerez que cette fonction n'est pas vectorielle
## pour 'y', c'est-à-dire qu'elle n'est valide que lorsque 'y'
## est un vecteur de longueur 1.
fun <- function(x, y) mean(x[x > y])

## Pour effectuer ce calcul sur chaque élément de la liste
## 'x', nous pouvons utiliser 'sapply' plutôt que 'lapply',
## car chaque résultat est de longueur 1.
##
## Cependant, il faut passer la valeur de 'y' à la fonction
## 'fun'. C'est là qu'entre en jeu l'argument '...' de
## 'sapply'.
sapply(x, fun, 7)          # moyennes des données > 7

## Les fonctions 'lapply' et 'sapply' passent tour à tour les
## éléments de leur premier argument comme *premier* argument
## à la fonction, sans le nommer explicitement. L'expression
## ci-dessus est donc équivalente à
##
##   c(fun(x[[1]], 7), ..., fun(x[[4]], 7)
##
## Que se passe-t-il si l'on souhaite passer les valeurs à un
## argument de la fonction autre que le premier? Par exemple,
## supposons que l'ordre des arguments de la fonction 'fun'
## ci-dessus est inversé.
fun <- function(y, x) mean(x[x > y])

## Les règles de pairage des arguments des fonctions en R font
## en sorte que lorsque les arguments sont nommés dans l'appel
## de fonction, leur ordre n'a pas d'importance. Par
## conséquent, un appel de la forme
##
##   fun(x, y = 7)
##
## est tout à fait équivalent à fun(7, x). Pour effectuer les
## calculs
##
##   c(fun(x[[1]], y = 7), ..., fun(x[[4]], y = 7)
##
## avec la liste définie plus haut, il s'agit de nommer
## l'argument 'y' dans '...' de 'sapply'.
sapply(x, fun, y = 7)

## Décodons maintenant l'expression
##
##   lapply(c(8, 12, 10, 9), sample, x = 1:10, replace = TRUE)
##
## qui a servi à créer la liste. La définition de la fonction
## 'sample' est la suivante:
##
##   sample(x, size, replace = FALSE, prob = NULL)
##
## L'appel à 'lapply' est équivalent à
##
##   list(sample(8, x = 1:10, replace = TRUE),
##        ...,
##        sample(9, x = 1:10, replace = TRUE))
##
## Toujours selon les règles d'appariement des arguments, vous
## constaterez que les valeurs 8, 12, 10, 9 seront attribuées
## à l'argument 'size', soit la taille de l'échantillon.
##
## L'expression crée donc une liste comprenant quatre
## échantillons aléatoires de tailles différentes des nombres
## de 1 à 10 pigés avec remise.
##
## Une expression équivalente, quoique moins élégante, aurait
## recours à une fonction anonyme pour replacer les arguments
## de 'sample' dans l'ordre voulu.
lapply(c(8, 12, 10, 9),
       function(x) sample(1:10, x, replace = TRUE))

## La fonction 'sapply' est aussi très utile pour vectoriser
## une fonction qui n'est pas vectorielle. Supposons que l'on
## veut généraliser la fonction 'fun' pour qu'elle accepte un
## vecteur de seuils 'y'.
fun <- function(x, y)
    sapply(y, function(y) mean(x[x > y]))

## Utilisation sur la liste 'x' avec trois seuils.
sapply(x, fun, y = c(3, 5, 7))

## FONCTION 'mapply'

## Application de la fonction 'fun' sur les échantillons de la
## liste 'x' avec un seuil différent pour chacun.
mapply(fun, x, c(3, 5, 7, 7))

## Création de quatre échantillons aléatoires de taille 12.
x <- lapply(rep(12, 4), sample, x = 1:100)

## Moyennes tronquées à 0, 10, 20 et 30 %, respectivement, de
## ces quatre échantillons aléatoires.
mapply(mean, x, 0:3/10)    #-*- `\labelline{donnees:lsmapply:fin}`
@


\section{Tableau de données}
\label{sec:donnees:dataframes}

Le \Index{tableau de données}\index{data frame|see{tableau de
    données}}tableau de données (\emph{data frame}\footnote{%
  Il n'y a pas de traduction française universelle pour \emph{data
    frame}, mais «tableau de données» semble la plus répandue. Ne vous
  surprenez pas de voir tout bonnement «data frame» dans les messages
  français de R. Comme c'est souvent le cas, des nuances se perdent
  dans la traduction puisque ce n'est pas pour rien si la structure de
  données s'appelle \emph{data frame} et non \emph{data table}.
  Discuter de la raison est toutefois hors de la portée de cet
  ouvrage.}) %
est une structure de données de R sur laquelle reposent plusieurs
procédures statistiques comme la régression linéaire. Un tableau de
données est un hybride entre la matrice et la liste: il s'agit d'un
tableau rectangulaire de données, mais dont chaque colonne peut être
d'un mode différent. Pensons, par exemple, à un tableau avec des noms
(mode \code{character}) dans une colonne et des notes (mode
\code{numeric}) dans une autre.

Formellement, un \index{tableau de données}tableau de données est
une liste de classe \code{data.frame} dont tous les éléments sont de
la même longueur (ou comptent le même nombre de lignes, si les
éléments sont des matrices). Chaque élément de la liste correspond à
une colonne du tableau. On crée un tableau de données avec la fonction
\Icode{data.frame} ou, pour convertir un autre type d'objet en tableau
de données (notamment les matrices), avec \Icode{as.data.frame}.
<<echo=TRUE>>=
(x <- data.frame(Nom = c("Pierre", "Jean", "Jacques"),
                 Age = c(42, 34, 19),
                 Fumeur = c(TRUE, TRUE, FALSE)))
@

Le tableau de données peut être indicé à la fois comme une liste (pour
l'extraction des colonnes) et comme une matrice (pour l'extraction des
lignes ou des colonnes).
<<echo=TRUE>>=
x[1, ]
x[, 1]
x$Age
@

Il est possible d'ajouter des lignes ou des colonnes à un tableau de
données avec les fonctions \icode{rbind} et \icode{cbind}.

\tipbox{Vous remarquerez, ci-dessus, que les données de la colonne
  \code{Nom} sont considérées comme des facteurs. C'est une
  caractéristique de la fonction \code{data.frame} de convertir
  automatiquement les chaines de caractères en facteurs. L'option
  \code{stringAsFactors = FALSE} permet d'éviter la conversion
  forcée.}

\gotorbox{Étudiez les quelques exemples de tableaux de données
  présentés aux lignes \reflines{donnees:dataframe} du fichier de
  script \code{\scriptfilename} reproduit à la
  \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### TABLEAU DE DONNÉES  `\labelline{donnees:dataframe}`
###

## Un tableau de données (data frame) est une liste dont les
## éléments sont tous de la même longueur. Il comporte un
## attribut 'dim', ce qui fait qu'il est représenté comme une
## matrice. Cependant, les colonnes peuvent être de modes
## différents.
##
## Nous créons ici le même data frame que dans l'exemple du
## chapitre, mais avec l'option 'stringsAsFactors = FALSE'
## pour éviter la conversion automatique de la colonne 'Nom'
## en facteur.
data.frame(Nom = c("Pierre", "Jean", "Jacques"),
           Age = c(42, 34, 19),
           Fumeur = c(TRUE, TRUE, FALSE),
           stringsAsFactors = FALSE)

## R est livré avec plusieurs jeux de données, la plupart sous
## forme de data frames.
##-!- data()                     # liste complète

## Nous allons illustrer certaines manipulations des data
## frames avec le jeu de données 'USArrests'.
USArrests                  # jeu de données

## Analyse succincte de l'objet.
mode(USArrests)            # un data frame est une liste...
length(USArrests)          # ... de quatre éléments...
class(USArrests)           # ... de classe 'data.frame'
dim(USArrests)             # dimensions implicites
names(USArrests)           # titres des colonnes
row.names(USArrests)       # titres des lignes
USArrests[, 1]             # première colonne
USArrests$Murder           # idem, plus simple
USArrests[1, ]             # première ligne

## La fonction 'subset' permet d'extraire des lignes et des
## colonnes d'un data frame de manière très intuitive.
##
## Par exemple, nous pouvons extraire ainsi le nombre
## d'assauts dans les états comptant un taux de meurtre
## supérieur à 10.
subset(USArrests, Murder > 10, select = Assault) #-*- `\labelline{donnees:dataframe:fin}`
@


\section{Facteur}
\label{sec:donnees:facteur}

Il est très courant en analyse de données de travailler avec des
catégories comme la couleur («rouge», «vert», «bleu»), la taille
(«petit», «moyen», «grand») ou la position géographique (pays,
province, état). Bien sûr, un vecteur de mode \code{character} suffit
pour stocker ce genre de données. Cependant, R propose une structure
de données dédiée pour les données catégorielles qui permet
d'automatiser plusieurs traitements: le facteur.

Un facteur est un vecteur de données correspondant à des catégories. À
ce titre, il devrait normalement afficher un fort taux de redondance:
inutile de définir des catégories s'il y en a une différente pour
chaque donnée, n'est-ce pas?

Les fonctions de base pour créer et manipuler des facteurs sont
\Icode{factor} et \Icode{levels}. R représente les données sous forme
de chaine de caractères, mais il les stocke et les traite à l'interne
comme un vecteur d'entiers.
<<echo=TRUE>>=
(grandeurs <- factor(c("S", "S", "L", "XL",
                       "M", "M", "L", "L")))
levels(grandeurs)
@

Les facteurs sont assez peu utilisés en tant que structure de données
en programmation. Par contre, ils s'avèrent essentiels pour les
calculs par groupe de données à l'aide d'une fonction
d'application.


\section{Application pour les groupes de données}
\label{sec:donnees:tapply}

La fonction \Icode{tapply} applique une fonction à chacun des groupes
de données définis par les catégories d'un facteur ou d'une
combinaison de facteurs. Pour mieux comprendre, étudions la syntaxe de
la fonction:
\begin{Schunk}
\begin{Verbatim}
tapply(X, INDEX, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} est un vecteur.
\item \code{INDEX} est un facteur ou une liste de facteurs, chacun de la
  même longueur que \code{X}.
\item \code{FUN} est la fonction à appliquer à chacun des groupes de
  données définis par les catégories des facteurs dans \code{INDEX}.
\end{itemize}
<<echo=TRUE>>=
x <- data.frame(couleur=c("r", "v", "r", "r", "v"),
                score=c(2, 0, 4, 3, 10))
str(x)
tapply(x$score, x$couleur, mean)
@

\gotorbox{Étudiez les lignes \reflines{donnees:facteur}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### FACTEUR  `\labelline{donnees:facteur}`
###

## Les facteurs jouent un rôle important en analyse de
## données, surtout pour classer des données en diverses
## catégories. Les données d'un facteur devraient normalement
## afficher un fort taux de redondance.
##
## Reprenons l'exemple du chapitre.
(grandeurs <-
     factor(c("S", "S", "L", "XL", "M", "M", "L", "L")))
levels(grandeurs)          # catégories
as.integer(grandeurs)      # représentation interne

## Dans le présent exemple, nous pourrions souhaiter que R
## reconnaisse le fait que S < M < L < XL. C'est possible avec
## les facteurs *ordonnés*.
factor(c("S", "S", "L", "XL", "M", "M", "L", "L"),
       levels = c("S", "M", "L", "XL"),
       ordered = TRUE)

###
### APPLICATION POUR LES GROUPES DE DONNÉES
###

## Le jeu de données 'airquality' livré avec R contient les
## mesures quotidiennes de la qualité de l'air à New York
## entre mai et septembre 1973.
##-!- ?airquality                # rubrique d'aide du jeu de données

## La colonne 'Temp' contient la température du jour et la
## colonne 'Month', le mois (sous forme d'entier de 5 à 9).
##
## La fonction 'tapply' permet de calculer facilement la
## température moyenne par mois.
tapply(airquality$Temp, airquality$Month, mean)

## Équivalent (sauf pour la présentation des résultats).
by(airquality$Temp, airquality$Month, mean) #-*- `\labelline{donnees:facteur:fin}`
@


\section{Date}
\label{sec:donnees:date}

Plusieurs analyses de données impliquent l'enregistrement et le
traitement des dates. Or, les dates figurent parmi les données les
plus complexes à traiter, et ce, dans n'importe quel langage de
programmation ou outil d'analyse. Pensez seulement: il faut tenir
compte du nombre variable de jours par mois, des années bissextiles,
des secondes intercalaires, des fuseaux horaires et du type de
calendrier. Nous pourrions y consacrer un chapitre entier.

R contient dans le système de base les fonctionnalités essentielles
pour manipuler les dates: stockage dans divers formats, tri,
comparaison, génération de suites, etc. L'infractructure repose sur
trois classes d'objets principales: \Icode{Date}, \Icode{POSIXct} et
\Icode{POSIXlt}.\footnote{%
  \index{POSIX}POSIX est une famille de normes techniques de
  standardisation des interfaces de programmation des logiciels
  destinés à fonctionner sur les variantes du système d'exploitation
  \index{Unix}Unix.} %
Les fonctions \Icode{as.Date}, \Icode{as.POSIXct} et
\Icode{as.POSIXlt} permettent de convertir un objet (notamment une
chaine de caractères) vers la classe correspondante.

\begin{itemize}
\item La classe \icode{Date} permet de représenter une date au jour
  près (sans l'heure, donc). À l'interne, la date est enregistrée
  comme le nombre de jours depuis l'époque\footnote{%
    \textbf{époque}, n.~f.\ Moment choisi arbitrairement dans le temps
    auquel se réfèrent les mesures de position.
    (\link{http://gdt.oqlf.gouv.qc.ca/ficheOqlf.aspx?Id_Fiche=17052384}{Grand
      dictionnaire terminologique})} %
  POSIX, le 1{\ier} janvier 1970. Les opérateurs suivants sont définis
  pour les dates: \icode{+}, \icode{-} (avec un nombre de jours),
  \icode{==}, \index{"!=@\code{"!=}}\verb|!=|, \icode{<}, \icode{<=},
  \icode{>} et \icode{>=} (entre deux dates). La fonction \icode{seq}
  peut également générer des suites d'une date à une autre pour divers
  intervalles.
<<echo=TRUE>>=
(d <- as.Date("2000-02-29"))
d + 1
as.Date("2019-09-01") > d
seq(as.Date("2019-09-01"), as.Date("2020-05-31"),
    by = "month")
@
%
\item La classe \icode{POSIXct} permet de représenter une date et une
  heure à la seconde près (incluant le fuseau horaire). C'est
  habituellement le type de représentation privilégié dans les
  tableaux de données. À l'interne, la date est enregistrée en nombre
  de secondes depuis l'époque POSIX. Certains opérateurs sont définis
  pour les objets \code{POSIXct}, mais vous devez tenir compte que
  tous les calculs sont effectués en secondes.
<<echo=TRUE>>=
(d <- as.POSIXct("2000-02-29 10:51:27"))
d + 1
d + 3600
seq(as.POSIXct("2019-09-01 08:30"),
    as.POSIXct("2019-09-01 13:00"),
    by = "hour")
@
%
\item Un objet de classe \icode{POSIXlt} contient les mêmes
  informations qu'un objet \icode{POSIXct}, mais sous forme de liste à
  raison d'un élément par composante de la date et de l'heure: année
  (depuis $1900$), mois (après le premier, $0$--$11$), jour
  ($1$--$31$), heure ($0$--$23$), minute ($0$--$59$), seconde
  ($0$-$61$), fuseau horaire, etc. La représentation en format
  \code{POSIXlt} est surtout utile pour extraire des informations
  d'une date. N'hésitez donc pas à convertir un objet \code{POSIXct}
  en objet \code{POSIXlt} pour extraire des composantes d'une date.
<<echo=TRUE>>=
(d <- as.POSIXlt("2000-02-29 10:51:27"))
d$year
d$mon
d$hour
@
\end{itemize}

\tipbox{Consultez les rubriques d'aide de \code{Date} et de
  \code{DateTimeClasses}. Elles contiennent une foule de détails
  additionnels sur la représentation et le traitement des dates dans
  R.}

\notebox{Que s'est-il passé de spécial le 29 février 2000? Les années
  multiples de 100 ne sont pas bissextiles, sauf celles multiples de
  400. C'est pourquoi 2000 était bel et bien une année bissextile. La
  prochaine du type aura donc lieu en{\dots} 2400. Certains logiciels
  à l'époque étaient affligés d'un bogue qui faisait en sorte que la
  date n'existait pas dans leur calendrier. C'est beaucoup par
  espièglerie que le \emph{R Core Team} a justement choisi cette
  journée pour lancer la
  \link{ftp://cran.r-project.org/pub/R/R-release-1.0.0.html}{version
    1.0.0 de R}.}

\gotorbox{Les lignes \reflines{donnees:date} du fichier de script
  \code{\scriptfilename} reproduit à la \autoref{sec:donnees:exemples}
  contiennent des exemples additionnels de manipulation des dates.}

<<script, results=hide>>=
###
### DATE  `\labelline{donnees:date}`
###

## Votre premier réflexe pour représenter une date pourrait
## être d'utiliser simplement une chaine de caractères. Ça
## suffit si les dates sont à intervalles égaux et pour
## identifier les points sur un graphique. Dès lors que vous
## devez tenir compte de l'écart entre les dates ou effectuer
## des calculs avec les dates, il vous faut une solution plus
## robuste.
##
## R utilise la représentation standard des systèmes Unix
## consignée dans la norme POSIX. En simplifiant, le temps y
## est compté (en jours pour une date seule, en secondes pour
## une date et une heure) à partir du 1er janvier 1970.
##
## Une date n'est donc rien d'autre qu'un entier à l'interne
## pour R. C'est ce qui permet d'effectuer facilement des
## calculs et des comparaisons. Cependant, l'objet est muni
## d'un attribut "class" qui fait en sorte de modifier
## l'affichage et l'interaction avec certaines fonctions.
##
## Pour les dates seules, la classe de base est "Date".
d <- "2000-02-29"          # chaine de caractères
##-!- d + 1                      # opération invalide
d <- as.Date(d)            # conversion en date
d + 1                      # opération valide; jour suivant
d - 1                      # jour précédent
as.numeric(d)              # nombre de jours depuis 1970-01-01
d - as.Date("1970-01-01")  # vérification
(auj <- Sys.Date())        # date du jour
auj >= d                   # après le 2000-02-29?

## Chose particulièrement utile, la fonction 'seq' est munie
## d'une méthode pour la classe "Date", ce qui permet de
## générer des suites de dates.
##
## Exemple: générer les dates des 10 prochaines semaines à
## partir d'aujourd'hui.
(dixsem <- seq(Sys.Date(), length.out = 10, by = "1 week"))
##-!- ?seq.Date                  # voir les autres possibilités

## Quelques fonctions d'extraction utiles.
weekdays(dixsem)           # jours de la semaine
months(dixsem)             # mois
quarters(dixsem)           # trimestres

## Pour enregistrer non seulement une date, mais aussi une
## heure, vous devez utiliser les représentations POSIXct et
## POSIXlt. Il s'agit de classes d'objets très puissantes qui
## permettent d'enregistrer une heure jusqu'à la fraction de
## seconde, le fuseau horaire, s'il s'agit de l'heure d'été ou
## non, etc.
##-!- ?DateTimeClasses           # *tous* les détails

## Les objets POSIXct et POSIXlt représentent un nombre de
## secondes depuis le 1er janvier 1970.
(auj <- Sys.time())        # date et heure courante
auj + 3600                 # une heure plus tard
auj - 24 * 3600            # hier, même heure
auj - as.POSIXct("2000-02-29") # écart entre deux dates
difftime(auj, as.POSIXct("2000-02-29")) # idem

## La classe POSIXlt est un représentation sous forme de liste
## des informations contenues dans un objet POSIXct. Elle est
## surtout utile pour extraire facilement des informations
## d'une date sous forme numérique, ce qui permet ensuite
## d'effectuer des calculs.
##
## N'hésitez pas à convertir d'un type vers un autre.
class(auj)                 # objet POSIXct
auj <- as.POSIXlt(auj)     # conversion en POSIXlt
unclass(auj)               # c'est une liste
auj$hour                   # extraction de l'heure
(m <- auj$mon)             # nombre de mois après janvier
11 - m                     # nombre de mois fin d'année
(y <- auj$year)            # nombre d'année depuis 1900 (!)
y - (2000 - 1900)          # nombre d'années depuis 2000

## La conversion de la classe POSIXct ou POSIXlt vers la
## classe Date laisse tomber l'heure.
d <- as.POSIXct("2000-02-29 10:51:27") # objet POSIXct
as.Date(d)                 # conversion en date seule `\labelline{donnees:date:fin}`
@


\section{Fonctions internes utiles}
\label{sec:donnees:internes}

Cette section présente les fonctions internes couramment utilisées
pour les opérations sur les matrices. Les exemples utilisent la
matrice suivante.
<<echo=FALSE>>=
x <- matrix(c(2, 1, 4, 3), 2)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{rowMeans}
\item[\Icode{nrow}] \index{matrice!nombre de
    lignes}nombre de lignes
<<echo=TRUE>>=
nrow(x)
@
\item[\Icode{ncol}] nombre de \index{matrice!nombre de
    colonnes}colonnes
<<echo=TRUE>>=
ncol(x)
@
\item[\Icode{rowSums}] \index{matrice!sommes par ligne}sommes par
  ligne
<<echo=TRUE>>=
rowSums(x)
@
\item[\Icode{colSums}] \index{matrice!sommes par colonne}sommes par
  colonne
<<echo=TRUE>>=
colSums(x)
@
\item[\Icode{rowMeans}] \index{matrice!moyennes par ligne}moyennes par
  ligne
<<echo=TRUE>>=
rowMeans(x)
@
\item[\Icode{colMeans}] \index{matrice!moyennes par colonne}moyennes
  par colonne
<<echo=TRUE>>=
colMeans(x)
@
\item[\code{\%*\%}] \index{matrice!produit}produit matriciel
<<echo=TRUE>>=
x %*% x
@
\item[\Icode{t}] \index{matrice!transposée}transposée
<<echo=TRUE>>=
t(x)
@
\item[\Icode{det}] \index{matrice!déterminant}déterminant
<<echo=TRUE>>=
det(x)
@
\item[\Icode{solve}] avec un seul argument (une matrice carrée):
  \index{matrice!inverse}inverse
<<echo=TRUE>>=
solve(x)
@
  avec deux arguments (une matrice
  carrée et un vecteur): solution du système d'équations linéaires
  $\mat{A} \mat{x} = \mat{b}$
<<echo=TRUE>>=
solve(x, c(1, 2))
@
\item[\Icode{diag}] avec une matrice en argument:
  \index{matrice!diagonale}diagonale de la matrice
<<echo=TRUE>>=
diag(x)
@
  avec un vecteur en
  argument: matrice diagonale formée avec le vecteur
<<echo=TRUE>>=
diag(c(5, 1))
@
  avec un scalaire
  $p$ en argument: \index{matrice!identité}matrice identité
  $p \times p$
<<echo=TRUE>>=
diag(2)
@
\end{ttscript}

\gotorbox{Étudiez les lignes \reflines{donnees:internes}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}

<<script, results=hide>>=
###
### FONCTIONS INTERNES UTILES  `\labelline{donnees:internes}`
###

## On se donne un vecteur de 16 éléments.
(A <- sample(1:10, 16, replace = TRUE))

## Opérations sur les matrices.
dim(A) <- c(4, 4)          # conversion en une matrice 4 x 4
b <- c(10, 5, 3, 1)        # vecteur quelconque
A                          # matrice 'A'
t(A)                       # transposée
solve(A)                   # inverse
solve(A, b)                # solution de Ax = b
A %*% solve(A, b)          # vérification de la réponse
diag(A)                    # extraction de la diagonale de 'A'
diag(b)                    # matrice diagonale formée avec 'b'
diag(4)                    # matrice identité 4 x 4
(A <- cbind(A, b))         # matrice 4 x 5
nrow(A)                    # nombre de lignes de 'A'
ncol(A)                    # nombre de colonnes de 'A'
rowSums(A)                 # sommes par ligne
colSums(A)                 # sommes par colonne  `\labelline{donnees:internes:fin}`
@


\section{Produit extérieur}
\label{sec:application:outer}

En étirant un peu le concept, la fonction de produit extérieur
\code{outer} peut être considérée comme une fonction d'application.
Son utilisation, du moins, est très similaire aux fonctions
d'application. Je la présente seulement ici car son résultat est une
matrice ou un tableau.

La fonction \Index{outer} est très utile pour effectuer plusieurs
opérations en une seule expression. Elle calcule le
\index{produit!extérieur}produit extérieur entre deux vecteurs, c'est
à dire le résultat de \code{FUN(X[i], Y[j])} pour toutes les valeurs
des indices \code{i} et \code{j}. La syntaxe de la fonction est la
suivante:
\begin{Schunk}
\begin{Verbatim}
outer(X, Y, FUN, ...)
\end{Verbatim}
\end{Schunk}
\begin{itemize}
\item \code{X} et \code{Y} sont deux objets, normalement des vecteurs
  ou des matrices.
\item \code{FUN} est la fonction à appliquer (\code{"*"}, ou le
  produit, par défaut) entre chacun des éléments de \code{X} et chacun
  des éléments de \code{Y}. Lorsque \code{FUN} est un opérateur
  arithmétique du \autoref{tab:bases:operateurs}, il faut placer le
  symbole entre guillemets: \code{"*"}, \code{"+"}, \code{"<="}, etc.
\end{itemize}
La dimension du résultat de \code{outer} est \code{c(dim(X), dim(Y))}.
<<echo=TRUE>>=
outer(c(1, 2, 5), c(2, 3, 6))
@

L'opérateur \Icode{\%o\%} est un raccourci de \code{outer(X, Y, "*")}.

\videobox{\link{https://youtu.be/cyPUAnieWHw}{Fonction \code{outer}}}{%
  Visionnez la vidéo sur la
  \link{https://youtu.be/cyPUAnieWHw}{fonction \icode{outer}} pour
  mieux comprendre le rôle de cette fonction.}

\gotorbox{Étudiez les lignes \reflines{donnees:outer}
  du fichier de script \code{\scriptfilename}.}

<<script, results=hide>>=
###
### FONCTION 'outer'  `\labelline{donnees:outer}`
###

## La fonction 'outer' applique une fonction (le produit par
## défaut, d'où le nom de la fonction, dérivé de «produit
## extérieur») à toutes les combinaisons des éléments de ses
## deux premiers arguments.
x <- c(1, 2, 4, 7, 10, 12)
y <- c(2, 3, 6, 7, 9, 11)
outer(x, y)                # produit extérieur
x %o% y                    # équivalent plus court

## Pour effectuer un calcul autre que le produit, on spécifie
## la fonction à appliquer en troisième argument. Si la
## fonction est un des opérateurs arithmétiques de base, il
## faut placer le symbole entre guillemets " ".
outer(x, y, "+")           # «somme extérieure»
outer(x, y, "<=")          # toutes les comparaisons possibles
outer(x, y, function(x, y) x + 2 * y) # fonction quelconque  `\labelline{donnees:outer:fin}`
@


\section{Exemples}
\label{sec:donnees:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:donnees:exercices}

\Opensolutionfile{solutions}[solutions-donnees]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:donnees}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:donnees}}

\end{Filesave}

\begin{exercice}
  Évaluer les expressions suivantes comme le ferait l'interpréteur R.
  \begin{enumerate}
  \item \verb|length(c("a", "abc", "ab"))|
  \item \verb|x <- c(-1, -2, -3); length(x)|
  \item \verb|length(c(c(1, 3, 6, 7), NULL))|
  \item \verb|mode(c(45.44, pi, TRUE))|
  \item \verb|mode(c(5, "5", "cinq"))|
  \item \verb|sum(is.na(c(4, NA, 3, 8, NA)))|
  \item \verb|matrix(1:6, 2)[, 2]|
  \item \verb|as.POSIXlt(as.Date("2001-05-09"))$day|
  \item \verb|list(NA, 1:10, list(NA, 1:10))|
  \item \verb|x <- data.frame(A = 1:3, B = 5:7); x$A|
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
     \item Vecteur de trois chaines de caractères, peu importe leur
       longueur.
<<echo=FALSE>>=
length(c("a", "abc", "ab"))
@
     \item Longueur du vecteur.
<<echo=FALSE>>=
x <- c(-1, -2, -3); length(x)
@
     \item Concaténer \code{NULL} à un vecteur n'ajoute rien (ou du
       vide, qui n'a pas de longueur).
<<echo=FALSE>>=
length(c(c(1, 3, 6, 7), NULL))
@
     \item La valeur booléenne est convertie en nombre réel.
<<echo=FALSE>>=
mode(c(45.44, pi, TRUE))
@
     \item Le nombre réel est converti en chaine de caractères.
<<echo=FALSE>>=
mode(c(5, "5", "cinq"))
@
     \item Nombre de données manquantes dans le vecteur.
<<echo=FALSE>>=
sum(is.na(c(4, NA, 3, 8, NA)))
@
     \item Deuxième colonne de la matrice $\Bigl[\begin{smallmatrix} 1 & 3 & 5
           \\ 2 & 4 & 6 \end{smallmatrix} \Bigr]$.
<<echo=FALSE>>=
matrix(1:6, 2)[, 2]
@
     \item Jour du mois de la date.
<<echo=FALSE>>=
as.POSIXlt(as.Date("2001-05-09"))$mday
@
     \item Liste trois éléments dont le troisième élément est une
       sous-liste de deux éléments.
<<echo=FALSE>>=
list(NA, 1:10, list(NA, 1:10))
@
     \item Première colonne du tableau de données, sous forme de vecteur.
<<echo=FALSE>>=
x <- data.frame(A = 1:3, B = 5:7); x$A
@
     \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \index{indiçage!matrice}
  Soit \code{x} une matrice $7 \times 10$ obtenue aléatoirement avec
<<echo=TRUE,eval=FALSE>>=
x <- matrix(sample(1:100, 70), 7, 10)
@
  Écrire des expressions R permettant d'obtenir les éléments de la
  matrice demandés ci-dessous.
  \begin{enumerate}
  \item L'élément $(4, 3)$.
  \item Le contenu de la sixième ligne.
  \item Les première et quatrième colonnes (simultanément).
  \item Les lignes dont le premier élément est supérieur à $50$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[4, 3]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[6, ]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[, c(1, 4)]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x[, 1] > 50, ]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Trouver une formule pour calculer la position, dans le vecteur
    sous-jacent, de l'élément $(i, j)$ d'une matrice $I \times J$
    remplie par colonne.
  \item Répéter la partie a) pour l'élément $(i, j, k)$ d'un tableau
    $I \times J \times K$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item \verb|(j - 1) * I + i|
    \item \verb|((k - 1) * J + j - 1) * I + i|
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit \code{m} une matrice $10 \times 7$ quelconque. Écrire des
  expressions R permettant d'effectuer les tâches demandées
  ci-dessous.
  \begin{enumerate}
  \item Calculer la somme des éléments de chacunes des lignes de la
    matrice.
  \item Calculer la moyenne des éléments de chacunes des colonnes de
    la matrice.
  \item Calculer la valeur maximale de la sous-matrice formée par les
    trois premières lignes et les trois premières colonnes de la
    matrice.
  \item Extraire toutes les lignes de la matrice dont la moyenne des
    éléments est supérieure à $7$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE, eval=FALSE>>=
rowSums(m)
@
\item
<<echo=TRUE, eval=FALSE>>=
colMeans(m)
@
\item
<<echo=TRUE, eval=FALSE>>=
max(m[1:3, 1:3])
@
\item
<<echo=TRUE, eval=FALSE>>=
m[rowMeans(m) > 7, ]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Écrire une fonction \code{sort.matrix} servant à ordonner les lignes
  d'une matrice selon les valeurs des éléments de la première colonne.

  Par défaut, la fonction trie en ordre croissant. Elle peut également
  trier en ordre décroissant si son argument \code{decreasing} est
  \code{TRUE}.

<<echo=FALSE>>=
sort.matrix <- function(m, decreasing = FALSE)
    m[order(m[, 1], decreasing = decreasing), ]
set.seed(4)
m <- matrix(sample(1:10, 12, rep = TRUE), 3, 4)
@
<<echo=TRUE>>=
m
sort.matrix(m)
sort.matrix(m, decreasing = TRUE)
@

  \begin{sol}
    La solution repose sur l'utilisation judicieuse de la fonction
    \icode{order}.
<<echo=TRUE>>=
sort.matrix
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Écrire une expression R pour créer la liste suivante:
<<echo=FALSE>>=
x <- list(1:5, data=matrix(1:6, 2, 3), numeric(3), test=logical(4))
@
<<echo=TRUE>>=
x
@ %
  \item \index{etiquette@étiquette} Extraire les étiquettes de la
    liste.
  \item \index{mode} \index{longueur} Trouver le mode et la longueur
    du quatrième élément de la liste.
  \item \index{dimension} Extraire les dimensions du second élément de
    la liste.
  \item \index{indiçage!liste} Extraire les deuxième et troisième
    éléments du second élément de la liste.
  \item Remplacer le troisième élément de la liste par le vecteur
    \verb|3:8|.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item Il y a plusieurs façons de créer les troisième et quatrième
      éléments de la liste. Le plus simple consiste à utiliser
      \code{numeric()} et \code{logical()}:
<<echo=TRUE,eval=FALSE>>=
x <- list(1:5, data = matrix(1:6, 2, 3), numeric(3),
          test = logical(4))
@
    \item
<<echo=TRUE,eval=FALSE>>=
names(x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
mode(x$test)
length(x$test)
@
    \item
<<echo=TRUE,eval=FALSE>>=
dim(x$data)
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[2]][c(2, 3)]
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[3]] <- 3:8
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  La valeur actuelle d'une série de $n$ paiements de $1$ versés à la
  fin des années $1, 2, \dots, n$ à un taux d'intérêt $i$ est
  \begin{equation*}
    a_\angln
    = v + v^2 + \dots + v^n
    = \frac{1 - v^n}{i},
  \end{equation*}
  où $v = (1 + i)^{-1}$. À partir de vecteurs \code{n} et \code{i}
  contenant les durées et les taux d'intérêt, respectivement, calculer
  en une seule expression et \emph{sans boucle} un tableau des valeurs
  actuelles de séries de $n = 1, 2, \dots, 10$ paiements à chacun des
  taux d'intérêt $i = 0,05, 0,06, \dots, 0,10$.
  \begin{sol}
    Deux solutions. La première utilise directement la formule $(1 -
    (1 + i)^{-n})/i$ pour calculer les valeurs actuelles:
<<echo=TRUE>>=
n <- 1:10
i <- seq(0.05, 0.1, by = 0.01)
(1 - outer((1 + i), -n, "^"))/i
@
    La seconde calcule plutôt les valeurs actuelles à partir de la
    définition $(1 + i)^{-1} + (1 + i)^{-2} + \dots + (1 +
    i)^{-n}$ (le résultat est toutefois transposé par rapport à la
    première solution):
<<echo=TRUE>>=
n <- 1:10
i <- (5:10)/100
apply(outer(1/(1 + i), n, "^"), 1, cumsum)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{ex:application:moyennes}
  Étant donné un vecteur d'observations $\mat{x} = (x_1, \dots, x_n)$
  et un vecteur de poids correspondants $\mat{w} = (w_1, \dots, w_n)$,
  calculer la moyenne pondérée des observations,
  \begin{equation*}
    X_w = \sum_{i = 1}^n \frac{w_i}{w_\pt} x_i,
  \end{equation*}
  où $w_\pt = \sum_{i = 1}^n w_i$. Tester l'expression avec les vecteurs
  de données
  \begin{align*}
    \mat{x}
    &= (7, 13, 3, 8, 12, 12, 20, 11) \\
    \intertext{et} \mat{w}
    &= (0,15,\; 0,04,\; 0,05,\; 0,06,\; 0,17,\; 0,16,\; 0,11,\; 0,09).
  \end{align*}
  \begin{sol}
<<echo=TRUE>>=
x <- c(7, 13, 3, 8, 12, 12, 20, 11)
w <- c(0.15, 0.04, 0.05, 0.06, 0.17, 0.16, 0.11, 0.09)
sum(x * w)/sum(w)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Nous pouvons généraliser aux matrices et aux tableaux de données la
  définition de moyenne pondérée de
  l'\autoref{ex:application:moyennes}.

  Dans le cas d'une matrice $n \times p$ d'observations $X_{ij}$ et
  poids $w_{ij}$ correspondant, on définit les moyennes pondérées
  suivantes:
  \begin{align*}
    X_{iw}
    &= \sum_{j = 1}^p \frac{w_{ij}}{w_{i\pt}}\, X_{ij}, \quad
    w_{i\pt} = \sum_{j = 1}^p w_{ij} \\
    X_{wj}
    &= \sum_{i = 1}^n \frac{w_{ij}}{w_{\pt j}}\, X_{ij}, \quad
    w_{\pt j} = \sum_{i = 1}^n w_{ij} \\
    \intertext{et}
    X_{ww}
    &= \sum_{i = 1}^n \sum_{j=1}^p \frac{w_{ij}}{w_{\pt\pt}}\, X_{ij}, \quad
    w_{\pt\pt} = \sum_{i = 1}^n \sum_{j = 1}^p w_{ij}.
  \end{align*}
  En suivant la même logique que ci-dessus, il est possible de définir
  des moyennes pondérées pour un tableau de données $X_{ijk}$ de
  dimensions $n \times p \times r$ et ses poids $w_{ijk}$
  correspondant.

  Écrire des expressions R pour calculer, sans boucle, les moyennes
  pondérées suivantes.
  \begin{enumerate}
  \item $X_{iw}$ en supposant une matrice de données $n \times p$.
  \item $X_{wj}$ en supposant une matrice de données $n \times p$.
  \item $X_{ww}$ en supposant une matrice de données $n \times p$.
  \item $X_{ijw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{iww}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{wjw}$ en supposant un tableau de données $n \times p
    \times r$.
  \item $X_{www}$ en supposant un tableau de données $n \times p
    \times r$.
  \end{enumerate}
  \begin{sol}
    Soit \code{Xij} et \code{wij} des matrices, et \code{Xijk}
    et \code{wijk} des tableaux à trois dimensions.
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 1, sum)/apply(wij, 1, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
rowSums(Xij * wij)/rowSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xij * wij, 2, sum)/apply(wij, 2, sum)
@
ou
<<echo=TRUE,eval=FALSE>>=
colSums(Xij * wij)/colSums(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xij * wij)/sum(wij)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, c(1, 2), sum) /
    apply(wijk, c(1, 2), sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 1, sum)/apply(wijk, 1, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
apply(Xijk * wijk, 2, sum)/apply(wijk, 2, sum)
@
\item
<<echo=TRUE,eval=FALSE>>=
sum(Xijk * wijk)/sum(wijk)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Générer les suites de nombres suivantes à l'aide d'expressions R.
  (Évidemment, il faut trouver un moyen de générer les suites sans
  simplement concaténer les différentes sous-suites.)
  \begin{enumerate}
  \item $0, 0, 1, 0, 1, 2, \dots, 0, 1, 2, 3, \dots, 10$.
  \item $10, 9, 8, \dots, 2, 1, 10, 9, 8, \dots 3, 2, \dots, 10, 9, 10$.
  \item $10, 9, 8, \dots, 2, 1, 9, 8, \dots, 2, 1, \dots, 2, 1, 1$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE>>=
unlist(lapply(0:10, seq, from = 0))
@
\item
<<echo=TRUE>>=
unlist(lapply(1:10, seq, from = 10))
@
\item
<<echo=TRUE>>=
unlist(lapply(10:1, seq, to = 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}


\begin{exercice}
  La fonction de densité de probabilité et la fonction de répartition
  de la loi de Pareto de paramètres $\alpha$ et $\lambda$ sont,
  respectivement,
  \begin{align*}
    f(x)
    &= \frac{\alpha \lambda^\alpha}{(x + \lambda)^{\alpha + 1}} \\
    \intertext{et}
    F(x)
    &= 1 - \left( \frac{\lambda}{x + \lambda} \right)^\alpha.
  \end{align*}
  La fonction suivante simule un échantillon aléatoire de taille $n$
  issu d'une distribution de Pareto de paramètres
  $\alpha = \text{\texttt{shape}}$ et
  $\lambda = \text{\texttt{scale}}$:
\begin{Schunk}
\begin{Verbatim}
rpareto <- function(n, shape, scale)
    scale * (runif(n)^(-1/shape) - 1)
\end{Verbatim}
\end{Schunk}
  \begin{enumerate}
  \item Écrire une expression R utilisant la fonction \code{rpareto}
    ci-dessus qui permet de simuler cinq échantillons aléatoires de
    tailles $100$, $150$, $200$, $250$ et $300$ d'une loi de Pareto
    avec $\alpha = 2$ et $\lambda = \nombre{5000}$. Les échantillons
    aléatoires devraient être stockés dans une liste.
  \item On vous fournit l'exemple suivant d'utilisation de la
    fonction \icode{paste}:
<<echo=TRUE>>=
paste("a", 1:5, sep = "")
@
    Nommer les éléments de la liste créée en a) \code{sample1},
    \code{sample2}, \dots, \code{sample5}.
  \item Calculer la moyenne de chacun des échantillons aléatoires
    obtenus en a). Retourner le résultat dans un vecteur.
  \item Évaluer la fonction de répartition de la loi de Pareto$(2,
    \nombre{5000})$ en chacune des valeurs de chacun des échantillons
    aléatoires obtenus en a). Retourner les valeurs de la fonction de
    répartition en ordre croissant.
  \item Ajouter $\nombre{1000}$ à toutes les valeurs de tous les
    échantillons simulés en a), ceci afin d'obtenir des observations
    d'une distribution de Pareto \emph{translatée}.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=FALSE>>=
library(actuar)
@
<<echo=TRUE>>=
x <- lapply(seq(100, 300, by = 50), rpareto,
            shape = 2, scale = 5000)
@
\item
<<echo=TRUE>>=
names(x) <- paste("sample", 1:5, sep = "")
@
\item
<<echo=TRUE>>=
sapply(x, mean)
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, function(x) sort(ppareto(x, 2, 5000)))
@
\item
<<echo=TRUE,eval=FALSE>>=
lapply(x, "+", 1000)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  La fonction \code{emrl} de l'\autoref{ex:bases:emrl} ne permettait
  de calculer l'espérance résiduelle empirique d'un vecteur \code{x}
  que pour seul un seuil \code{d}. Composer une version qui permet
  d'effectuer le calcul pour un vecteur de seuils \code{d}.
  \begin{sol}
    La solution la plus simple consiste à placer l'expression qui
    effectue le calcul pour un seuil à l'intérieur d'une fonction
    d'application \icode{sapply} qui, elle, se chargera de faire le
    calcul pour chacun des seuils. Il s'agit d'une belle occasion pour
    utiliser une \index{fonction!anonyme}fonction anonyme.
    \begin{Schunk}
\begin{Verbatim}
emrl <- function(x, d)
    sapply(d, function(y) mean(x[x > y])) - d
\end{Verbatim}
    \end{Schunk}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
