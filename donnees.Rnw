%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de données de R}
\label{chap:donnees}

\def\scriptfilename{\currfilebase.R}
\SweaveOpts{echo=FALSE}

<<echo=FALSE, results=hide>>=
source(".Sweaveprofile")   # configuration
source("Stangle.R")        # lancement de Stangle
@
<<script>>=
## Copyright (C) 2019 Vincent Goulet
##
## Ce fichier fait partie du projet
## «Programmer avec R»
## https://gitlab.com/vigou3/programmer-avec-r
##
## Cette création est mise à disposition sous licence
## Attribution-Partage dans les mêmes conditions 4.0
## International de Creative Commons.
## https://creativecommons.org/licenses/by-sa/4.0/
@

\begin{objectifs}
\item Distinguer les caractéristiques des structures de données
  suivantes de R: le vecteur simple, la matrice, le tableau, la liste,
  le \emph{data frame} et le facteur.
\item Créer et manipuler chacune des structures de données ci-dessus.
\item Extraire des données des divers types d'objet ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Importer dans R des données provenant de sources externes.
\item Exporter des données de R vers un format exploitable par
  d'autres outils.
\end{objectifs}

Une structure de données est une manière d'organiser les données dans
un ordinateur afin de pouvoir les traiter efficacement. L'étude des
structures de données va généralement de pair avec celle des
algorithmes puisqu'elles en influencent directement la performance. Le
bon choix de structure de données peut faire la différence entre un
programme performant et un autre trop lent ou inapte à traiter des
grandes quantités de données.

Le modèle de données de R repose sur des structures abstraites et
spécialisées que nous avons appelées des \emph{objets}. Jusqu'à
maintenant, nous n'avons étudié que le vecteur simple (\emph{atomic}).
Il existe d'autres structures de données en R, mais leur mise en œuvre
demeure tout à fait transparente pour les programmeuses et les
programmeurs. Cet ouvrage fera donc l'impasse sur les notions de
tableau (\emph{array}), de liste chainée (\emph{linked list}), d'arbre
(\emph{tree}) ou de table de hachage (\emph{hashtable}) dont traitent
habituellement les ouvrages d'algorithmique et de programmation.

Le vecteur, la matrice, le tableau et la liste sont les types d'objets
les plus fréquemment utilisés en programmation en R. Le facteur et le
\emph{data frame} sont davantage des structures de données
spécialisées pour l'analyse de données.


\section{Objets R}
\label{sec:donnees:objets}

Tout dans le langage R est un objet: les variables contenant des
données, les fonctions, les opérateurs, même le symbole représentant
le nom d'un objet est lui-même un objet. Les objets possèdent au
minimum un \emph{mode} et une \emph{longueur} et certains peuvent
être dotés d'un ou de plusieurs \emph{attributs}.

\subsection{Règles pour les noms d'objets}
\label{sec:donnees:objets:noms}

Les caractères permis pour les noms d'objets sont les lettres
minuscules a--z et majuscules A--Z, les chiffres 0--9, le point «.» et
le caractère de soulignement «\_». Selon l'environnement linguistique
de l'ordinateur, il peut être permis d'utiliser des lettres accentuées
dans les noms d'objet, mais je recommande fortement d'éviter cette
pratique qui nuit à la portabilité du code. Le nom d'un objet ne peut
débuter par un chiffre. Si le nom débute par un point, alors le second
caractère ne peut être un chiffre.

\warningbox{R est sensible à la casse, ce qui signifie que \code{foo},
  \code{Foo} et \code{FOO} sont trois objets distincts.}

Certains noms sont utilisés par le système R, aussi vaut-il mieux
éviter de les utiliser comme nom de variable ou de fonction. En
particulier, évitez:
\begin{quote}
  \code{c}, \code{q}, \code{t}, \code{C}, \code{D},
  \code{I}, \code{diff}, \code{length}, \code{mean},
  \code{pi}, \code{range}, \code{var}.
\end{quote}
De plus, certains mots sont réservés et il est interdit de les
utiliser comme nom d'objet. Les mots réservés pour le système sont:
\begin{quote}
  \code{break}, \code{else}, \code{for}, \code{function}, \code{if},
  \code{in}, \code{next}, \code{repeat}, \code{return}, \code{while}, \\
  \code{TRUE}, \code{FALSE}, \\
  \code{Inf}, \code{NA}, \code{NaN}, \code{NULL}, \\
  \verb|NA_integer_|, \verb|NA_real_|, \verb|NA_complex_|,
  \verb|NA_character_|, \\
  \code{...}, \code{..1}, \code{..2}, etc.
\end{quote}
Oui, `\code{...}' (\emph{point-point-point}) est véritablement un nom
d'objet dans R! Son usage est expliqué à la
\autoref{sec:fonctions:definition}.

Les variables \code{T}\index{T@\code{T}|see{\code{TRUE}}} et
\code{F}\index{F@\code{F}|see{\code{FALSE}}} prennent par défaut les
valeurs \icode{TRUE} et \icode{FALSE}, respectivement, mais peuvent
être réaffectées.
<<echo=TRUE>>=
T
F
@
\begin{Schunk}
\begin{Sinput}
> TRUE <- 3
\end{Sinput}
\begin{Soutput}
Error in TRUE <- 3 : membre gauche de l'assignation
(do_set) incorrect
\end{Soutput}
\end{Schunk}
<<echo=TRUE>>=
(T <- 3)
@
<<echo=FALSE>>=
rm(T)
@

\tipbox{Écrivez toujours les valeurs booléennes \code{TRUE} et
  \code{FALSE} au long pour éviter des bogues difficiles à détecter.}

\subsection{Modes et types de données}
\label{sec:donnees:objets:mode}

Le mode\Index{mode} prescrit ce qu'un objet peut contenir. À ce titre,
un objet ne peut avoir qu'un seul mode. Le \autoref{tab:donnees:modes}
contient la liste des principaux modes disponibles en R. À chacun de
ces modes correspond une fonction du même nom servant à créer un objet
de ce mode. Le mode d'un objet est obtenu avec la fonction
\Icode{mode}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
mode(v)
@

\begin{table}
  \centering
  \caption{Modes disponibles et contenus correspondants}
  \label{tab:donnees:modes}
  \begin{tabular}{ll}
    \toprule
    Mode              & Contenu de l'objet \\
    \midrule
    \icode{numeric}    & nombres réels \\
    \icode{complex}    & nombres complexes \\
    \icode{logical}    & valeurs booléennes \\
    \icode{character}  & chaines de caractères \\
    \icode{function}   & fonction \\
    \icode{list}       & liste \\
    \icode{expression} & expressions non évaluées \\
    \bottomrule
  \end{tabular}
\end{table}

Les objets de mode \code{numeric}, \code{complex},
\code{logical} et \code{character} sont des objets \emph{simples}
(\emph{atomic}) qui contiennent des données d'un seul type. En
revanche, les objets de mode \code{list} ou \code{expression} sont
des objets \emph{récursifs} qui peuvent contenir d'autres objets. Par
exemple, une liste peut contenir une ou plusieurs autres listes; nous
y reviendrons au \autoref{chap:donnees}.

\tipbox{La fonction \Icode{typeof} permet d'obtenir une description
  plus précise de la représentation interne d'un objet (c'est-à-dire
  au niveau de la mise en {\oe}uvre en C). Le mode et le type d'un
  objet sont souvent identiques.}

Plusieurs opérations --- notamment la création de vecteurs ou les
opérations arithmétiques et logiques --- entrainent ce que l'on
appelle la \emph{conversion forcée} (\emph{coercion}) d'un mode vers
un autre. Nous y revenons plus loin.


\subsection{Longueur}
\label{sec:donnees:objets:longueur}

La longueur\Index{longueur} d'un objet est égale au nombre d'éléments
qu'il contient. La longueur d'un objet est obtenue avec la fonction
\Icode{length}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
length(v)
@

\tipbox{Il est permis --- et parfois utile --- de créer un objet de
  longueur nulle, c'est-à-dire un objet qui existe, mais qui est
  vide.}

Au sens R du terme, la longueur d'une chaine de caractères est
toujours $1$. Un objet de mode \code{character} doit contenir
plusieurs chaines de caractères pour que sa longueur soit supérieure à
$1$. Il faut utiliser la fonction \Icode{nchar} pour obtenir le
nombre de caractères dans une chaine.
<<echo=TRUE>>=
v1 <- "actuariat"
length(v1)
nchar(v1)
@
<<echo=TRUE>>=
v2 <- c("a", "c", "t", "u", "a", "r", "i", "a", "t")
length(v2)
nchar(v2)
@

\subsection{Valeurs spéciales}
\label{sec:donnees:objets:NA_et_al}

Les objets valeur manquante (\code{NA}), infini (\code{Inf},
\code{-Inf}), valeur indéterminée (\code{NaN}) et néant (\code{NULL})
permettent de représenter de manière intuitive des quantités souvent
utilisées dans les applications statistiques et en analyse de données.
Pour pleinement tirer profit de ces objets, il faut connaitre leurs
caractéristiques spéciales.

L'objet \code{NA} sert à représenter une donnée manquante. Chose
quelque peu surprenante, c'est un objet de mode \icode{logical}. Cependant,
\code{NA} ne peut être considéré ni \code{TRUE}, ni \code{FALSE}.
<<echo=TRUE>>=
mode(NA)
length(NA)
NA == TRUE
NA == FALSE
@
Toute opération, y compris la comparaison, impliquant la valeur
\code{NA} a comme résultat \code{NA}. Par conséquent, la valeur
\code{NA} n'est égale à aucune autre, pas même elle-même! Pour tester
si une valeur est manquante, il faut avoir recours à la fonction
\Icode{is.na}.
<<echo=TRUE>>=
x <- NA
x == NA
is.na(NA)
@

Les objets \code{Inf}, \code{-Inf} et \code{NaN} permettent de
représenter les valeurs mathématiques spéciales prévues dans la norme
IEEE~754 régissant la représentation interne des nombres dans un
ordinateur \citep{IEEE:754}. De manière intuitive, l'objet \icode{Inf}
représente $+\infty$, \code{-Inf} représente $-\infty$ et \icode{NaN}
(\emph{Not a Number}) représente une forme indéterminée du type
$\frac{0}{0}$ ou $\infty - \infty$. Les fonctions
\Icode{is.infinite}, \Icode{is.finite} et \Icode{is.nan}
fournissent des manières robustes de tester ces valeurs.
<<echo=TRUE>>=
is.infinite(1/0)
is.finite(-1/0)
is.nan(0/0)
is.nan(Inf - Inf)
@

Enfin, l'objet spécial \icode{NULL} représente «rien», ou le vide. Son
mode est \code{NULL} et sa longueur est $0$. Il est toutefois
différent d'un objet vide: un objet de longueur $0$ est un contenant
vide, alors que \code{NULL} est «pas de contenant».
<<echo=TRUE>>=
mode(NULL)
length(NULL)
1 + NULL
@
Ajouter \code{NULL} à un objet n'ajoute rien. Par ailleurs, la seule
façon de tester si un objet est \code{NULL} est avec la fonction
\Icode{is.null}.
<<echo=TRUE>>=
c(3, NULL)
x <- NULL
x == NULL
is.null(NULL)
@


\subsection{Attributs}
\label{sec:donnees:objets:attributs}

Les attributs\Index{attribut} d'un objet sont des éléments
d'information additionnels attachés à cet objet. Le
\autoref{tab:attributs} fournit la liste des attributs les plus
fréquemment utilisés. À chacun des attributs du tableau correspond une
fonction du même nom servant à extraire l'attribut d'un objet.

\begin{table}
  \centering
  \caption{Attributs les plus usuels d'un objet}
  \label{tab:attributs}
  \begin{tabular}{ll}
    \toprule
    Attribut            & Utilisation \\
    \midrule
    \icode{class}    &
    affecte le comportement d'un objet \\
    \icode{dim}      &
    dimensions\index{dimension} des matrices et tableaux \\
    \icode{dimnames} &
    étiquettes\index{etiquette@étiquette} des dimensions des matrices
    et tableaux \\
    \icode{names}    &
    étiquettes des éléments d'un objet \\
    \bottomrule
  \end{tabular}
\end{table}

La fonction \Icode{attributes} permet d'extraire ou de modifier la
liste des attributs d'un objet, alors que la fonction \Icode{attr}
permet de travailler sur un seul attribut à la fois. Les programmeurs
peuvent ajouter à peu près n'importe quoi à la liste des attributs
d'un objet. Par exemple, nous pourrions vouloir attacher au résultat
d'un calcul la méthode de calcul utilisée.
<<echo=TRUE>>=
x <- 3
attr(x, "methode") <- "au pif"
attributes(x)
@

L'extraction d'un attribut qui n'existe pas retourne \icode{NULL},
alors qu'à l'inverse, affecter à un attribut la valeur \code{NULL}
efface cet attribut.
<<echo=TRUE>>=
attributes(x)
dim(x)
attr(x, "methode") <- NULL
attributes(x)
@

<<script, results=hide>>=
###
### OBJETS R               `\labelline{donnees:objets}`
###

## NOMS D'OBJETS

## Quelques exemples de noms valides et invalides.
foo <- 5                   # valide
foo.123 <- 5               # valide
foo_123 <- 5               # valide
.foo <- 5                  # valide
##-!- 123foo <- 5                # invalide; commence par un chiffre
##-!- .123foo <- 5               # invalide; point suivi d'un chiffre

## Liste des objets dans l'espace de travail. Les objets dont
## le nom commence par un point sont cachés, comme à la ligne
## de commande Unix.
ls()                       # l'objet '.foo' n'est pas affiché
ls(all.names = TRUE)       # objets cachés aussi affichés

## R est sensible à la casse
foo <- 1
##-!- Foo
##-!- FOO

## MODES ET TYPES DE DONNÉES

## Le mode d'un objet détermine ce qu'il peut contenir. Les
## vecteurs simples ("atomic") contiennent des données d'un
## seul type.
mode(c(1, 4.1, pi))        # nombres réels
mode(c(2, 1 + 5i))         # nombres complexes
mode(c(TRUE, FALSE, TRUE)) # valeurs booléennes
mode("foobar")             # chaînes de caractères

## La plupart des autres types d'objets sont récursifs. Voici
## quelques autres modes.
mode(seq)                  # une fonction
mode(list(5, "foo", TRUE)) # une liste
mode(expression(x <- 5))   # une expression non évaluée

## LONGUEUR

## La longueur d'un vecteur est égale au nombre d'éléments
## dans le vecteur.
(x <- 1:4)
length(x)

## Une chaîne de caractères ne compte que pour un seul
## élément.
(x <- "foobar")
length(x)

## Pour obtenir la longueur de la chaîne, il faut utiliser
## nchar().
nchar(x)

## Un objet peut néanmoins contenir plusieurs chaînes de
## caractères.
(x <- c("f", "o", "o", "b", "a", "r"))
length(x)

## La longueur peut être 0, auquel cas on a un objet vide,
## mais qui existe.
(x <- numeric(0))          # création du contenant
length(x)                  # l'objet 'x' existe...
x[1] <- 1                  # définition du permier élément

## Si un objet n'existe pas au préalable, il est impossible
## d'affecter directement la valeur d'un élément.
##-!- X[1] <- 1                  # impossible, 'X' n'existe pas

## ATTRIBUTS

## Les objets peuvent être dotés d'un ou plusieurs attributs.
data(cars)                 # jeu de données intégré
attributes(cars)           # liste de tous les attributs
attr(cars, "class")        # extraction d'un seul attribut

## L'attribut 'names' conserve les étiquettes des éléments
## d'un vecteur.
x <- 1:24                  # un vecteur
names(x) <- letters[1:24]  # attribution d'étiquettes
x                          # identification facilitée `\labelline{donnees:objets:fin}`
@

\gotorbox{Étudiez les lignes \reflines{donnees:objets}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}



\section{Matrice et tableau}
\label{sec:donnees:matrice}

R étant un langage spécialisé dans les calculs mathématiques, il
supporte tout naturellement et de manière intuitive --- à une
exception près, comme nous le verrons --- les matrices et les
tableaux. Dans la terminologie de R, une matrice est un tableau
rectangulaire de nombres à deux dimensions, alors qu'un tableau
(\emph{array}) est la généralisation à plus de deux
dimensions.\footnote{%
  Il est donc correct de dire qu'une matrice est un tableau à deux
  dimensions.} %

Nous avons établi d'entrée de jeu à la \autoref{sec:premiers:vecteurs}
qu'en R, tout est un vecteur. C'est aussi vrai pour les matrices et
tableaux, qui ne sont rien d'autre que des vecteurs dotés d'un
attribut \icode{dim} (\autoref{sec:premiers:objets:attributs}). Ces
objets sont donc stockés, et peuvent être manipulés, exactement comme
des vecteurs simples.

Une \Index{matrice}matrice est un vecteur avec un attribut \icode{dim}
de longueur $2$. La présence de cet attribut change implicitement la
classe de l'objet et, de ce fait, son mode d'affichage (sous forme de
tableau rectangulaire) et son interaction avec plusieurs opérateurs et
fonctions, notamment les opérateurs d'indiçage. La fonction de base
pour créer une matrice est \Icode{matrix}.
<<echo=TRUE>>=
matrix(1:6, nrow = 2, ncol = 3)
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
@

Tel que mentionné précédemment, la généralisation d'une matrice à plus
de deux dimensions est un \Index{tableau}tableau. Le nombre de
dimensions du tableau est toujours égal à la longueur de l'attribut
\icode{dim}. La fonction de base pour créer des tableaux est
\Icode{array}.
<<echo=TRUE>>=
array(1:24, dim = c(3, 4, 2))
@

Formellement, un tableau peut aussi compter une seule dimension. Un
tel tableau comporte un attribut \code{dim} de longueur $1$, alors
qu'un vecteur simple n'a pas d'attribut \code{dim}.

\importantbox{%
  Vous aurez remarqué que les matrices et tableaux sont remplis en
  faisant d'abord varier la première dimension, puis la seconde, etc.
  Pour les matrices, cela revient à les remplir par colonne. Cette
  convention, héritée du Fortran, n'est pas des plus intuitives, mais
  elle a ses avantages dans plusieurs applications.

  La fonction \icode{matrix} possède un argument \code{byrow} qui
  permet d'inverser l'ordre de remplissage, mais il vaut mieux
  vous habituer à la convention de R qu'essayer constamment de la
  contourner.}

L'ordre de remplissage inhabituel des tableaux rend leur manipulation
difficile si on ne les visualise pas correctement. Imaginons un
tableau de dimensions $3 \times 4 \times 5$: il faut voir le tableau
comme cinq matrices $3 \times 4$ (remplies par colonne!) les unes
\emph{derrière} les autres. Autrement dit, le tableau est un prisme
rectangulaire haut de $3$ unités, large de $4$ et profond de $5$. Si
l'on ajoute une quatrième dimension, cela revient à aligner des
prismes les uns derrière les autres, et ainsi de suite. La
\autoref{fig:donnees:tableaux} fournit une représentation schématique
des tableaux à trois et quatre dimensions.

\begin{figure}[t]
  \centering
  \hspace*{\fill}
  \begin{minipage}[b]{0.4\linewidth}
    \setlength{\unitlength}{5mm}
    \begin{picture}(9,7)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.7}}\put(0.51,3.51){\makebox(0,0){\footnotesize 1}}
      \put(0.5,3){\vector(0,-1){2.5}}
      \put(1.5,3.5){\circle{0.7}}\put(1.51,3.51){\makebox(0,0){\footnotesize 2}}
      \put(2,3.5){\vector(1,0){2.5}}
      \put(6.3,0.3){\circle{0.7}}\put(6.31,0.31){\makebox(0,0){\footnotesize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
    \end{picture}
    \subcaption{trois dimensions}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \setlength{\unitlength}{5mm}
    \setlength{\unitlength}{3.5mm}
    \begin{picture}(14,12)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(6,7){\line(0,1){2}}
      \put(6,9){\line(1,0){5}}
      \put(11,9){\line(0,-1){4}}
      \put(11,5){\line(-1,0){3}}
      \multiput(7,9)(1,1){3}{\line(0,1){1}}
      \multiput(7,10)(1,1){3}{\line(1,0){5}}
      \multiput(12,10)(1,1){3}{\line(0,-1){4}}
      \multiput(12,6)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.8}}\put(0.51,3.51){\makebox(0,0){\scriptsize 1}}
      \put(0.5,2.9){\vector(0,-1){2.4}}
      \put(1.5,3.5){\circle{0.8}}\put(1.51,3.51){\makebox(0,0){\scriptsize 2}}
      \put(2.1,3.5){\vector(1,0){2.4}}
      \put(6.3,0.3){\circle{0.8}}\put(6.31,0.31){\makebox(0,0){\scriptsize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
      \put(7.3,0.3){\circle{0.8}}\put(7.31,0.31){\makebox(0,0){\scriptsize 4}}
      \put(7.7,0.7){\vector(1,1){6.3}}
    \end{picture}
    \subcaption{quatre dimensions}
  \end{minipage}
  \caption[Représentation schématique de tableaux]{Représentation
    schématique de tableaux. Les chiffres encerclés identifient
    l'ordre de remplissage.}
  \label{fig:donnees:tableaux}
\end{figure}

L'indiçage\Index{indiçage!matrice} des matrices et tableaux se fait
avec les crochets \code{[~]}\indexcode{[}, comme pour les vecteurs
simples. D'ailleurs, l'ensemble des règles d'indiçage de la
\autoref{sec:premiers:vecteurs:indicage} s'appliquent à l'identique aux
matrices et tableaux, sinon qu'il faut maintenant préciser des
indices pour chaque dimension, séparés par des virgules.

Par exemple, on extrait un élément d'une matrice en précisant sa
position dans chaque dimension de celle-ci.

<<echo=TRUE>>=
(m <- matrix(c(40, 80, 45, 21, 55, 32), nrow = 2))
m[1, 2]
@

Il est équivalent --- quoique moins usité --- d'utiliser la position
de l'élément dans le vecteur sous-jacent à la matrice.
<<echo=TRUE>>=
m[3]
@

Les indices négatifs suppriment des dimensions et les vecteurs
booléens sélectionnent des dimensions, comme d'habitude.
<<echo=TRUE>>=
m[-1, -2]
m[c(FALSE, TRUE), c(FALSE, TRUE, TRUE)]
@

En vertu de la cinquième règle d'indiçage de la
\autoref{sec:premiers:vecteurs:indicage}, lorsqu'une dimension est
laissée vide dans les crochets, tous les éléments de cette dimension
sont extraits.
<<echo=TRUE>>=
m[2, ]
m[, 1]
m[-1, ]
m[, -2]
@

Les fonctions \Icode{rbind} et \Icode{cbind} permettent de fusionner
des matrices et des tableaux ayant au moins une dimension en commun.
La fonction \Icode{rbind} (\emph{row bind}) fusionne verticalement
(empile) deux matrices (ou plus) ayant le même nombre de colonnes.
<<echo=TRUE>>=
n <- matrix(1:9, nrow = 3)
rbind(m, n)
@

La fonction \Icode{cbind} (\emph{column bind}), quant à elle, fusionne
horizontalement (place côte à côte) deux matrices (ou plus) ayant le
même nombre de lignes.
<<echo=TRUE>>=
n <- matrix(1:4, nrow = 2)
cbind(m, n)
@

\videobox{\link{https://youtu.be/6P2cFe3DBfw}{Matrices et tableaux}}{%
  Visionnez la vidéo sur les
  \link{https://youtu.be/6P2cFe3DBfw}{matrices et tableaux} en
  complément de la présentation ci-dessus. Grâce à des représentations
  visuelles, elle facilite la compréhension des opérations de création
  et d'indiçage des matrices et des tableaux.}

<<script, results=hide>>=
###
### MATRICE ET TABLEAU  `\labelline{donnees:matrice}`
###

## Une matrice est un vecteur avec un attribut 'dim' de
## longueur 2 et une classe implicite "matrix". La manière
## naturelle de créer une matrice est avec la fonction
## 'matrix'.
(x <- matrix(1:12, nrow = 3, ncol = 4))
length(x)                  # longueur du vecteur sous-jacent
attributes(x)              # objet muni d'un attribut 'dim'
dim(x)                     # deux dimensions

## Les matrices sont remplies par colonne par défaut. L'option
## 'byrow' permet de les remplir par ligne, si nécessaire.
(x <- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE))

## Il n'est pas nécessaire de préciser les deux dimensions de
## la matrice s'il est possible d'en déduire une à partir de
## l'autre et de la longueur du vecteur de données. Les
## expressions ci-dessous sont toutes équivalentes.
matrix(1:12, nrow = 3, ncol = 4)
matrix(1:12, nrow = 3)
matrix(1:12, ncol = 4)

## À l'inverse, s'il n'y a pas assez de données pour remplir
## les dimensions précisées, les données seront recyclées,
## comme d'habitude.
matrix(1, nrow = 3, ncol = 4)
matrix(1:3, nrow = 3, ncol = 4)
matrix(1:4, nrow = 3, ncol = 4, byrow = TRUE)

## Dans l'indiçage des matrices et tableaux, l'indice de
## chaque dimension obéit aux règles usuelles d'indiçage des
## vecteurs.
x[1, 2]                    # élément en position (1, 2)
x[1, -2]                   # 1ère rangée sans 2e colonne
x[c(1, 3), ]               # 1ère et 3e rangées
x[-1, ]                    # supprimer 1ère rangée
x[, -2]                    # supprimer 2e colonne
x[x[, 1] > 2, ]            # lignes avec 1er élément > 2

## Indicer la matrice ou le vecteur sous-jacent est
## équivalent. Utiliser l'approche la plus simple selon le
## contexte.
x[1, 3]                    # l'élément en position (1, 3)...
x[7]                       # ... est le 7e élément du vecteur

## Détail additionnel sur l'indiçage des matrices et tableaux:
## il est aussi possible de les indicer avec une matrice.
## Chaque ligne de la matrice d'indiçage fournit alors la
## position d'un élément à sélectionner.
##
## Consulter au besoin la rubrique d'aide de la fonction '['
## (ou de 'Extract').
x[rbind(c(1, 1), c(2, 2))] # éléments x[1, 1] et x[2, 2]
x[cbind(1:3, 1:3)]         # éléments x[i, i] («diagonale»)
diag(x)                    # idem et plus explicite

## Quelques fonctions pour travailler avec les dimensions des
## matrices.
nrow(x)                    # nombre de lignes
dim(x)[1]                  # idem
ncol(x)                    # nombre de colonnes
dim(x)[2]                  # idem

## Les matrices et les tableaux étant des vecteurs, ils sont
## soumis aux règles usuelles de l'arithmétique vectorielle.
## Certains des opérations qui en résultent ne sont pas
## définies en algèbre linéaire usuelle.
(x <- matrix(1:4, 2))      # matrice 2 x 2
(y <- matrix(3:6, 2))      # autre matrice 2 x 2
5 * x                      # multiplication par une constante
x + y                      # addition matricielle
x * y                      # produit *élément par élément*
x %*% y                    # produit matriciel
x / y                      # division *élément par élément*
x * c(2, 3)                # produit par colonne

## La fonction 'rbind' ("row bind") permet d'«empiler» des
## matrices comptant le même nombre de colonnes.
##
## De manière similaire, la fonction 'cbind' ("column bind")
## permet de concaténer des matrices comptant le même nombre de
## lignes.
##
## Utilisées avec un seul argument, 'rbind' et 'cbind' créent
## des vecteurs ligne et colonne, respectivement. Ceux-ci sont
## rarement nécessaires.
x <- matrix(1:12, 3, 4)    # 'x' est une matrice 3 x 4
y <- matrix(1:8, 2, 4)     # 'y' est une matrice 2 x 4
z <- matrix(1:6, 3, 2)     # 'z' est une matrice 3 x 2

rbind(x, 99)               # ajout d'une ligne à 'x'
rbind(x, y)                # fusion verticale de 'x' et 'y'
cbind(x, 99)               # ajout d'une colonne à 'x'
cbind(x, z)                # concaténation de 'x' et 'z'
##-!- rbind(x, z)                # dimensions incompatibles
##-!- cbind(x, y)                # dimensions incompatibles
rbind(1:3)                 # vecteur ligne
cbind(1:3)                 # vecteur colonne

## Un tableau (array) est un vecteur avec plus de deux
## dimensions. Pour le reste, la manipulation des tableaux
## est en tous points identique à celle des matrices. Ne pas
## oublier: les tableaux sont remplis de la première dimension
## à la dernière!
(x <- array(1:60, 3:5))    # tableau 3 x 4 x 5
length(x)                  # longueur du vecteur sous-jacent
dim(x)                     # trois dimensions
x[1, 3, 2]                 # l'élément en position (1, 3, 2)...
x[19]                      # ... est le 19e élément du vecteur

## Le tableau ci-dessus est un prisme rectangulaire 3 unités
## de haut, 4 de large et 5 de profond. Indicer ce prisme avec
## un seul indice équivaut à en extraire des «tranches», alors
## qu'utiliser deux indices équivaut à en tirer des «carottes»
## (au sens géologique du terme). Il est laissé en exercice de
## généraliser à plus de dimensions...
x                          # les cinq matrices
x[, , 1]                   # tranche transversale
x[, 1, ]                   # tranche verticale
x[1, , ]                   # tranche horizontale
x[, 1, 1]                  # carotte de haut en bas
x[1, 1, ]                  # carotte de devant à derrière
x[1, , 1]                  # carotte de gauche à droite
x[1, 1, 1]                 # donnée unique  `\labelline{donnees:matrice:fin}`
@

\gotorbox{Étudiez les lignes \reflines{donnees:matrice}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}


\section{Fonctions internes utiles}
\label{sec:donnees:internes}

Cette section présente les fonctions internes couramment utilisées
pour les opérations sur les matrices. Les exemples utilisent la
matrice suivante.
<<echo=FALSE>>=
x <- matrix(c(2, 1, 4, 3), 2)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{rowMeans}
\item[\Icode{nrow}] \index{matrice!nombre de
    lignes}nombre de lignes
<<echo=TRUE>>=
nrow(x)
@
\item[\Icode{ncol}] nombre de \index{matrice!nombre de
    colonnes}colonnes
<<echo=TRUE>>=
ncol(x)
@
\item[\Icode{rowSums}] \index{matrice!sommes par ligne}sommes par
  ligne
<<echo=TRUE>>=
rowSums(x)
@
\item[\Icode{colSums}] \index{matrice!sommes par colonne}sommes par
  colonne
<<echo=TRUE>>=
colSums(x)
@
\item[\Icode{rowMeans}] \index{matrice!moyennes par ligne}moyennes par
  ligne
<<echo=TRUE>>=
rowMeans(x)
@
\item[\Icode{colMeans}] \index{matrice!moyennes par colonne}moyennes
  par colonne
<<echo=TRUE>>=
colMeans(x)
@
\item[\code{\%*\%}] \index{matrice!produit}produit matriciel
<<echo=TRUE>>=
x %*% x
@
\item[\Icode{t}] \index{matrice!transposée}transposée
<<echo=TRUE>>=
t(x)
@
\item[\Icode{det}] \index{matrice!déterminant}déterminant
<<echo=TRUE>>=
det(x)
@
\item[\Icode{solve}] avec un seul argument (une matrice carrée):
  \index{matrice!inverse}inverse
<<echo=TRUE>>=
solve(x)
@
  avec deux arguments (une matrice
  carrée et un vecteur): solution du système d'équations linéaires
  $\mat{A} \mat{x} = \mat{b}$
<<echo=TRUE>>=
solve(x, c(1, 2))
@
\item[\Icode{diag}] avec une matrice en argument:
  \index{matrice!diagonale}diagonale de la matrice
<<echo=TRUE>>=
diag(x)
@
  avec un vecteur en
  argument: matrice diagonale formée avec le vecteur
<<echo=TRUE>>=
diag(c(5, 1))
@
  avec un scalaire
  $p$ en argument: \index{matrice!identité}matrice identité
  $p \times p$
<<echo=TRUE>>=
diag(2)
@
\end{ttscript}

<<script, results=hide>>=
###
### FONCTIONS INTERNES UTILES  `\labelline{donnees:internes}`
###

## On se donne un vecteur de 16 éléments.
(A <- sample(1:10, 16, replace = TRUE))

## Opérations sur les matrices.
dim(A) <- c(4, 4)          # conversion en une matrice 4 x 4
b <- c(10, 5, 3, 1)        # vecteur quelconque
A                          # matrice 'A'
t(A)                       # transposée
solve(A)                   # inverse
solve(A, b)                # solution de Ax = b
A %*% solve(A, b)          # vérification de la réponse
diag(A)                    # extraction de la diagonale de 'A'
diag(b)                    # matrice diagonale formée avec 'b'
diag(4)                    # matrice identité 4 x 4
(A <- cbind(A, b))         # matrice 4 x 5
nrow(A)                    # nombre de lignes de 'A'
ncol(A)                    # nombre de colonnes de 'A'
rowSums(A)                 # sommes par ligne
colSums(A)                 # sommes par colonne  `\labelline{donnees:internes:fin}`
@

\gotorbox{Étudiez les lignes \reflines{donnees:internes}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}


\section{Liste}
\label{sec:donnees:liste}

La liste\index{liste} est la structure de données la plus générale et
polyvalente du langage R. Si les éléments d'un vecteur simple doivent
tous être du même mode, ceux de la liste peuvent être de n'importe
quel mode, y compris le mode \icode{list}. Par conséquent, il est
possible d'emboîter des listes, d'où le qualificatif de
\emph{récursif} pour ce type d'objet.

La liste est la structure de données par excellence pour réunir dans
un objet plusieurs types d'objets différents. La fonction de base pour
créer des listes est \Icode{list}.
<<echo=TRUE>>=
(x <- list(size = c(1, 5, 2), user = "Joe", new = TRUE))
@ %

(Dans l'exemple ci-dessus, le premier élément de la liste est un
vecteur de mode \code{numeric}, le second un vecteur de mode
\code{character} et le troisième, un vecteur de mode \code{logical}.)

\tipbox{Nommez les éléments des listes puisqu'il peut s'avérer
  difficile autrement de les identifier. De plus, comme nous le
  verrons ci-dessous, il est très simple d'extraire les éléments d'une
  liste par leur étiquette.}

L'indiçage\Index{indiçage!liste} des listes recèle quelques subtilités
auxquelles il faut porter une attention particulière. Tout d'abord, il
existe trois opérateurs d'indiçage: les crochets simples usuels
\code{[~]}, les crochets doubles \code{[[~]]} et le signe de dollar
\code{\$}.

\begin{itemize}
\item Les crochets simples\indexcode{[} fonctionnent avec la liste
  comme avec tout vecteur. Le résultat de l'indiçage avec \code{[~]}
  est une liste. Quand on y pense, c'est le seul résultat logique
  lorsque l'on indice une liste avec un vecteur. Par conséquent, le
  résultat de l'extraction d'un seul élément d'une liste avec les
  crochets simples est non pas l'objet en question, mais bien une
  liste d'un élément contenant l'objet. C'est rarement ce que l'on
  souhaite obtenir.
<<echo=TRUE>>=
x[1]
x[-2]
x[c(1, 3)]
@
%
\item Les crochets doubles\Indexcode{[[} permettent d'extraire un, et
  un seul, élément d'une liste à l'aide d'un entier positif ou d'une
  chaine de caractères. Le résultat est l'objet «sorti» de la liste.
<<echo=TRUE>>=
x[[1]]
x[["size"]]
@

  Petite fonctionnalité peu employée, mais élégante des crochets
  doubles: si l'indice est un vecteur d'entiers positifs, R utilisera
  les valeurs de celui-ci pour indicer récursivement la liste. Autrement
  dit, R sélectionnera la composante de la liste correspondant au
  premier élément du vecteur, puis l'élément de la composante
  correspondant au second élément du vecteur, et ainsi de suite.
<<echo=TRUE>>=
x[[c(1, 2)]]
@
%
\item Finalement, l'autre façon --- la meilleure, en fait --- de
  sélectionner un seul élément d'une liste est par son étiquette avec
  l'opérateur \Icode{\$}.
<<echo=TRUE>>=
x$size
@
\end{itemize}

Mentionnons en terminant la fonction \Icode{unlist} qui convertit une
liste en un vecteur simple. Elle est surtout utile pour concaténer les
éléments d'une liste lorsque ceux-ci sont des vecteurs simples,
idéalement de même mode, car il y aura autrement conversion forcée.
Attention: cette fonction est destructrice si la structure interne de
la liste est importante.
<<echo=TRUE>>=
unlist(x)
@

<<script, results=hide>>=
###
### LISTE  `\labelline{donnees:liste}`
###

## La liste est l'objet le plus général en R. C'est un objet
## récursif qui peut contenir des objets de n'importe quel
## mode (y compris la liste) et de n'importe quelle longueur.
(x <- list(joueur = c("V", "C", "C", "M", "A"),
           score = c(10, 12, 11, 8, 15),
           expert = c(FALSE, TRUE, FALSE, TRUE, TRUE),
           niveau = 2))
is.vector(x)               # liste est un vecteur...
is.recursive(x)            # ... récursif...
length(x)                  # ... de quatre éléments...
mode(x)                    # ... de mode "list"

## Comme tout autre vecteur, une liste peut être concaténée
## avec un autre vecteur avec la fonction 'c'.
y <- list(TRUE, 1:5)       # liste de deux éléments
c(x, y)                    # liste de six éléments

## Pour initialiser une liste d'une longueur donnée, on
## utilise la fonction 'vector'.
vector("list", 5)

## Les crochets simples [ ] permettent d'extraire un ou
## plusieurs éléments d'une liste. Le résultat est toujours
## une liste, même si l'on extrait un seul élément.
x[c(1, 2)]                 # deux premiers éléments
x[1]                       # premier élément: une liste

## Lorsque l'on veut extraire un, et un seul, élément d'une
## liste et obtenir l'objet lui-même (et non une liste
## contenant l'objet), il faut utiliser les crochets doubles
## [[ ]].
x[[1]]                     # comparer avec ci-dessus

## Jolie fonctionnalité: les crochets doubles permettent
## d'indicer récursivement la liste, c'est-à-dire d'extraire
## un objet de la liste, puis un élément de l'objet, et ainsi
## de suite.
x[[1]][2]                  # 2e élément du 1er élément
x[[c(1, 2)]]               # idem, par indiçage récursif

## Les éléments d'une liste étant généralement nommés (c'est
## une bonne habitude à prendre!), il est souvent plus simple
## et, surtout, plus sûr d'extraire les éléments d'une liste
## par leur étiquette avec l'opérateur $.
x$joueur                   # équivalent à x[[1]]
x$joueur[2]                # équivalent à x[[c(1, 2)]]
x[["expert"]]              # aussi valide, mais peu usité
x$level <- 1               # aussi pour l'affectation

## Une liste peut contenir n'importe quoi...
x[[5]] <- matrix(1, 2, 2)  # ... une matrice...
x[[6]] <- list(0:5, TRUE)  # ... une autre liste...
x[[7]] <- seq              # ... même le code d'une fonction!
x                          # eh ben!
x[[c(6, 1, 3)]]            # de quel élément s'agit-il?

## Il est possible de supprimer un élément d'une liste en lui
## affectant la valeur 'NULL'.
x[[7]] <- NULL; length(x)  # suppression du 7e élément

## Il est parfois utile de convertir une liste en un simple
## vecteur. Les éléments de la liste sont alors «déroulés», y
## compris la matrice en position 5 dans notre exemple (qui
## n'est rien d'autre qu'un vecteur, on s'en souviendra).
unlist(x)                    # remarquer la conversion
unlist(x, recursive = FALSE) # ne pas appliquer aux sous-listes
unlist(x, use.names = FALSE) # éliminer les étiquettes  `\labelline{donnees:liste:fin}`
@

\gotorbox{La liste est une structure de données très importante en R.
  Prenez le temps de bien étudier les lignes
  \reflines{donnees:liste} du fichier de script
  \code{\scriptfilename} reproduit à la
  \autoref{sec:donnees:exemples}.}


\section{Facteur}
\label{sec:donnees:facteur}

Il est très courant en analyse de données de travailler avec des
catégories comme la couleur («rouge», «vert», «bleu»), la taille
(«petit», «moyen», «grand») ou la position géographique (pays,
province, état). Bien sûr, un vecteur de mode \code{character} suffit
pour stocker ce genre de données. Cependant, R propose une structure
de données dédiée pour les données catégorielles qui permet
d'automatiser plusieurs traitements: le facteur.

Un facteur est un vecteur de données correspondant à des catégories. À
ce titre, il devrait normalement afficher un fort taux de redondance:
inutile de définir des catégories s'il y en a une différente pour
chaque donnée, n'est-ce pas?

Les fonctions de base pour créer et manipuler des facteurs sont
\Icode{factor} et \Icode{levels}. R représente les données sous forme
de chaine de caractères, mais il les stocke et les traite à l'interne
comme un vecteur d'entiers.
<<echo=TRUE>>=
(grandeurs <- factor(c("S", "S", "L", "XL",
                       "M", "M", "L", "L")))
levels(grandeurs)
@

En programmation, les facteurs sont assez peu utilisés en tant que
structure de données. Par contre, ils servent implicitement dans les
calculs par catégorie de données; nous y reviendrons au
\autoref{chap:application} quand nous traiterons des fonctions
d'application.


\section{\emph{Data frames}}
\label{sec:donnees:dataframes}

Le \Index{data frame|emph}\emph{data frame} est une structure de
données de R sur laquelle reposent plusieurs procédures statistiques
comme la régression linéaire. Un \emph{data frame} est un
hybride entre la matrice et la liste: c'est un tableau rectangulaire
de données, mais dont chaque colonne peut être d'un mode différent.
Pensons, par exemple, à un tableau avec des noms (mode
\code{character}) dans une colonne et des notes (mode \code{numeric})
dans une autre.

Plus formellement, un \emph{data frame} est une liste de classe
\code{data.frame} dont tous les éléments sont de la même longueur (ou
comptent le même nombre de lignes, si les éléments sont des matrices).
Chaque élément de la liste correspond à une colonne du \emph{data
  frame}. On crée un \emph{data frame} avec la fonction
\Icode{data.frame} ou, pour convertir un autre type d'objet en
\emph{data frame}, avec \Icode{as.data.frame}.
<<echo=TRUE>>=
(x <- data.frame(Nom = c("Pierre", "Jean", "Jacques"),
                 Age = c(42, 34, 19),
                 Fumeur = c(TRUE, TRUE, FALSE)))
@

Le \emph{data frame} peut être indicé à la fois comme une liste (pour
l'extraction des colonnes) et comme une matrice (pour l'extraction des
lignes ou des colonnes).
<<echo=TRUE>>=
x[1, ]
x[, 1]
x$Age
@

\tipbox{Vous remarquerez, ci-dessus, que les données de la colonne
  \code{Nom} sont considérées comme des facteurs. C'est une
  caractéristique de la fonction \code{data.frame} de convertir
  automatiquement les chaines de caractères en facteurs. L'option
  \code{stringAsFactors = FALSE} permet d'éviter la conversion
  automatique.}

Il est possible d'ajouter des lignes ou des colonnes à un \emph{data
  frame} avec les fonctions \icode{rbind} et \icode{cbind}.

<<script, results=hide>>=
###
### FACTEUR  `\labelline{donnees:facteur+df}`
###

## Les facteurs jouent un rôle important en analyse de
## données, surtout pour classer des données en diverses
## catégories. Les données d'un facteur devraient normalement
## afficher un fort taux de redondance.
##
## Reprenons l'exemple du chapitre.
(grandeurs <-
     factor(c("S", "S", "L", "XL", "M", "M", "L", "L")))
levels(grandeurs)          # catégories
as.integer(grandeurs)      # représentation interne

## Dans le présent exemple, nous pourrions souhaiter que R
## reconnaisse le fait que S < M < L < XL. C'est possible avec
## les facteurs *ordonnés*.
factor(c("S", "S", "L", "XL", "M", "M", "L", "L"),
       levels = c("S", "M", "L", "XL"),
       ordered = TRUE)

###
### DATA FRAME
###

## Un data frame est une liste dont les éléments sont tous de
## la même longueur. Il comporte un attribut 'dim', ce qui fait
## qu'il est représenté comme une matrice. Cependant, les
## colonnes peuvent être de modes différents.
##
## Nous créons ici le même data frame que dans l'exemple du
## chapitre, mais avec l'option 'stringsAsFactors = FALSE'
## pour éviter la conversion automatique de la colonne 'Nom'
## en facteur.
data.frame(Nom = c("Pierre", "Jean", "Jacques"),
           Age = c(42, 34, 19),
           Fumeur = c(TRUE, TRUE, FALSE),
           stringsAsFactors = FALSE)

## R est livré avec plusieurs jeux de données, la plupart sous
## forme de data frames.
##-!- data()                     # liste complète

## Nous allons illustrer certaines manipulations des data
## frames avec le jeu de données 'USArrests'.
USArrests                  # jeu de données

## Analyse succincte de l'objet.
mode(USArrests)            # un data frame est une liste...
length(USArrests)          # ... de quatre éléments...
class(USArrests)           # ... de classe 'data.frame'
dim(USArrests)             # dimensions implicites
names(USArrests)           # titres des colonnes
row.names(USArrests)       # titres des lignes
USArrests[, 1]             # première colonne
USArrests$Murder           # idem, plus simple
USArrests[1, ]             # première ligne

## La fonction 'subset' permet d'extraire des lignes et des
## colonnes d'un data frame de manière très intuitive.
##
## Par exemple, nous pouvons extraire ainsi le nombre
## d'assauts dans les états comptant un taux de meurtre
## supérieur à 10.
subset(USArrests, Murder > 10, select = Assault) #-*- `\labelline{donnees:facteur+df:fin}`
@

\gotorbox{Étudiez les lignes \reflines{donnees:facteur+df}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:donnees:exemples}.}


\section{Importation et exportation de données}
\label{sec:donnees:import-export}

«Est-ce que je peux transférer mes données de Excel à R?» Cette
question et ses multiples variantes est assurément l'une des plus
fréquemment posées par les utilisateurs de R. La réponse courte: oui,
c'est possible d'importer (c'est la terminologie correcte) des données
de source externe dans R. La réponse longue, cependant: oui, c'est
possible, mais c'est souvent compliqué. Il en va de même pour la
procédure inverse consistant à exporter des données de R pour usage
dans une autre application.

Ce qui rend souvent ardu l'échange de données entre différents
systèmes et logiciels, c'est le nombre de facteurs qui influencent
l'importation et l'exportation: le type de fichier (en format texte
brut ou en format binaire), l'encodage des caractères (ASCII pur,
UTF-8 ou autre), la disposition des données dans le fichier (notamment
les matrices et tableaux), le caractère utilisé pour séparer les
champs (espace, virgule ou autre), le format du fichier (Excel, SAS ou
autre), etc. Difficile, dans les circonstances, de proposer une
procédure universelle. C'est d'ailleurs pourquoi la documentation
officielle de R consacre le manuel \emph{R Data Import/Export}
\citep{R-data} à ce seul sujet.

Nous ne traitons, ici, que de l'importation et de l'exportation de
données sous forme de fichiers en format texte brut\footnote{%
  C'est-à-dire sans aucune mise en forme, comme les fichiers de
  script.}.

\tipbox{Il existe de multiples autres façons de travailler avec des
  données externes, notamment l'importation de fichiers de tableurs
  comme Excel ou, encore mieux, l'interaction directe avec une base de
  données depuis R. Consultez le manuel \emph{R Data Import/Export}
  pour en savoir plus.}


\subsection{Importation de vecteurs de données}
\label{sec:donnees:import-export:scan}

%% création des fichiers vecteur.data et matrice.data
<<echo=FALSE>>=
set.seed(1)
vec <- sample(4200:4300, 5)
mat <- matrix(sample(101:200, 15), 3, 5)
cat(file = "vecteur.data", "# Vecteur de données",
    vec, sep = "\n")
cat(file = "matrice.data", "# Données d'une matrice 3 x 5\n")
write(t(mat), file = "matrice.data", append = TRUE)
@

Le plus simple jeu de données à transférer d'un système à un autre est
un vecteur ou une matrice de données toutes du même mode. Pour ce
genre d'applications, un fichier en format texte brut convient
parfaitement. Les données y sont disposées les unes à la suite des
autres sur une ou plusieurs lignes. Le fichier peut aussi contenir
des commentaires, ceux-ci étant normalement délimités par un caractère
spécial tel que «\code{\#}», «\code{\%}» ou «\code{;}». La
\autoref{fig:donnees:scan} fournit deux exemples d'un tel fichier de
données.

\begin{figure}
  \lstset{frame=single,language={},numbers=none}
  \begin{minipage}{1.0\linewidth}
    \begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}
<<echo=FALSE, results=tex>>=
writeLines(readLines("vecteur.data"))
@
\end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}
<<echo=FALSE, results=tex>>=
writeLines(readLines("matrice.data"))
@
\end{lstlisting}
    \end{minipage} \\
    \mbox{}
  \end{minipage}
  \caption[Exemples de fichiers contenant des vecteurs de données en
  texte brut]{Exemples de fichiers contenant des vecteurs de données
    en texte brut. Gauche: fichier de données \code{vecteur.data}
    contenant un vecteur de données à raison d'une donnée par ligne.
    Droite: fichier \code{matrice.data} contenant les données d'une
    matrice. Dans les deux cas, le caractère \# indique que le reste
    du texte sur la ligne est un commentaire.}
  \label{fig:donnees:scan}
\end{figure}

La fonction \Icode{scan} permet d'importer de telles données dans R.
Elle lit l'intégralité des données du fichier dont le nom est donné en
premier argument, ligne par ligne, puis retourne un vecteur. Seul
l'ordre des données dans le fichier est pris en compte, leur
disposition n'a aucune importance. La fonction ignore tout texte qui
suit le caractère spécifié via l'argument \Icode{comment.char}.
<<echo=TRUE>>=
scan("vecteur.data", comment.char = "#")
@

Alternative à \code{comment.char}, l'argument \code{skip} permet de
sauter un certain nombre de lignes au début du fichier lors de
l'importation.
<<echo=TRUE>>=
scan("vecteur.data", skip = 1)
@

Pour recréer à l'identique dans R une matrice importée avec
\code{scan}, il faut s'assurer de la remplir par ligne.
<<echo=TRUE>>=
matrix(scan("matrice.data", comment.char = "#"),
       nrow = 3, byrow = TRUE)
@

La fonction \code{scan} compte de nombreux autres arguments; consulter
sa rubrique d'aide si la structure du fichier de données à importer
dans R ne correspond pas tout à fait aux cas traités ci-dessus.

\importantbox{Dès qu'il s'agit d'accéder à un fichier, R recherche
  celui-ci dans son \index{repertoire@répertoire de travail}répertoire
  de travail (\autoref{sec:presentation:workspace}). Si le fichier se
  trouve dans un autre répertoire, vous devez spécifier dans le nom le
  \index{chemin d'accès}chemin d'accès
  (\autoref{sec:informatique:fs:path}) vers le fichier.}

%% nettoyage
<<echo=FALSE>>=
unlink("vecteur.data")
unlink("matrice.data")
@

\subsection{Importation de tableaux de données}
\label{sec:donnees:import-export:read.table}

%% création des fichiers carburant.txt et carburant.csv
<<echo=FALSE>>=
carb <- matrix(c(16.9, 8, 350, 155, 4.360,
                 15.5, 8, 351, 142, 4.054,
                 19.2, 8, 267, 125, 3.605,
                 18.5, 8, 360, 150, 3.940,
                 30.0, 4, 98,  68,  2.155),
               nrow = 5, byrow = TRUE,
               dimnames = list(NULL, c("mpg", "nbcyl", "cylindree", "cv", "poids")))
write.table(carb, file = "carburant.txt", row.names = FALSE)
write.csv(carb, file = "carburant.csv", row.names = FALSE)
@

Les données des tableurs et des bases de données sont habituellement
organisées en tableau rectangulaire où chaque ligne représente un
«sujet», ou une «entrée», et chaque colonne représente une
caractéristique observée chez les sujets. On reconnait là la structure
du \emph{data frame} dans R.

Les tableurs, les bases de données et les différents logiciels
statistiques peuvent exporter leurs tableaux de données sous forme de
fichier texte dans lequel les champs sont séparés par un caractère
quelconque, souvent une espace. Le format le plus universel utilise
toutefois comme séparateur la virgule ou le point-virgule; c'est le
format de fichier CSV (\emph{comma-separated values}). La
\autoref{fig:donnees:read.table} présente le même jeu de données dans
deux formats différents.

\begin{figure}
  \lstset{frame=single,language={},numbers=none}
\begin{lstlisting}
<<echo=FALSE, results=tex>>=
writeLines(readLines("carburant.txt"))
@
\end{lstlisting}
\begin{lstlisting}
<<echo=FALSE, results=tex>>=
writeLines(readLines("carburant.csv"))
@
\end{lstlisting}
  \caption[Exemples de tableaux de données en texte brut]{Exemples de
    tableaux de données en texte brut. Haut: fichier
    \code{carburant.txt} contenant un jeu de données rectangulaire
    dont les champs sont séparés par des espaces. Bas: fichier
    \code{carburant.csv} contenant le même jeu de données avec une
    virgule comme séparateur. Dans les deux fichiers, la première
    ligne contient les titres des colonnes.}
  \label{fig:donnees:read.table}
\end{figure}

Les deux principales fonctions d'importation de tableaux de données
dans R sont \Icode{read.table} et \Icode{read.csv}. On choisira l'une
ou l'autre selon le format du fichier de données: \code{read.table} si
le séparateur des champs est une espace et \code{read.csv} si c'est
une virgule. Les nombreux arguments de ces fonctions permettent de
spécifier si les titres des lignes ou des colonnes apparaissent ou non
dans le fichier, le mode de chaque colonne, le séparateur décimal,
l'encodage, etc. La rubrique d'aide fournit les détails.
<<echo=TRUE>>=
read.table("carburant.txt", header = TRUE)
read.csv("carburant.csv", header = TRUE)
@

D'autres variantes de \icode{read.table} existent pour des formats de
fichiers courants. Elles diffèrent uniquement par le séparateur des
champs et le séparateur décimal; consulter le
\autoref{tab:donnees:read.table}.

\begin{table}
  \centering
  \caption{Caractéristiques des fonctions de la famille
    \code{read.table}}
  \label{tab:donnees:read.table}
  \begin{tabular}{lcc}
    \toprule
             & Séparateur & Séparateur \\
    Fonction & des champs & décimal \\
    \midrule
    \icode{read.table}  & espace     & \code{.} \\
    \icode{read.csv}    & \code{,}   & \code{.} \\
    \icode{read.csv2}   & \code{;}   & \code{,} \\
    \icode{read.delim}  & tabulation & \code{.} \\
    \icode{read.delim2} & tabulation & \code{,} \\
    \bottomrule
  \end{tabular}
\end{table}

%% nettoyage
<<echo=FALSE>>=
unlink("carburant.txt")
unlink("carburant.csv")
@

\tipbox{Les données à importer comportent parfois des accents --- dans
  des noms, par exemple. Si les accents n'apparaissent pas
  correctement dans R, c'est que le type d'encodage utilisé par R par
  défaut ne correspond pas à celui du fichier. Ce problème est
  particulièrement fréquent sous Windows. Pour y remédier, utilisez
  l'option \code{encoding} dans les appels des fonctions de la famille
  \icode{read.table}. Par exemple, si le fichier de données est encodé
  en UTF-8, ajoutez l'option \code{encoding = "UTF-8"}.}

\subsection{Exportation de données}
\label{sec:donnees:import-export:write}

R peut évidemment produire les types de fichiers mentionnés aux
sections \ref{sec:donnees:import-export:scan} et
\ref{sec:donnees:import-export:read.table} pour exporter ses données
vers d'autres systèmes. Les exemples de la présente section permettent
d'ailleurs de recréer les fichiers des figures \ref{fig:donnees:scan}
et \autoref{fig:donnees:read.table} (sans les commentaires).

L'exportation d'un vecteur simple dans un fichier en format texte brut
passe par la fonction \Icode{cat}. Les principaux arguments de la
fonction sont: le ou les objets à exporter; le nom du fichier; le
séparateur entre les éléments du vecteur dans le fichier. Le
séparateur par défaut est une espace, ce qui fait en sorte que les
éléments du vecteur se retrouvent sur une seule ligne dans le fichier
d'exportation. Pour placer les éléments sur des lignes différentes, il
faut utiliser un retour à la ligne, symbolisé par \verb="\n"=, comme
séparateur.
<<echo=FALSE>>=
x <- vec
@
<<echo=TRUE>>=
x
cat(x, file = "vecteur.data", sep = "\n")
@

La fonction \Icode{write} joue le même rôle que \icode{cat}, sauf que
les données sont disposées sous forme de tableau rectangulaire (de
cinq colonnes par défaut) dans le fichier d'exportation. Elle est donc
mieux appropriée pour exporter les matrices. Étant donné que R remplit
les matrices par colonne, il faut prendre soin de les transposer avant
de les exporter.
<<echo=FALSE>>=
x <- mat
@
<<echo=TRUE>>=
x
write(t(x), file = "matrice.data", ncolumns = 5)
@

%% nettoyage
<<echo=FALSE>>=
unlink("vecteur.data")
unlink("matrice.data")
@

Enfin, les pendants d'exportation des fonctions \icode{read.table},
\icode{read.csv} et \icode{read.csv2} sont \Icode{write.table},
\Icode{write.csv} et \icode{write.csv2}, dans l'ordre. Divers
arguments permettent de contrôler les informations à transférer du
\emph{data frame} au fichier d'exportation ainsi que le format de ce
dernier.
<<echo=FALSE>>=
x <- as.data.frame(carb)
@
<<echo=TRUE>>=
x
write.table(x, file = "carburant.txt", row.names = FALSE)
write.csv(x, file = "carburant.csv", row.names = FALSE)
@

%% nettoyage
<<echo=FALSE>>=
unlink("carburant.txt")
unlink("carburant.csv")
@

<<script, results=hide>>=
###
### IMPORTATION ET EXPORTATION DE DONNÉES  `\labelline{donnees:import-export}`
###

## Pour illustrer les procédures d'importation et
## d'exportation de données, nous allons d'abord exporter des
## données dans des fichiers pour ensuite les importer.
##
## Les fichiers seront créés dans le répertoire de travail de
## R. La commande
##
##   getwd()
##
## affiche le nom de ce répertoire.
##
## Après chaque création de fichier d'exportation, ci-dessous,
## ouvrir le fichier correspondant dans votre éditeur pour
## voir les résultats.
##
## Débutons par l'exportation d'un vecteur simple créé à
## partir d'un échantillon aléatoire des nombres de 1 à 100.
(x <- sample(1:100, 20))

## Exportation avec la fonction 'cat' sans commentaires dans
## le fichier, les données les unes à la suite des autres sur
## une seule ligne.
cat(x, file = "vecteur.data")

## Pour placer des commentaires au début du fichier, il suffit
## d'exporter deux objets: la chaine de caractères contenant
## le commentaire et le vecteur. Ici, nous insérons un retour
## à la ligne entre chaque élément.
cat("# commentaire", x, file = "vecteur.data", sep = "\n")

## La fonction 'write' permet de disposer les données
## exportées en colonnes (cinq par défaut), un peu comme une
## matrice. Exportons exactement le même vecteur de données en
## lui donnant l'apparence d'une matrice 5 x 4 (remplie par
## ligne).
write(x, file = "matrice.data", ncolumns = 4)

## Pour insérer des commentaires au début du fichier créé avec
## 'write', le plus simple consiste à procéder en deux étapes:
## on crée d'abord un fichier ne contenant que le commentaire
## (et le retour à la ligne) avec 'cat', puis on y ajoute les
## données avec 'write' en spécifiant 'append = TRUE' pour
## éviter d'écraser le contenu du fichier.
cat("# commentaire\n", file = "matrice.data")
write(x, file = "matrice.data", ncolumns = 4, append = TRUE)

## Pour illustrer l'exportation avec 'write.table',
## 'write.csv' et 'write.csv2', nous allons exporter le jeu de
## données 'USArrests' utilisé précédemment.
##
## Les titres des lignes sont importants dans ce jeu de
## données puisqu'ils contiennent les noms des États. Par
## défaut, les fonctions exportent tant les titres de lignes
## que les titres de colonnes.
##
## 'write.table' utilise l'espace comme séparateur des champs
## et le point comme séparateur décimal.
write.table(USArrests, "USArrests.txt")

## 'write.csv' utilise la virgule comme séparateur des champs
## et le point comme séparateur décimal.
write.csv(USArrests, "USArrests.csv")

## 'write.csv2' utilise le point-virgule comme séparateur des
## champs et la virgule comme séparateur décimal.
write.csv2(USArrests, "USArrests.csv2")

## Importons maintenant toutes ces données dans notre espace
## de travail.
##
## Les données de 'vecteur.data' (en passant, l'extension dans
## le nom de fichier n'a aucune importance) sont lues et
## importées avec la fonction 'scan'.
##
## Nous devons indiquer à la fonction que la ligne débutant
## par un # est un commentaire.
(x <- scan("vecteur.data", comment.char = "#"))

## La fonction 'scan' permet aussi de lire les données de
## 'matrice.data'. La disposition des données dans le fichier
## n'a aucune importance pour 'scan'. Il faut donc en recréer
## la structure dans R.
##
## Cette fois, nous sautons simplement la ligne du fichier
## pour omettre le commentaire.
(x <- matrix(scan("matrice.data", skip = 1),
             nrow = 5, ncol = 4, byrow = TRUE))

## L'importation des données de 'USArrests.txt',
## 'USArrests.csv' et 'USArrests.csv2' est très simple avec
## les fonctions 'read.table', 'read.csv' et 'read.csv2'.
##
## Prenez toutefois note: l'importation de données n'est pas
## toujours aussi simple. Il faut souvent avoir recours aux
## multiples autres arguments de 'read.table'
read.table("USArrests.txt")
read.csv("USArrests.csv")
read.csv2("USArrests.csv2")

## Nettoyage: la fonction 'unlink' supprime les fichiers
## spécifiés en argument, ici ceux créés précédemment dans le
## répertoire de travail.
unlink(c("vecteur.data", "matrice.data",
         "USArrests.txt", "USArrests.csv", "USArrests.csv2")) #-*- `\labelline{donnees:import-export:fin}`
@

\gotorbox{Des exemples interactifs vous permettrons de mieux
  comprendre le fonctionnement des fonctions d'importation et
  d'exportation. Étudiez les lignes \reflines{donnees:import-export}
  du fichier de script \code{\scriptfilename} reproduit à la
  \autoref{sec:donnees:exemples}.}


\section{Exemples}
\label{sec:donnees:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:donnees:exercices}

\Opensolutionfile{solutions}[solutions-donnees]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:donnees}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:donnees}}

\end{Filesave}

\begin{exercice}
  Évaluer les expressions suivantes comme le ferait l'interpréteur R.
  \begin{enumerate}
  \item \verb|mode(c(45.44, pi, TRUE))|
  \item \verb|mode(c(5, "5", "cinq"))|
  \item ...
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
     \item La valeur booléenne est convertie en nombre réel.
<<echo=FALSE>>=
mode(c(45.44, pi, TRUE))
@
     \item Le nombre réel est converti en chaine de caractères.
<<echo=FALSE>>=
mode(c(5, "5", "cinq"))
@
     \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \index{indiçage!matrice}
  Soit \code{x} une matrice $7 \times 10$ obtenue aléatoirement avec
<<echo=TRUE,eval=FALSE>>=
x <- matrix(sample(1:100, 70), 7, 10)
@
  Écrire des expressions R permettant d'obtenir les éléments de la
  matrice demandés ci-dessous.
  \begin{enumerate}
  \item L'élément $(4, 3)$.
  \item Le contenu de la sixième ligne.
  \item Les première et quatrième colonnes (simultanément).
  \item Les lignes dont le premier élément est supérieur à $50$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[4, 3]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[6, ]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[, c(1, 4)]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x[, 1] > 50, ]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Trouver une formule pour calculer la position, dans le vecteur
    sous-jacent, de l'élément $(i, j)$ d'une matrice $I \times J$
    remplie par colonne.
  \item Répéter la partie a) pour l'élément $(i, j, k)$ d'un tableau
    $I \times J \times K$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item \verb|(j - 1)*I + i|
    \item \verb|((k - 1)*J + j - 1)*I + i|
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit \code{m} une matrice $10 \times 7$ quelconque. Écrire des
  expressions R permettant d'effectuer les tâches demandées
  ci-dessous.
  \begin{enumerate}
  \item Calculer la somme des éléments de chacunes des lignes de la
    matrice.
  \item Calculer la moyenne des éléments de chacunes des colonnes de
    la matrice.
  \item Calculer la valeur maximale de la sous-matrice formée par les
    trois premières lignes et les trois premières colonnes de la
    matrice.
  \item Extraire toutes les lignes de la matrice dont la moyenne des
    éléments est supérieure à $7$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE, eval=FALSE>>=
rowSums(m)
@
\item
<<echo=TRUE, eval=FALSE>>=
colMeans(m)
@
\item
<<echo=TRUE, eval=FALSE>>=
max(m[1:3, 1:3])
@
\item
<<echo=TRUE, eval=FALSE>>=
m[rowMeans(m) > 7, ]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Écrire une fonction \code{sort.matrix} servant à ordonner les lignes
  d'une matrice selon les valeurs des éléments de la première colonne.

  Par défaut, la fonction trie en ordre croissant. Elle peut également
  trier en ordre décroissant si son argument \code{decreasing} est
  \code{TRUE}.

<<echo=FALSE>>=
sort.matrix <- function(m, decreasing = FALSE)
    m[order(m[, 1], decreasing = decreasing), ]
set.seed(4)
m <- matrix(sample(1:10, 12, rep = TRUE), 3, 4)
@
<<echo=TRUE>>=
m
sort.matrix(m)
sort.matrix(m, decreasing = TRUE)
@

  \begin{sol}
    La solution repose sur l'utilisation judicieuse de la fonction
    \code{order}.
<<echo=TRUE>>=
sort.matrix
@
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Écrire une expression R pour créer la liste suivante:
<<echo=FALSE>>=
x <- list(1:5, data=matrix(1:6, 2, 3), numeric(3), test=logical(4))
@
<<echo=TRUE>>=
x
@ %
  \item \index{etiquette@étiquette} Extraire les étiquettes de la
    liste.
  \item \index{mode} \index{longueur} Trouver le mode et la longueur
    du quatrième élément de la liste.
  \item \index{dimension} Extraire les dimensions du second élément de
    la liste.
  \item \index{indiçage!liste} Extraire les deuxième et troisième
    éléments du second élément de la liste.
  \item Remplacer le troisième élément de la liste par le vecteur
    \verb|3:8|.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item Il y a plusieurs façons de créer les troisième et quatrième
      éléments de la liste. Le plus simple consiste à utiliser
      \code{numeric()} et \code{logical()}:
<<echo=TRUE,eval=FALSE>>=
x <- list(1:5, data = matrix(1:6, 2, 3), numeric(3),
          test = logical(4))
@
    \item
<<echo=TRUE,eval=FALSE>>=
names(x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
mode(x$test)
length(x$test)
@
    \item
<<echo=TRUE,eval=FALSE>>=
dim(x$data)
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[2]][c(2, 3)]
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[3]] <- 3:8
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Effectuer une mise en œuvre de l'algorithme \emph{Bucketsort} de
  \citet[chapitre~6]{Stephens:algorithms:2013} permettant de trier des
  entiers entre $1$ et $x_{\max}$. La fonction prend en argument le
  vecteur des données à trier, la valeur de $x_{\max}$ et le nombre de
  compartiments. Utiliser la fonction \icode{sort} pour trier les
  compartiments.

  \begin{sol}
    La principale difficulté réside dans le fait que certains
    compartiments peuvent demeurer vides (\code{NULL}). Or,
    \icode{sort} ne peut prendre \code{NULL} en argument. Il faut donc
    faire un test avant de trier les données.
<<echo=TRUE, eval=FALSE>>=
bucketsort <- function(x, max, nbuckets)
{
    ## création des compartiments
    buck <- vector("list", nbuckets)
    span <- max/nbuckets

    ## répartition des données dans les compartiments
    for (i in seq_along(x))
    {
        j <- ceiling(x[i]/span)
        buck[[j]] <- c(buck[[j]], x[i])
    }

    ## tri des données dans chaque compartiment; on
    ## effectue le tri seulement s'il y a des données
    ## dans le compartiment
    for (i in seq_len(nbuckets))
        if (!is.null(buck[[i]]))
            buck[[i]] <- sort(buck[[i]])

    ## retourner le vecteur trié
    unlist(buck)
}
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Importer dans R les données \code{boston} du dépôt de jeux de
  données de \link{http://lib.stat.cmu.edu/datasets}{StatLib}.
  Remarquer que les données commencent à la ligne $23$ du fichier. De
  plus, chaque entrée du fichier compte $14$ variables, mais leurs
  valeurs sont chaque fois réparties sur deux lignes à raison de $11$
  variables sur une ligne et $3$ sur l'autre.
  \begin{sol}
    Avec les données réparties sur deux lignes, le plus simple demeure
    d'importer les données avec \code{scan} et les replacer dans le
    bon format avec \code{matrix}. Remarquer comment l'on peut
    importer directement depuis Internet en spécifiant une adresse URL
    comme nom de fichier.
<<echo=TRUE, eval=FALSE>>=
x <- matrix(
    scan("http://lib.stat.cmu.edu/datasets/boston",
         skip = 22),
    ncol = 14, byrow = TRUE)
@
<<echo=FALSE, eval=TRUE>>=
x <- matrix(scan("data/boston", skip = 22),
            ncol = 14, byrow = TRUE)
@
    Juste pour le plaisir, amusons-nous à extraire les
    noms des variables (colonnes) dans l'entête du fichier. Ils
    forment le premier champ de mode caractère des lignes 8 à 21,
    inclusivement.
<<echo=FALSE, results=hide>>=
## copier (temporairement) le fichier de données du sous-dossier 'data' vers le  dossier de travail courant pour le bloc de code suivant
file.copy("data/boston", ".")
@
<<echo=TRUE>>=
(xnames <- scan("boston", skip = 7, nlines = 14,
                what = "character", flush = TRUE))
@
<<echo=FALSE, results=hide>>=
## supprimer le fichier de données
file.remove("boston")
@
    Nous pouvons ensuite ajouter les noms de colonne à notre matrice
    de données, puis convertir en \emph{data frame} pour un traitement
    statistique ultérieur. La fonction \icode{head} permet d'afficher
    les six premières lignes de l'objet.
<<echo=TRUE>>=
colnames(x) <- xnames
x <- as.data.frame(x)
head(x)
@
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
