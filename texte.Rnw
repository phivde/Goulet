%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Analyse et contrôle de texte}
\label{chap:texte}

<<echo=FALSE>>=
options(width=50)
@

\begin{objectifs}
\item Utiliser les expressions régulières pour décrire ou identifier
  une chaine de caractères.
\item Effectuer l'analyse et le contrôle de texte à l'aide des outils
  informatiques standards \code{grep}, \code{sed} et \code{awk}.
\item Effectuer des opérations de recherche et de remplacement de
  texte à l'aide d'expressions régulières avec les divers outils de R.
\end{objectifs}

Vous êtes-vous déjà demandé comment s'effectue la validation de
certains champs comme le code postal ou l'adresse de courrier
électronique dans les formulaires électroniques? Sûrement pas en
vérifiant si l'entrée figure dans la liste des quelques 17,5 millions
de codes postaux possibles au Canada ou, pire, parmi les milliards
d'adresse de courriel que les
\link{https://tools.ietf.org/html/rfc3696}{règles internationales}
permettent de concevoir! Non, ce qu'il faut, c'est un «langage» qui
permet de décrire \emph{comment} une chaine de caractères peut être
composée, sans toutefois en fixer la composition exacte. Un tel
langage existe: ce sont les \emph{expressions régulières} ou
expressions relationnelles.

Une expression régulière (\emph{regular expression}, ou regex ou
regexp) est une chaine de caractères qui décrit, selon une syntaxe
précise, un ensemble de chaines de caractères possibles
\citep{Wikipedia:Expression_reguliere}.

Par exemple, les plaques d'immatriculation récentes distribuées par la
Société d'assurance automobile du Québec (SAAQ) sont composées ainsi:
une lettre, deux chiffres, une espace, trois lettres. Les lettres
\textsf{O}, \textsf{I} et \textsf{U} ne sont pas utilisées à cause de
leur similitude avec, respectivement, le chiffre {\fullcaps 0}, le
chiffre {\fullcaps 1} et la lettre \textsf{V}. L'expression régulière
suivante permet de décrire l'ensemble des numéros de plaques possibles
(y compris les combinaisons de lettres exclues comme \code{LSD} ou
\code{SEX}):
\begin{Schunk}
\begin{Verbatim}
[A-HJ-NP-TV-Z][0-9]{2} [A-HJ-NP-TV-Z]{3}
\end{Verbatim}
\end{Schunk}

Voici quelques autres utilisations possibles des expressions
régulières.
\begin{itemize}
\item Rechercher du texte pouvant contenir des variations ou des
  fautes d'orthographe comme, par exemple, «je transfert» plutôt que
  «je transfère», ou encore les multiples variations autour du verbe
  «appeler»: appel, appelle, appellent, appeler, appelez, etc.
\item Extraire les coordonnées géographiques d'un lieu (latitude et
  longitude) de l'URL d'une carte Google Maps. Par exemple, l'%
  \link{https://www.google.ca/maps/place/Universite+Laval/@46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d46.7817463!4d-71.2747424}{URL
    correspondant à la recherche «Université Laval»} est
  \begin{Schunk}
\begin{Verbatim}
https://www.google.ca/maps/place/Universite+Laval/
  @46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!
  1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d
  46.7817463!4d-71.2747424
\end{Verbatim}
  \end{Schunk}
  dont on décode que le lieu se trouve à une latitude de
  $\nombre{46,7817463}$ et à une longitude de $\nombre{-71.2769311}$
  en degrés décimaux.
\item Mettre en italique tous les mots d'un texte qui se trouvent
  entre guillemets (mais pas les guillemets eux-mêmes), et ce, quels
  que soient les mots.
\item Déterminer par programmation si un dépôt Git contient une
  branche autre que \code{master} en examinant le résultat de la
  commande \code{git branch}.
\end{itemize}

Un jour ou l'autre, vous aurez à traiter des chaines de caractères en
programmation ou en analyse de données. Ce jour-là, connaitre les
expressions régulières vous sauvera énormément de temps.

Pour les exemples de ce chapitre, nous utiliserons le texte de la
chanson «La journée qui s'en vient est flambant neuve» de l'album
\emph{Astronomie} (2012) du groupe québécois Avec pas d'casque. Le
texte est fourni avec le présent document dans le fichier
\code{chanson.txt}. Pour référence, il est également reproduit à la
\autoref{fig:texte:chanson}.

\begin{figure}
  \centering
  \lstinputlisting[frame=single,numbers=none]{chanson.txt}
  \caption{Texte de la chanson «La journée qui s'en vient est flambant
    neuve» de Avec pas d'casque}
  \label{fig:texte:chanson}
\end{figure}

\begin{figure}[t]
  \centering
  \begin{minipage}{0.9\linewidth}
    \setkeys{Gin}{width=\textwidth}
    \includegraphics{images/regular_expressions} \\
    \footnotesize\sffamily%
    Tiré de \href{https://xkcd.com/208/}{XKCD.com}
  \end{minipage}
\end{figure}


\section{Outils d'analyse et de contrôle du texte}
\label{sec:texte:outils}

L'expression régulière n'est qu'un langage de description d'une chaine
de texte. Pour exploiter ce langage, des outils sont nécessaires. Aux
fins de cet ouvrage, j'ai choisi de concentrer notre étude sur les
utilitaires Unix standards en ligne de commande \icode{grep},
\icode{sed} et \icode{awk}. Ils font partie intégrante des systèmes
d'exploitation macOS et Linux et, sous Windows, ils sont livrés avec
les interpréteurs de commande \index{MSYS}MSYS de
\index{MSYS2}\link{https://www.msys2.org}{MSYS2} et
\index{Git~Bash}Git~Bash de \link{https://git-scm.com/downloads}{Git
  for Windows}.

Il va sans dire que les utilitaires \icode{grep}, \icode{sed} et
\icode{awk} s'utilisent depuis une ligne de commande \index{Unix}Unix:
dans le \index{Terminal}Terminal sous macOS, ou dans
\index{Git~Bash}Git~Bash ou MSYS sous Windows. Si vous n'êtes pas
familier avec la ligne de commande,
\citet{Goulet:laboratoire-cli-git:2019} offre une rapide introduction
suffisante pour suivre la matière de ce chapitre. Nous reviendrons à R
à la \autoref{sec:texte:internes} lorsque nous étudierons les
fonctions internes de R aux fonctionnalités équivalentes à \code{grep}
et \code{sed}.

Comme la plupart des utilitaires Unix, \icode{grep}, \icode{sed} et
\icode{awk} prennent en entrée un flux de texte ou un ou plusieurs
fichiers en format texte brut et ils opèrent sur cette entrée ligne
par ligne. Le résultat du traitement est affiché dans le terminal,
envoyé à un autre programme ou redirigé vers un fichier. Les outils
diffèrent quant au type de traitement qu'ils peuvent effectuer.
\begin{description}
\item[\code{grep}] sélectionne les lignes en entrée correspondant à
  une expression régulière;
\item[\code{sed}] sert surtout pour rechercher et remplacer du texte;
\item[\code{awk}] permet de traiter aisément du texte séparé en
  champs, ainsi que du texte réparti sur plusieurs lignes.
\end{description}

Puisque nous utiliserons les utilitaires \icode{grep} et \icode{sed} à
profusion dans la présentation sur les expressions régulières à la
\autoref{sec:texte:regex}, prenons un moment pour apprendre comment
les utiliser. L'utilitaire \icode{awk}, quant à lui, fera l'objet
de la \autoref{sec:texte:awk}.

\notebox{Lorsqu'il est question d'expressions régulières dans la
  littérature informatique, le langage de programmation
  \index{Perl}Perl est habituellement mentionné. En effet, Perl a été
  créé par Larry Wall en 1987 pour traiter facilement du texte. Le
  langage prend en charge les expressions régulières dans sa syntaxe
  même et il comporte plusieurs extensions aux expressions prises en
  charge par \icode{grep} et \icode{sed}. Cet ouvrage ne traite pas de
  \icode{Perl}.}

\subsection{Extraction de lignes avec \code{grep}}
\label{sec:texte:outils:grep}

L'utilitaire \Icode{grep}\footnote{%
  Le nom de l'utilitaire provient de la commande \code{:g/re/p} de
  l'antédiluvien éditeur de texte \icode{ed} qui permet de rechercher
  globalement (\code{g}) une expression régulière (\emph{regular
    expression}, \code{re}) et d'afficher les lignes qui correspondent
  (\emph{print}, \code{p}).} %
prend en argument une expression régulière, lit l'entrée standard ou
une liste de fichiers ligne par ligne, puis retourne sur la sortie
standard les lignes qui contiennent des correspondances avec
l'expression régulière. C'est très utile pour savoir si un fichier
contient --- ou quels fichiers contiennent --- un mot ou une
expression, assez pour que le nom de l'utilitaire soit devenu un verbe
dans le %
\link{http://www.catb.org/jargon/html/G/grep.html}{jargon
  informatique} %
en anglais (\emph{to grep}).

Les trois exemples ci-dessous permettent, dans l'ordre, d'extraire du
fichier \code{chanson.txt}: le vers de la chanson qui contient le mot
«temps»; les vers qui débutent par «M»; le vers qui contient le mot
«chat» (aucun\footnote{%
  Sachez que la \link{https://youtu.be/eR_44AzYIZs}{vidéo} de la
  chanson est, elle, emplie de chatons très mignons.}).
\begin{Schunk}
\begin{Verbatim}
$ grep 'temps' chanson.txt
Le temps qui s'appelle hier
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ grep '^M' chanson.txt
Mes bras désolés
Même si le mouvement
Meurt mieux qu'il ne se charge
Même si la fatigue
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ grep 'chat' chanson.txt
$
\end{Verbatim}
\end{Schunk}

En combinant \icode{grep} avec l'utilitaire \Icode{wc} (\emph{word
  count}), nous pouvons obtenir le nombre total de lignes, de mots et
de caractères des vers dans lesquels le mot «flambant» apparait dans
la chanson.
\begin{Schunk}
\begin{Verbatim}
$ grep 'flambant' chanson.txt | wc
       6      48     276
\end{Verbatim}
\end{Schunk}

L'option \code{-c} de \icode{grep} donne encore plus rapidement accès
au nombre de lignes qui correspondent à l'expression régulière.
\begin{Schunk}
\begin{Verbatim}
$ grep -c 'flambant' chanson.txt
6
\end{Verbatim}
\end{Schunk}

L'option \code{-v} de \icode{grep} permet d'inverser les résultats ou,
autrement dit, d'extraire les lignes qui ne contiennent aucune
correspondance avec l'expression régulière. Par exemple, la commande
ci-dessous permet d'extraire les vers qui ne contiennent pas la
lettre «e» (ce qui inclut les lignes blanches entre les strophes).
\begin{Schunk}
\begin{Verbatim}
$ grep -v 'e' chanson.txt



Nous avons l'outil


\end{Verbatim}
\end{Schunk}

\subsection{Recherche et remplacement avec \code{sed}}
\label{sec:texte:outils:sed}

L'utilitaire \Icode{sed}\footnote{Pour \emph{stream editor}, ou
  éditeur de flux de texte. Comme \code{grep}, \code{sed} tire son
  origine de l'éditeur \icode{ed}.} %
est en quelque sorte un éditeur de texte qui opère sur un texte une
ligne à la fois et de manière non-interactive. L'éventail des
traitements que \icode{sed} peut appliquer à un texte est très vaste,
mais la syntaxe des commandes qu'il faut entrer pour y arriver est
particulièrement ésotérique\footnote{%
  Jugez-en: la commande pour supprimer l'une de deux lignes blanches
  consécutives dans un texte est \code{N;/\string^\bs n\$/D;P;D;}.}. %
Nous nous attarderons donc à une seule commande de \icode{sed}, celle
qui permet de rechercher et de remplacer à l'intérieur d'un texte. La
syntaxe de cette commande est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
s/\meta{motif}/\meta{remplacement}/\meta{modificateur}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \code{s} est le nom de la commande \icode{sed} qui sert à
  rechercher et remplacer.
\item \meta{motif} est une expression régulière qui définit le texte à
  rechercher.
\item \meta{remplacement} est le texte qui sert à remplacer le texte
  qui correspond à \meta{motif}.
\item \meta{modificateur} est un symbole qui permet de modifier le
  comportement de la commande; nous utiliserons uniquement le
  modificateur \code{g} (pour «global») qui indique de remplacer
  toutes les correspondances de \meta{motif} sur une ligne, et non
  seulement la première.
\item «\code{/}» est un symbole qui sert à délimiter les différentes
  parties de la commande; n'importe quel symbole (qui ne se trouve pas
  autrement dans la commande) fait l'affaire, mais «\code{/}» est le
  symbole le plus couramment utilisé.
\end{itemize}

La commande de remplacement est fournie en argument à \icode{sed}.
L'utilitaire lit ensuite l'entrée standard ou une liste de fichiers
ligne par ligne, puis retourne sur la sortie standard le texte modifié
(sans modifier le fichier d'origine).

Les trois exemples ci-dessous permettent de faire les changements
suivants dans le texte du fichier \code{chanson.txt}, dans l'ordre:
remplacer «Oh» par «Ah»; remplacer «mm» par «MM»; remplacer toutes les
occurrences de «promets» sur une ligne par «jure». (J'ai abrégé les
sorties des commandes pour économiser de l'espace.)
\begin{Schunk}
\begin{Verbatim}
$ sed 's/Oh/Ah/' chanson.txt
Ah comme il est lourd
Le temps qui s'appelle hier
...
\end{Verbatim}
\end{Schunk}

\begin{Schunk}
\begin{Verbatim}
$ sed 's/mm/MM/' chanson.txt
Oh coMMe il est lourd
Le temps qui s'appelle hier
...
Mes bras désolés
Rampent coMMe des chiens
...
Gave-moi de ton amour
Pour shiMMer l'Univers
...
\end{Verbatim}
\end{Schunk}

\begin{Schunk}
\begin{Verbatim}
$ sed 's/promets/jure/g' chanson.txt
...
Dans ma tête il est pour toi
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Rampent comme des chiens
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Voudrait que tu deviennes
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Il manque la manière
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Pour shimmer l'Univers
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Nos plus beaux accidents
Je jure, je jure que
la journée qui s'en vient est flambant neuve
\end{Verbatim}
\end{Schunk}

Il n'est pas tout à fait exact de dire que \icode{sed} traite une
seule ligne à la fois. En effet, il est également possible d'appliquer
des commandes sur un intervalle de lignes par le biais d'une mémoire
tampon (\emph{hold space}). Nous n'aurons pas recours à la mémoire
tampon de \icode{sed} dans le présent ouvrage.

\warningbox{Il existe plusieurs versions différentes de \icode{grep},
  \icode{sed} et \icode{awk}, parfois avec des différences
  importantes, surtout dans le cas de \code{sed}. Les versions sous
  Linux, \index{MSYS2}MSYS2 et \index{Git~Bash}Git~Bash sont
  généralement celles du \link{https://www.gnu.org/}{projet GNU}. Dans
  macOS, elles proviennent de
  \link{https://en.wikipedia.org/wiki/Berkeley_Software_Distribution}{BSD}.
  J'ai tâché de fournir ici des expressions universelles qui
  fonctionnent dans ces deux principales variantes.}

\section{Expressions régulières}
\label{sec:texte:regex}

Tel que mentionné dans l'introduction de ce chapitre, une expression
régulière, ou expression rationnelle, est un langage, muni d'une
syntaxe précise, qui permet de décrire un ensemble de chaines de
caractères possibles. Vous avez rencontré quelques expressions
régulières très simples et intuitives à la section précédente. Ainsi,
l'expression régulière \regex{chat} décrit la chaine «chat», mais
aussi «chats», «chaton» ou «achat». Nous verrons dans la suite comment
restreindre l'expression au seul mot «chat».

Cette section propose une introduction au langage des expressions
régulières. Il existe une multitude de tutoriels et de documents de
référence sur le sujet dans Internet et sous forme de livre. Pour vous
accompagner dans l'atteinte des objectifs d'apprentissage mentionnés
au début du chapitre, je me suis inspiré de l'excellent guide
\link{https://developer.apple.com/library/content/documentation/OpenSource/Conceptual/ShellScripting/}{\emph{Shell
    Scripting Primer}} de la bibliothèque pour développeurs de Apple
\citep{Apple:shellprimer}. Si vous souhaitez étudier les expressions
régulières vraiment en profondeur, je vous recommande l'ouvrage de
référence classique de \citet{Friedl:regex:2006}.

\subsection{Types d'expressions régulières}
\label{sec:texte:regex:types}

Avant d'aller plus loin, vous devez absolument savoir qu'il existe
trois grands types d'expressions régulières: les expressions
régulières basiques ou classiques (\emph{Basic Regular Expressions},
BRE), les expressions régulières étendues (\emph{Extended Regular
  Expressions}, ERE) et les expressions régulières de Perl (\emph{Perl
  Compatible Regular Expressions}, PCRE). Les utilitaires \icode{grep}
et \icode{sed} utilisent les expressions régulières basiques par défaut.

Les principales différences entre les expressions régulières basiques
et étendues sont les suivantes.
\begin{itemize}
\item Dans les expressions régulières étendues, les symboles
  «\code{+}» et «\code{?}» sont des opérateurs de répétition. Dans les
  expressions régulières basiques, ce sont des caractères ordinaires
  et il n'existe aucun équivalent pour leur fonctionnalité respective.
\item Dans les expressions régulières étendues, le symbole «\code{|}»
  est un opérateur de choix entre plusieurs possibilités. Dans les
  expressions régulières basiques, c'est un caractère ordinaire et il
  n'existe aucun équivalent pour sa fonctionnalité.
\item Dans les expressions régulières basiques, les accolades \code{\{
    \}} et les parenthèses \code{( )} sont des caractères ordinaires
  et il faut les précéder du symbole \code{\bs} pour les convertir,
  respectivement, en opérateurs de quantificateur borné et de
  regroupement. C'est l'inverse dans les expressions régulières
  étendues.
\end{itemize}




\section{Traitement de texte divisé en champs avec \code{awk}}
\label{sec:texte:awk}



\section{Fonctions internes utiles}
\label{sec:texte:internes}

Cette section présente quelques unes seulement des fonctions internes
qu'offre R pour rechercher et remplacer du texte à l'aide
d'expressions régulières. Consultez la rubrique d'aide (commune) de
n'importe laquelle de celles-ci pour connaitre l'ensemble des
fonctions disponibles et les détails concernant leur fonctionnement.
Vous trouverez également dans la rubrique d'aide de nombreux exemples
d'utilisation additionnels.

Les exemples de cette section utilisent le vecteur \icode{state.name}
fourni avec R et qui contient les noms des cinquante États américains.
<<echo=FALSE>>=
op <- options(width=55)                 # trois colonnes
@
<<echo=TRUE>>=
state.name
@
<<echo=FALSE>>=
options(op)                             # rétablir défaut
@

\warningbox{Rappelons qu'en R un vecteur de mode \icode{character} peut
  contenir plusieurs chaines de caractères. Les fonctions ci-dessous
  effectuent leur traitement sur chacune des chaines d'un vecteur.}

\begin{ttscript}{regexpr}
\item[\code{grep}] \index{grep@\code{grep} (R)|bfhyperpage} recherche
  d'une expression régulière dans un vecteur de chaines de caractères
<<echo=TRUE>>=
grep("na$", state.name)
grep("na$", state.name, value = TRUE)
@
\item[\Icode{regexpr}] comme \index{grep@\code{grep} (R)}grep, mais
  avec des informations additionnelles sur la position et la longueur
  des appariements dans les résultats
<<echo=TRUE>>=
regexpr("na$", state.name)
@
\item[\Icode{sub}] recherche une expression régulière dans un vecteur
  de chaines de caractères et remplace uniquement la première
  occurence dans chaque chaine par une autre chaine
<<echo=TRUE>>=
sub("i", "*", state.name)
@
\item[\Icode{gsub}] comme \icode{sub}, mais remplace toutes les
  occurences dans chaque chaine par une autre chaine
<<echo=TRUE>>=
gsub("i", "*", state.name)
@
\end{ttscript}

\tipbox{Plusieurs langages de programmation contiennent des
  utilitaires \code{grep}, \code{sub} et \code{gsub}. Par exemple,
  dans \icode{awk} des fonctions \code{sub} et \code{gsub} permettent
  d'effectuer des remplacements à l'intérieur des champs.}


\section{Exemples additionnels}
\label{sec:texte:exemples}

Exceptionnellement, je présente les exemples additionnels de ce
chapitre en texte normal plutôt que sous forme de fichier de script.

Les exemples ci-dessous utilisent des fichiers distribués avec le
présent document dans l'archive \code{programmer-avec-r.zip}.
Assurez-vous d'avoir extrait les fichiers de l'archive quelque part
sur votre disque et notez bien cet endroit: vous en aurez besoin dans
un instant.

Vous devez entrer les expressions ci-dessous à une ligne de commande
du \index{Terminal}Terminal sous macOS, ou de \index{Git~Bash}Git~Bash
ou MSYS sous Windows.

\importantbox{L'espace horizontal étant compté dans un document en
  format PDF, il est parfois nécessaire de scinder une commande sur
  deux lignes ou plus. Pour ces cas, j'ai inséré le symbole de
  continuation de ligne «\bs» de Bash à la fin des lignes. Vous pouvez
  ainsi copier les commandes directement du document et les coller
  dans une ligne de commande. Le symbole {\bs} ne fait \emph{pas}
  partie des commandes.}

En premier lieu, déplacez, à l'aide de la commande \icode{cd},
l'invite de commande dans le répertoire où vous avez extrait les
fichiers de l'archive.

Comme premier exemple, dressons la liste de toutes les utilisations de
la fonction \code{matrix} dans les fichiers d'exemples. C'est un
travail pour l'utilitaire \icode{grep}.
\begin{Schunk}
\begin{Verbatim}
$ grep matrix *.R
\end{Verbatim}
\end{Schunk}

L'option \code{-l} de \icode{grep} permet de limiter les résultats à
la liste des fichiers contenant au moins une utilisation de
\code{matrix}.
\begin{Schunk}
\begin{Verbatim}
$ grep -l matrix *.R
\end{Verbatim}
\end{Schunk}

Pour connaitre les fichiers d'exemples dans lesquels apparaissent les
objets \code{letters} et \code{LETTERS}, nous devons rechercher sans
égard à la casse pour attraper les deux cas.
\begin{Schunk}
\begin{Verbatim}
$ grep -i letters *.R
\end{Verbatim}
\end{Schunk}

Allons-y maintenant d'une expression régulière plus élaborée pour
trouver toutes les utilisations de la fonction \code{g} dans les
fichiers d'exemples, c'est-à-dire la chaine \code{g(} précédée d'au
moins une espace ou en début de ligne.
\begin{Schunk}
\begin{Verbatim}
$ grep -E '( |^)g\(' *.R
\end{Verbatim}
\end{Schunk}

Tel que mentionné à la \autoref{sec:texte:outils}, la fonction
\icode{sed} sert surtout pour rechercher et remplacer dans un fichier,
et ce, ligne par ligne par défaut. Remplaçons les symboles de
commentaires triples «\code{\#\#\#}» en début de ligne (à la Emacs) dans
le fichier \code{pratiques.R} par un symbole unique «\code{\#}» (à
la RStudio). Pour faire bonne mesure, plaçons le résultat dans un
nouveau fichier \code{pratiques-new.R} à l'aide de l'opérateur de
redirection de Bash \index{>@\code{>} (Bash)}«\code{>}».
\begin{Schunk}
\begin{Verbatim}
$ sed 's/^###/#/' pratiques.R > pratiques-new.R
\end{Verbatim}
\end{Schunk}

Le programme \icode{awk} est particulièrement utile pour traiter des
fichiers dont les lignes sont séparées en «champs», comme des colonnes
de données, par exemple. Or, le présent document est justement livré
avec le fichier \code{100metres.data} qui contient la liste des 31
meilleurs temps enregistrés au 100~mètres homme entre 1964 et 2005
(voir l'\autoref{ex:tri:100metres}).
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data
\end{Verbatim}
\end{Schunk}

Effectuons dans un premier temps l'extraction des temps des records
(second champ). La première commande utilise un transfert de données
du programme \icode{cat} vers \icode{awk} avec l'opérateur de
transfert de données de Bash \index{{"|}@\code{\textbar} (Bash)}
«\code{\textbar}», alors que la seconde, plus usuelle et tout à fait
équivalente, emploie un fichier en entrée.
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data | awk '{ print $2 }'
$ awk '{ print $2 }' 100metres.data
\end{Verbatim}
\end{Schunk}

L'inversion des deux colonnes du fichier est simple à réaliser avec
\icode{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $2, $1 }' 100metres.data
\end{Verbatim}
\end{Schunk}

Les colonnes du fichier \code{100metres.data} sont séparées par une
espace. Remplaçons ces espaces par des virgules pour convertir le
fichier en format CSV. Je fournis deux solutions, avec \icode{awk} et avec
\icode{sed}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $1","$2 }' 100metres.data
$ sed 's/ /,/' 100metres.data
\end{Verbatim}
\end{Schunk}

Changeons maintenant le format de la date du format
\link{https://fr.wikipedia.org/wiki/ISO_8601}{ISO~8601} aaaa-mm-qq
vers le format américain qq/mm/aa. D'abord une solution avec
\icode{awk}. En premier lieu, nous devons changer le séparateur de
champs de \code{awk} (l'espace par défaut) pour l'espace et le tiret.
Ainsi, \code{awk} va non seulement séparer les deux colonnes du
fichier, mais aussi les champs de la date. Ensuite, nous replaçons les
champs dans l'ordre voulu avec les bons séparateurs. La fonction
\index{substr@\code{substr} (awk)}\code{substr} de \code{awk} permet
de sélectionner une partie d'une chaine de caractères
\citep[section~9.1.3]{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk 'BEGIN { FS = "[ -]" } \
       { print $2"/"$3"/"substr($1, 3), $4 }' \
       100metres.data
\end{Verbatim}
\end{Schunk}

La solution avec \icode{sed} maintenant, qui repose non pas sur des
champs détectés automatiquement, mais plutôt sur la recherche et le
remplacement d'expressions régulières. Nous recherchons l'expression
régulière suivante en capturant chaque élément trouvé (sauf les
tirets): les nombres 19 ou 20; deux chiffres; un tiret; deux chiffres;
un tiret; deux chiffres; tout le reste de la ligne. Nous replaçons
ensuite les éléments capturés dans l'ordre souhaité avec des barres
obliques \code{/} entre les éléments de dates. Comme le symbole
\code{/} est utilisé dans la chaine de sortie, il faut utiliser un
autre symbole pour séparer les champs de la commande \code{sed}. J'ai
utilisé le symbole «\verb|~|» ici.
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's~(19|20)([0-9]{2})-([0-9]{2})-([0-9]{2})(.*)~'\
'\3/\4/\2\5~' 100metres.data
\end{Verbatim}
\end{Schunk}

Amusons-nous maintenant avec le fichier \code{NEWS} qui contient
l'historique des versions du document. La commande suivante dresse la
liste des numéros de versions.
\begin{Schunk}
\begin{Verbatim}
$ grep '^# [[:digit:]]' NEWS
$ grep -E '^# [[:digit:]]' NEWS
\end{Verbatim}
\end{Schunk}

Un dernier exemple plus avancé. Nous souhaitons extraire du fichier
\code{NEWS} les notes de mise à jour de la plus récente version. Si
vous examinez le fichier, vous constaterez que les notes de mise à
jour relatives à une version donnée débutent toujours à une ligne
marqué par %
\verb*|# |. %
Le meilleur outil pour effectuer des opérations sur plusieurs lignes
d'un fichier est \icode{awk}, tel que mentionné à la
\autoref{sec:texte:outils}.

L'idée, ici, consiste à avoir recours à une variable dite d'«état».
Avant qu'elle ne soit explicitement définie, la valeur de cette
variable est $0$ (faux). Lorsque la chaine marquant le début des notes
d'une version est trouvée, on donne une valeur de $1$ (vrai) à la
variable, puis l'on affiche les lignes jusqu'à ce que l'on rencontre
une nouvelle ligne débutant par %
\verb*|# |, %
moment où cesse le traitement du fichier.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state == 1 { print }' NEWS
\end{Verbatim}
\end{Schunk}

Nous pouvons écrire la commande ci-dessus de manière légèrement plus
compacte. En effet, écrire \code{state == 1} pour tester que la
variable \code{state} est vraie n'est pas nécessaire dans la mesure où
il est sous-entendu que l'expression qui précède l'action dans une
commande \icode{awk} est un test conditionnel et que \code{awk} traite
la valeur
$1$ comme vraie. De plus, la commande \code{print} est implicite avec
\code{awk}. Il n'est donc pas nécessaire de la demander explicitement.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state' NEWS
\end{Verbatim}
\end{Schunk}

\notebox{Les opérations de composition du présent document, de
  publication dans GitLab et de mise à jour de la page web sont
  entièrement automatisées à l'aide de
  \link{https://fr.wikipedia.org/wiki/Make}{\code{make}}, un autre de
  ces outils standards sur les systèmes Unix. Vous pouvez retrouver
  une variante un peu plus élaborée de la commande \code{awk}
  ci-dessus dans la règle \code{create-release} du fichier de
  configuration \code{Makefile} qui se trouve dans le
  \link{\reposurl}{code source} du document. Jetez-y un coup d'œil!}


\section{Exercices}
\label{sec:texte:exercices}

\Opensolutionfile{solutions}[solutions-texte]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:texte}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:texte}}

\end{Filesave}

\begin{exercice}
  Dans chacun des cas ci-dessous, déterminer à laquelle ou auxquelles
  des chaines de caractères correspond l'expression régulière donnée.
  Les symboles \verb=/= ne servent qu'à délimiter le début et la fin
  des expressions régulières. Ne pas tenir compte des espaces avant ou
  après les chaines.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/extra_regexps.html}.}
  \begin{enumerate}
    \setlength{\multicolsep}{2pt}
  \item \verb~/a(ab)*a/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abababa~
      \item \verb~aaba~
      \item \verb~aabbaa~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~aba~
      \item \verb~aabababa~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/ab+c?/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~ac~
      \item \verb~abbb~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~bbc~
      \item \verb~abcc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/a.[bc]+/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~abbbbbbbb~
      \item \verb~azc~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~abcbcbcbc~
      \item \verb~ac~
      \item \verb~asccbbbbcbcccc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/abc|xyz/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~xyz~
      \item \verb~abc|xyz~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z]+[\.\?!]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~battle!~
      \item \verb~Hot~
      \item \verb~green~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~swamping.~
      \item \verb~jump up.~
      \item \verb~undulate?~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~is.?~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-zA-Z]*[^,]=/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~Butt=~
      \item \verb~BotHEr,=~
      \item \verb~Ample~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~FIdDlE7h=~
      \item \verb~Brittle =~
      \item \verb~Other.=~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z][\.\?!]\s+[A-Z]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~A. B~
      \item \verb~c! d~
      \item \verb~e f~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~g. H~
      \item \verb~i? J~
      \item \verb~k L~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/<[^>]+>/~
    \begin{enumerate}[1)]
      \begin{multicols}{2}
      \item \verb~<an xml tag>~
      \item \verb~<opentag> <closetag>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~</closetag>~
      \item \verb~<>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~<with attribute=”77”>~
      \end{multicols}
    \end{enumerate}
  \end{enumerate}

  \begin{sol}
    \begin{enumerate}
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de zéro, une ou plusieurs occurrences des
      lettres minuscules «\verb=ab=», suivies de la lettre minuscule
      «\verb=b=». Les choix 2 et 5 satisfont ces conditions.
    \item L'expression régulière identifie la lettre
      «\verb=a=», suivie d'au moins une occurrence de la lettre
      minuscule «\verb=b=», suivie de zéro ou une occurrence de la
      lettre minuscule «\verb=c=». Les choix 1 et 3 satisfont ces
      conditions.
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de n'importe quel caractère (incluant les
      lettres «\verb=b=» et «\verb=c=»), suivi d'au moins une
      occurrence des lettres minuscules «\verb=b=» ou «\verb=c=». Les
      choix 1, 2, 3, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie les suites de lettres
      minuscules «\verb=abc=» ou «\verb=xyz=». Les choix 1 et 2
      satisfont la condition. Le troisième choix n'est pas valide
      puisque l'expression n'identifie pas le symbole «\verb=|=».
    \item L'expression régulière identifie au moins une lettre
      minuscule (à l'exclusion de tout autre symbole), suivie de l'un
      ou l'autre des symboles «\verb=.=», «\verb=?=», «\verb=!=» (sans
      répétition). Les choix 1, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie zéro, une ou plusieurs
      lettres minuscules ou majuscule (mais aucun autre symbole),
      suivies de tout caractère autre qu'une virgule, suivi du symbole
      «\verb|=|». Les choix 1, 5 et 6 satisfont ces conditions.
    \item L'expression régulière identifie une lettre minuscule,
      suivie de l'un ou l'autre des symboles «\verb=.=», «\verb=?=»,
      «\verb=!=» (sans répétition), suivi d'au moins une espace,
      suivie d'une lettre majuscule. Les choix 4 et 5 satisfont ces
      conditions.
    \item L'expression régulière identifie le symbole «\verb=<=»,
      suivi d'au moins un symbole autre que «\verb=>=», suivi du symbole
      «\verb=>=». Les choix 1, 3 et 5 satisfont ces conditions. Dans
      le choix 2, tant \verb~<opentag>~ que \verb~<closetag>~
      satisfont la condition, mais pas les deux ensemble.
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui correspond à tous les mots de
  la liste de gauche, ci-dessous, mais à aucun des mots de la liste de
  droite.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/cgi/ex1.cgi}.}
  \begin{center}
    \begin{minipage}[t]{0.3\linewidth}
      pit \\
      spot \\
      spate \\
      slap two \\
      respite
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      pt \\
      Pot \\
      peat \\
      part
    \end{minipage}
  \end{center}
  \begin{sol}
    L'expression doit identifier la lettre minuscule «\verb=p=»
    précédée ou non d'une ou de plusieurs lettres (ou symboles, ce n'est
    pas spécifié), suivie d'une (et une seule) lettre ou d'une espace,
    de la lettre «\verb=t=» et, enfin, de zéro ou de plusieurs
    lettres. Il y a assurément plusieurs réponses valides. En voici
    une: \verb=/.*p[a-z ]t.*/=.
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui permet de vérifier la validité
  d'un code postal canadien dans un formulaire électronique. Ne pas
  tenir compte des règles précises de composition d'un code postal,
  mais bien seulement qu'il s'agit d'une suite de six caractères
  alternant entre une lettre et un chiffre. Les lettres peuvent être
  fournies en majuscule ou en minuscule et l'espace entre le troisième
  et le quatrième symbole peut être présent ou non.
  \begin{sol}
    L'expression \verb=[a-zA-z][0-9][a-zA-z]\s?[0-9][a-zA-z][0-9]=
    convient si l'on ne permet que zéro ou une espace entre les deux
    blocs. S'il n'y a pas de limite au nombre d'espaces, remplacer
    «\verb=?=» par «\verb=*=».
  \end{sol}
\end{exercice}

\begin{exercice}
  Écrire une commande \code{sed} permettant de changer le séparateur
  décimal dans les temps du fichier \code{100metres.data} pour une
  virgule.
  \begin{sol}
    \code{sed} est l'outil idéal pour de tels traitements simples à
    effectuer ligne par ligne.
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data
\end{Verbatim}
    \end{Schunk}
    Pour placer le fichier modifié dans, disons,
    \code{100metres-dec.data}, utiliser
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data > 100metres-dec.data
\end{Verbatim}
    \end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Extraire du fichier \code{100metres.data} les informations des
    temps réalisés au mois d'août.
  \item Extraire les informations des temps de moins de 10~secondes.
  \item Extraire les lignes du fichier satisfaisant les deux
    conditions précédentes. Vous pouvez avoir recours à l'opérateur de
    transfert de données de Bash \index{{"|}@\code{\textbar} (Bash)}%
    «\code{\textbar}» pour combiner les commandes des parties a) et
    b).
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item C'est un travail pour \code{grep}. La solution la plus
      simple serait:
      \begin{Schunk}
\begin{Verbatim}
$ grep '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Cependant, \code{grep} n'aime pas cette commande puisque le
      symbole \verb=-= est utilisé pour passer des options. Dans ce
      cas, il vaut mieux utiliser une option \verb=-e= pour déclarer
      explicitement à \code{grep} que ce qui suit est l'expression à
      rechercher:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Autrement, simplement ajouter quelque chose à chercher avant le tiret:
      \begin{Schunk}
\begin{Verbatim}
$ grep '.*-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Le plus simple, ici, consiste à utiliser \code{awk} puisque
      les seconds champs --- les temps --- seront automatiquement
      disponibles.
      \begin{Schunk}
\begin{Verbatim}
$ awk '$2 < 10 { print }' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Malheureusement, cette commande risque de ne pas fonctionner sur
      certains systèmes qui traitent la virgule comme le séparateur
      décimal, notamment les Mac en configuration française. Dans ce
      cas, essayer plutôt (j'ai supprimé la commande \verb={ print }=
      ci-dessous puisqu'elle est implicite):
      \begin{Schunk}
\begin{Verbatim}
$ LC_NUMERIC="en_US.UTF-8" awk '$2 < 10' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Une solution avec \code{grep} consisterait à rechercher un
      «\verb=9.=» après l'espace sur chaque ligne:
      \begin{Schunk}
\begin{Verbatim}
$ grep ' 9\.' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Nous pouvons combiner les deux commandes ainsi:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | awk '$2 < 10'
\end{Verbatim}
      \end{Schunk} %$
      ou
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | grep ' 9\.'
\end{Verbatim}
      \end{Schunk}
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Pour tous les appels à une fonction \code{f} comportant deux
  arguments dans le fichier \code{environnement.R} livré avec le
  présent document, changer le nom de la fonction pour \code{fun} et
  inverser l'ordre des deux arguments.
  \begin{sol}
    Ce traitement s'effectue bien avec \code{sed}:
    \begin{Schunk}
\begin{Verbatim}
$ sed -E 's/( |^)f\((.*), (.*)\)/fun(\3, \2)/' \
  environnement.R
\end{Verbatim}
    \end{Schunk}
    Le premier groupe \verb=( |^)= capture une espace avant \code{f}
    ou le début de la ligne.
  \end{sol}
\end{exercice}

\begin{exercice}
  Résoudre le présent exercice dans R en utilisant le vecteur interne
  de données \icode{state.name}.
  \begin{enumerate}
  \item Déterminer les positions, dans l'ordre alphabétique, des États
    dont le nom comporte deux «s» de suite.
  \item Extraire les États dont le nom comporte au moins trois fois la
    lettre «s», qu'elles soient successives ou non.
  \item Extraire les États dont le nom comporte un double «s» parmi
    les quatre premiers caractères, puis abréger leur nom après ce
    double «s» et faire suivre d'un point. Par exemple:
    «Massachusetts» devient «Mass.».
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item On utilise la fonction \icode{grep}. L'expression régulière
      est très simple dans le cas présent. Avec l'argument
      \code{value} à \code{FALSE} (la valeur par défaut), la fonction
      retourne les positions dans le vecteur des chaines de caractères
      qui correspondent à l'expression régulière. Comme le vecteur de
      noms est trié, il s'agit des valeurs demandées.
<<echo=TRUE,eval=FALSE>>=
grep("ss", state.name)
@
    \item C'est toujours un travail pour \icode{grep}, mais
      l'expression régulière est cette fois un peu plus complexe. Deux
      solutions sont proposées ci-dessous. Il faut utiliser l'argument
      \code{value = TRUE} pour obtenir les noms des États, et non
      seulement leurs positions dans \code{state.name}.
<<echo=TRUE,eval=FALSE>>=
grep("(.*s){3,}", state.name, value = TRUE)
grep(".*s.*s.*s", state.name, value = TRUE)
@
    \item Nous devons extraire les États avec \icode{grep}, puis
      utiliser \icode{sub} pour remplacer les caractères après le
      quatrième par un point. Ceci requiert de sauvegarder les
      caractères jusqu'aux deux «s» successifs pour les réutiliser
      dans la chaine de remplacement.
<<echo=TRUE,eval=FALSE>>=
sub("(^.{0,2}ss).*", "\\1.",
    grep("(^.{0,2}ss)", state.name, value = TRUE))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
