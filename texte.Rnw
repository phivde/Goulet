%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Analyse et contrôle de texte}
\label{chap:texte}

<<echo=FALSE>>=
options(width = 50)

##
## Affiche une commande exécutée par le système et son résultat.
##
exec <- function(command, args, echo = TRUE, eval = TRUE)
{
    cmd <- paste("$", command, paste(args, collapse = " "))
    if (eval)
    {
        res <- system2(command, args, stdout = TRUE)
        if (echo)
            cat(paste(cmd, paste(res, collapse = "\n"), sep = "\n"))
        else
            cat(paste(res, collapse = "\n"))
    }
    else
        cat(cmd)
}
@

\begin{objectifs}
\item Utiliser les expressions régulières pour décrire ou identifier
  une chaine de caractères.
\item Effectuer l'analyse et le contrôle de texte à l'aide des outils
  informatiques standards \code{grep}, \code{sed} et \code{awk}.
\item Effectuer des opérations de recherche et de remplacement de
  texte à l'aide d'expressions régulières avec les divers outils de R.
\end{objectifs}

Vous êtes-vous déjà demandé comment s'effectue la validation de
certains champs comme le code postal ou l'adresse de courrier
électronique dans les formulaires électroniques? Surement pas en
vérifiant si l'entrée figure dans la liste des quelques 17,5~millions
de codes postaux possibles au Canada ou, pire, parmi les milliards
d'adresse de courriel que les
\link{https://tools.ietf.org/html/rfc3696}{règles internationales}
permettent de concevoir! Non, ce qu'il faut, c'est un «langage» qui
permet de décrire \emph{comment} une chaine de caractères peut être
composée, sans toutefois en fixer la composition exacte. Un tel
langage existe: ce sont les \emph{expressions régulières} ou
expressions rationnelles.

Une \index{expression régulière}expression régulière (\emph{regular
  expression}, ou regex ou regexp) est une suite de caractères
typographiques qui décrit, selon une syntaxe précise, un ensemble de
chaines de caractères possibles
\citep{Wikipedia:Expression_reguliere}. L'expression elle-même est
souvent appelée un \Index{motif}«motif» (\emph{pattern}). Les
expressions régulières s'avèrent particulièrement utiles dans
l'analyse de données textuelles et dans le traitement de la langue
naturelle (\emph{natural language processing}, NLP), une branche
importante de l'intelligence artificielle.

Voici quelques utilisations possibles des \index{expression
  régulière}expressions régulières.
\begin{itemize}
\item Rechercher du texte pouvant contenir des variations ou des
  fautes d'orthographe comme, par exemple, «je transfert» plutôt que
  «je transfère», ou encore les multiples variations autour du verbe
  «appeler»: appel, appelle, appellent, appeler, appelez, etc.
\item Extraire les coordonnées géographiques d'un lieu (latitude et
  longitude) de l'URL d'une carte Google Maps. Par exemple, l'%
  \link{https://www.google.ca/maps/place/Universite+Laval/@46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d46.7817463!4d-71.2747424}{URL
    correspondant à la recherche «Université Laval»} est
  \begin{Schunk}
\begin{Verbatim}
https://www.google.ca/maps/place/Universite+Laval/
  @46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!
  1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d
  46.7817463!4d-71.2747424
\end{Verbatim}
  \end{Schunk}
  dont on décode que le lieu se trouve à une latitude de
  $\nombre{46,7817463}$ et à une longitude de $\nombre{-71.2769311}$
  en degrés décimaux.
\item Extraire d'une base de données les adresses se trouvant sur une
  rue ou une avenue numérotée («1{\iere} Avenue» ou «4{\ieme} Rue»),
  et ce, peu importe comment est orthographié l'abréviation de
  l'adjectif numéral ordinal («re» ou «ère», «e» ou «ième»).
\item Sélectionner les entrées d'une base de données qui débutent ou
  qui se terminent par un caractère spécifique.
\item Déterminer par programmation si un dépôt Git contient une
  branche autre que \code{master} en examinant le résultat de la
  commande \code{git branch}.
\item Mettre en italique tous les mots d'un texte qui se trouvent
  entre guillemets (mais pas les guillemets eux-mêmes), et ce, quels
  que soient les mots.
\end{itemize}

Un jour ou l'autre, vous aurez à traiter des chaines de caractères en
programmation ou en analyse de données. Ce jour-là, connaitre les
expressions régulières vous sera d'un grand secours.

\begin{figure}[t]
  \centering
  \begin{minipage}{0.9\linewidth}
    \setkeys{Gin}{width=\textwidth}
    \includegraphics{images/regular_expressions} \\
    \footnotesize\sffamily%
    Tiré de \href{https://xkcd.com/208/}{XKCD.com}
  \end{minipage}
\end{figure}


\section{Conventions typographiques et texte des exemples}
\label{sec:texte:conventions}

La présentation des expressions régulières exige souvent de clairement
délimiter un \index{motif}motif et d'afficher certains caractères
invisibles, comme les espaces ou les retours à la ligne. Pour ce
chapitre, lorsque le contexte l'exige:
\begin{itemize}
\item les motifs sont encadrés de «coins» de couleur contrastante,
  comme \regex{ceci} \citep[une notation que j'emprunte
  à][]{Friedl:regex:2006};
\item les espaces sont représentées par le symbole \aspace, ce qui
  permet, par exemple, de bien discerner que le motif
  \regex{\#\aspace\aspace\aspace\aspace A} compte quatre espaces entre
  \code{\#} et \code{A};
\item la chaine dans laquelle s'effectue une recherche est représentée
  en police non proportionnelle et les correspondances d'un motif dans
  celle-ci sont mis en surbrillance, comme dans l'exemple suivant:
  \begin{center}
    le motif \regex{chat} correspond à \chaine{Les \matches{chat}s
      sont très mignons.}
  \end{center}
\item le caractère de retour à la ligne (\emph{newline}) est
  représenté par {\NLsymbol} et celui de retour chariot (\emph{carriage
    return}) est représenté par \CRsymbol.
\end{itemize}

Dans les exemples, nous utiliserons le texte de la chanson «La journée
qui s'en vient est flambant neuve» de l'album \emph{Astronomie} (2012)
du groupe québécois Avec pas d'casque. Le texte est fourni avec le
présent document dans le fichier \code{chanson.txt}. Pour référence,
il est également reproduit à la \autoref{fig:texte:chanson}.

\begin{figure}
  \centering
  \lstinputlisting[frame=single,numbers=none]{chanson.txt}
  \caption{Texte de la chanson «La journée qui s'en vient est flambant
    neuve» de Avec pas d'casque}
  \label{fig:texte:chanson}
\end{figure}


\section{Outils d'analyse et de contrôle du texte}
\label{sec:texte:outils}

L'\index{expression régulière}expression régulière n'est qu'un langage
de description d'une chaine de texte. Pour exploiter ce langage, des
outils sont nécessaires. Aux fins de cet ouvrage, j'ai choisi de
concentrer notre étude sur les utilitaires Unix standards en ligne de
commande \icode{grep}, \icode{sed} et \icode{awk}. Ils font partie
intégrante des systèmes d'exploitation macOS et Linux et, sous
Windows, ils sont livrés avec les interpréteurs de commande
\index{MSYS}MSYS de \index{MSYS2}\link{https://www.msys2.org}{MSYS2}
et \index{Git~Bash}Git~Bash de
\link{https://git-scm.com/downloads}{Git for Windows}.

Il va sans dire que les utilitaires \icode{grep}, \icode{sed} et
\icode{awk} s'utilisent depuis une ligne de commande \index{Unix}Unix:
dans le \index{Terminal}Terminal sous macOS, ou dans
\index{Git~Bash}Git~Bash ou MSYS sous Windows. Si vous n'êtes pas
familier avec la ligne de commande,
\citet{Goulet:laboratoire-cli-git:2019} offre une rapide introduction
suffisante pour suivre la matière de ce chapitre. Nous reviendrons à R
à la \autoref{sec:texte:internes} lorsque nous étudierons les
fonctions internes de R aux fonctionnalités équivalentes à \code{grep}
et \code{sed}.

Comme la plupart des utilitaires Unix, \icode{grep}, \icode{sed} et
\icode{awk} prennent en entrée un flux de texte ou un ou plusieurs
fichiers en format texte brut. Ils opèrent ensuite sur cette entrée
\emph{ligne par ligne}. Le résultat du traitement est affiché à la
sortie standard (le terminal), transféré à un autre programme avec le
tuyau \index{{"|}@\code{\textbar} (tuyau Unix)} «\code{\textbar}», ou
encore redirigé vers un fichier avec l'opérateur «\code{>}». La
\autoref{fig:texte:flux-cli}, reprise de
\citet{Goulet:laboratoire-cli-git:2019} avec quelques simplifications,
illustre ce flux des données.

\begin{figure}
  \centering
  \setlength{\unitlength}{4mm}
  \small
  \begin{picture}(31.25,8.5)(-0.25,0)
    \thicklines
    \put(3,6){\makebox(0,0)[t]{\parbox{6.5\unitlength}{
          \centering{\LARGE\faStream~\faFile*[regular]} \\[4pt]
          entrée standard ou fichier}}}
    \put(6,5){\vector(1,0){3.5}}
    \put(12,6){\makebox(0,0)[t]{\parbox{6\unitlength}{
          \centering{\LARGE\faCogs} \\[4pt]
          \code{grep}, \code{sed}, \code{awk}}}}
    \put(14.75,5){\line(1,0){1.5}}
    \put(16.25,7){\line(0,-1){4}}
    \put(16.25,7){\vector(1,0){1.75}}
    \put(16.25,3){\vector(1,0){1.75}}
    \put(21,8){\makebox(0,0)[t]{\parbox{6.5\unitlength}{
          \centering{\LARGE\faStream} \\[4pt]
          erreur standard}}}
    \put(21,4){\makebox(0,0)[t]{\parbox{6\unitlength}{
          \centering{\LARGE\faStream} \\[4pt]
          sortie standard}}}
    \put(23.75,3){\vector(1,0){2.75}}
    \put(25,3.75){\makebox(0,0){\color{regex}\code{>}}}
    \put(28,4){\makebox(0,0)[t]{\parbox{4\unitlength}{
          \centering{\LARGE\faFile*[regular]} \\[4pt]
            fichier}}}
    \Line(21,0.75)(21,0)(3,0)
    \put(3,0){\vector(0,1){1.5}}
    \put(16.25,0.75){\makebox(0,0){\color{regex}\code{\textbar}}}
  \end{picture}
  \caption{Flux des données à la ligne de commande Unix}
  \label{fig:texte:flux-cli}
\end{figure}

Les outils \icode{grep}, \icode{sed} et \icode{awk} diffèrent quant au
type de traitement qu'ils peuvent effectuer.
\begin{ttscript}{grep}
\item[\code{grep}] sélectionne les lignes en entrée correspondant à
  une \index{expression régulière}expression régulière.
\item[\code{sed}] sert surtout pour rechercher et remplacer du texte.
\item[\code{awk}] permet de traiter aisément du texte séparé en
  champs, ainsi que du texte réparti sur plusieurs lignes.
\end{ttscript}

Puisque nous utiliserons les utilitaires \icode{grep} et \icode{sed} à
profusion dans la présentation sur les expressions régulières à la
\autoref{sec:texte:regex}, prenons un moment pour apprendre comment
les utiliser. L'utilitaire \icode{awk}, quant à lui, fera l'objet
de la \autoref{sec:texte:awk}.

\notebox{Dans la littérature informatique, la présentation des
  \index{expression régulière}expressions régulières s'accompagne
  généralement de celle du langage de programmation \index{Perl}Perl.
  En effet, Perl a été créé par Larry Wall en 1987 justement pour
  traiter facilement du texte. Le langage prend en charge les
  expressions régulières dans sa syntaxe même et il comporte plusieurs
  extensions aux expressions prises en charge par \icode{grep} et
  \icode{sed}. Cet ouvrage ne traite pas de \icode{Perl}.}

\subsection{Extraction de lignes avec \code{grep}}
\label{sec:texte:outils:grep}

L'utilitaire \Icode{grep}\footnote{%
  Le nom de l'utilitaire provient de la commande \code{:g/re/p} de
  l'antédiluvien éditeur de texte \icode{ed} qui permet de rechercher
  globalement (\code{g}) une expression régulière (\emph{regular
    expression}, \code{re}) et d'afficher (\emph{print}, \code{p}) les
  lignes qui correspondent à l'expression.} %
prend en argument une \index{expression régulière}expression régulière
entre guillemets (simples ou doubles), lit l'entrée standard ou une
liste de fichiers ligne par ligne, puis retourne sur la sortie
standard les lignes qui contiennent des correspondances avec
l'expression régulière. C'est très utile pour savoir si un fichier
contient --- ou quels fichiers contiennent --- un mot ou une
expression, assez pour que le nom de l'utilitaire soit devenu, en
anglais, un verbe dans le %
\link{http://www.catb.org/jargon/html/G/grep.html}{jargon
  informatique} %
(\emph{to grep}).

Les trois exemples ci-dessous permettent, dans l'ordre, d'extraire du
fichier \code{chanson.txt}: le vers de la chanson qui contient le mot
«temps»; les vers qui débutent par «M»; le vers qui contient le mot
«chat» (aucun\footnote{%
  Sachez que la \link{https://youtu.be/eR_44AzYIZs}{vidéo} de la
  chanson est, elle, emplie de chatons très mignons.}).
<<echo=FALSE>>=
exec("grep", c("'temps'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'^M'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'chat'", "chanson.txt"))
@

Comme la plupart des utilitaires Unix, \icode{grep} accepte en
argument des options (ou drapeaux) qui modifient son comportement. Les
options se présentent généralement en deux versions: courte sous forme
d'une seule lettre précédée d'un tiret, ou longue sous forme d'un mot
(ou une expression) précédé de deux tirets. Les options de
\icode{grep} sont très nombreuses; je n'en ai retenu que quelques unes
ici.

\begin{ttscript}{-E, --extended-regexp}
\item[\code{-E, --extended-regexp}] interprète le motif comme une expression
  régulière étendue.
\item[\code{-c, --count}] retourne seulement le nombre de lignes qui
  correspondent au motif.
\item[\code{-o, --only-matching}] retourne uniquement la portion de la
  ligne qui correspond au motif, plutôt que la ligne au complet.
\item[\code{-v, --invert-match}] sélectionne les lignes
  qui ne correspondent \emph{pas} au motif.
\end{ttscript}

Nous aurons l'occasion d'illustrer chacune de ces options dans la suite.

\subsection{Recherche et remplacement avec \code{sed}}
\label{sec:texte:outils:sed}

L'utilitaire \Icode{sed}\footnote{Pour \emph{stream editor}, ou
  éditeur de flux de texte. Comme \code{grep}, \code{sed} tire son
  origine de l'éditeur \icode{ed}.} %
est en quelque sorte un éditeur de texte qui opère sur un texte une
seule ligne à la fois et de manière non-interactive. (Vous pourriez
objecter que cela ne correspond en rien à l'idée que l'on se fait d'un
éditeur de texte, mais il n'est reste pas moins que le programme
effectue des tâches d'édition sur du texte.) L'éventail des
traitements que \icode{sed} peut appliquer à un texte est très vaste,
mais la syntaxe des commandes qu'il faut entrer pour y arriver est
particulièrement ésotérique\footnote{%
  Jugez-en: la commande pour supprimer l'une de deux lignes blanches
  consécutives dans un texte est \code{N;/\string^\bs n\$/D;P;D;}.}. %
Nous nous attarderons donc à une seule commande de \icode{sed}, celle
qui permet de rechercher et de remplacer à l'intérieur d'un texte. La
syntaxe de cette commande est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
s/\meta{motif}/\meta{remplacement}/\meta{modificateur}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \code{s} est le nom de la commande \icode{sed} qui sert à
  rechercher et remplacer.
\item \index{motif}\meta{motif} est une \index{expression
    régulière}expression régulière qui définit le texte à rechercher.
\item \meta{remplacement} est le texte qui sert à remplacer le texte
  qui correspond à \meta{motif}.
\item \meta{modificateur} est un symbole qui permet de modifier le
  comportement de la commande; nous utiliserons uniquement le
  modificateur \code{g} (pour «global») qui indique de remplacer
  toutes les correspondances de \meta{motif} sur une ligne, et non
  seulement la première.
\item «\code{/}» est un symbole qui sert à délimiter les différentes
  parties de la commande; n'importe quel symbole (qui ne se trouve pas
  autrement dans la commande) fait l'affaire, mais «\code{/}» est le
  symbole le plus couramment utilisé.
\end{itemize}

La commande de remplacement est fournie en argument à \icode{sed}
entre guillemets (simples ou doubles). L'utilitaire lit ensuite
l'entrée standard ou une liste de fichiers ligne par ligne, puis
retourne sur la sortie standard le texte modifié (sans modifier le
fichier d'origine).

Les trois exemples ci-dessous permettent de faire les changements
suivants dans le texte du fichier \code{chanson.txt}, dans l'ordre:
remplacer «Oh» par «Ah»; remplacer «mm» par «MM»; remplacer toutes les
occurrences de «promets» sur une ligne par «jure». (J'ai abrégé les
sorties des commandes pour économiser de l'espace.)
\begin{Schunk}
\begin{Verbatim}
$ sed 's/Oh/Ah/' chanson.txt
Ah comme il est lourd
Le temps qui s'appelle hier
...
\end{Verbatim}
\end{Schunk} %$

\begin{Schunk}
\begin{Verbatim}
$ sed 's/mm/MM/' chanson.txt
Oh coMMe il est lourd
Le temps qui s'appelle hier
...
Mes bras désolés
Rampent coMMe des chiens
...
Gave-moi de ton amour
Pour shiMMer l'Univers
...
\end{Verbatim}
\end{Schunk} %$

\begin{Schunk}
\begin{Verbatim}
$ sed 's/promets/jure/g' chanson.txt
...
Dans ma tête il est pour toi
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Rampent comme des chiens
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Voudrait que tu deviennes
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Il manque la manière
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Pour shimmer l'Univers
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Nos plus beaux accidents
Je jure, je jure que
la journée qui s'en vient est flambant neuve
\end{Verbatim}
\end{Schunk} %$

Il n'est pas tout à fait exact de dire que \icode{sed} traite une
seule ligne à la fois. En effet, il est également possible d'appliquer
des commandes sur un intervalle de lignes par le biais d'une mémoire
tampon (\emph{hold space}). Nous n'aurons pas recours à la mémoire
tampon de \icode{sed} dans le présent ouvrage.

\warningbox{Il existe plusieurs versions différentes de \icode{grep},
  \icode{sed} et \icode{awk}, parfois avec des différences
  importantes, surtout dans le cas de \code{sed}. Les versions sous
  Linux, \index{MSYS2}MSYS2 et \index{Git~Bash}Git~Bash sont
  généralement celles du \link{https://www.gnu.org/}{projet GNU}. Dans
  macOS, elles proviennent de
  \link{https://en.wikipedia.org/wiki/Berkeley_Software_Distribution}{BSD}.
  J'ai tâché de fournir ici des expressions universelles qui
  fonctionnent dans ces deux principales variantes.}

\section{Expressions régulières}
\label{sec:texte:regex}

Tel que mentionné dans l'introduction de ce chapitre, une
\index{expression régulière}expression régulière, ou expression
rationnelle, est un langage, muni d'une syntaxe précise, qui permet de
décrire un ensemble de chaines de caractères possibles. Vous avez
rencontré quelques expressions régulières très simples et intuitives à
la section précédente. Ainsi, l'expression régulière \regex{chat}
correspond à \chaine{\matches{chat}}, mais aussi à
\chaine{\matches{chat}s}, \chaine{\matches{chat}on} ou
\chaine{a\matches{chat}}. Nous verrons dans la suite comment
restreindre l'expression au seul mot «chat».

Cette section propose une introduction au langage des expressions
régulières. Il existe une multitude de tutoriels et de documents de
référence sur le sujet dans Internet et sous forme de livre. Pour vous
accompagner dans l'atteinte des objectifs d'apprentissage mentionnés
au début du chapitre, je me suis inspiré de l'excellent
\link{https://developer.apple.com/library/content/documentation/OpenSource/Conceptual/ShellScripting/}{\emph{Shell
    Scripting Primer}} de la bibliothèque pour développeurs de Apple
\citep{Apple:shellprimer}. Si vous souhaitez étudier les expressions
régulières vraiment en profondeur, je vous recommande l'ouvrage
classique de \citet{Friedl:regex:2006}.

\subsection{Types d'expressions régulières}
\label{sec:texte:regex:types}

Avant d'aller plus loin, vous devez savoir qu'il existe trois grands
types d'\index{expression régulière}expressions régulières: les
\index{expression régulière!basique}expressions régulières basiques ou
classiques (\emph{Basic Regular Expressions}, \index{BRE}BRE), les
\index{expression régulière!étendue}expressions régulières étendues
(\emph{Extended Regular Expressions}, \index{ERE}ERE) et les
\index{expression régulière!Perl}expressions régulières de Perl
(\emph{Perl Compatible Regular Expressions}, \index{PCRE}PCRE). Les
utilitaires \icode{grep} et \icode{sed} utilisent les expressions
régulières basiques par défaut.

Voici les principales différences entre les \index{expression
  régulière!basique}expressions régulières basiques et
\index{expression régulière!étendue}étendues. Si ce qui suit n'est pas
tout à fait clair à la première lecture, ça le deviendra dès la
prochaine section lorsque nous entamerons l'étude des opérateurs des
expressions régulières.
\begin{itemize}
\item Dans les expressions régulières étendues, les symboles
  «\icode[regex]{+}» et «\icode[regex]{?}» sont des opérateurs de
  répétition. Dans les expressions régulières basiques, ce sont des
  caractères ordinaires et il n'existe aucun équivalent pour leur
  fonctionnalité respective.
\item Dans les expressions régulières étendues, le symbole
  \index{{"|}@\code{\textbar} (regex)}«\code{\textbar}» est un
  opérateur de choix entre plusieurs possibilités. Dans les
  expressions régulières basiques, c'est un caractère ordinaire et il
  n'existe aucun équivalent pour sa fonctionnalité.
\item Dans les expressions régulières étendues, les parenthèses
  «\icode[regex]{(~)}» et les accolades «\icode[regex]{\{~\}}» sont,
  respectivement, des opérateurs de regroupement et de quantificateur
  borné. Dans les expressions régulières basiques, ce sont des
  caractères ordinaires et il faut les précéder du caractère
  d'échappement «\code{\bs}» pour les convertir en opérateurs.
\end{itemize}

Dans la suite, lorsqu'il existe une différence entre les expressions
régulières basiques et les expressions régulières étendues, nous
utiliserons toujours ces dernières. Pour indiquer à \icode{grep} et à
\icode{sed} d'utiliser la syntaxe des \index{expression
  régulière!étendue}expressions régulières étendues, il suffit de leur
ajouter l'option \code{-E} mentionnée à la
\autoref{sec:texte:outils:grep}.

Dans le premier exemple ci-dessous, le motif \regex{chien|chat} est
interprété par \icode{grep} comme une \index{expression régulière
  basique}expression régulière basique dans laquelle le symbole
«\code{|}» est un caractère comme les autres. Comme le fichier
\code{chanson.txt} ne contient pas la chaine \chaine{chien|chat}, le
motif ne correspond à aucune ligne. Dans le second exemple
\icode{grep} est invoqué avec l'option \code{-E} et, par conséquent,
le motif est interprété comme une expression régulière étendue qui
signifie plutôt: \chaine{chien} \emph{ou} \chaine{chat}.
<<echo=FALSE>>=
exec("grep", c("'chien|chat'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("-E", "'chien|chat'", "chanson.txt"))
@

\tipbox{Pour effacer tout doute, n'hésitez pas à simplement utiliser
  toujours \icode{grep} et \icode{sed} avec l'option \code{-E}. La
  plupart des systèmes fournissent d'ailleurs un utilitaire
  \Icode{egrep} en tous points équivalent à \code{grep -E}.}

\subsection{Syntaxe de base}
\label{sec:texte:regex:syntaxe}

Comme mentionné précédemment, une \index{expression
  régulière}expression régulière est une suite de caractères
typographiques qui décrit une chaine de texte. Elle est composée de
caractères littéraux (dont la «valeur» correspond au symbole lui-même)
et de caractères spéciaux qui font office d'opérateurs\footnote{%
  Les opérateurs ou caractères spéciaux des expressions régulières
  sont aussi parfois appelés \emph{métacaractères}.}. %
La syntaxe obéit à quelques règles fondamentales en définitive assez
simples.
\begin{enumerate}
\item Un caractère littéral correspond à la \emph{première} occurrence
  de ce caractère dans la chaine de texte. Par exemple, le motif
  \regex{a} correspond à \chaine{G\matches{a}ve-moi de ton amour}. Que
  la lettre se trouve à l'intérieur d'un mot n'a pas d'importance.
\item Une expression régulière peut être formée par
  \index{concaténation}concaténation de deux ou plusieurs expressions
  régulières. Elle correspond alors à toute chaine de texte qui
  correspond aux sous-expressions. Autrement dit, les composantes
  d'une expression régulière sont par défaut reliées par une clause
  «et». Dans l'exemple précédent, le motif \regex{am} correspond à
  \chaine{Gave-moi de ton \matches{am}our}.
\item Une douzaine d'opérateurs permettent de rechercher dans une
  chaine de texte autre chose que des caractères littéraux.
\end{enumerate}

Vous pouvez visualiser le texte auquel un motif correspond à l'aide
d'un testeur d'expressions régulières en ligne\footnote{%
  Recherchez \emph{regular expression tester} pour en obtenir une
  liste et choisissez votre favori.}, %
ou encore simplement en remplaçant les correspondances par du texte
quelconque avec \icode{sed}. Je vous laisse exécuter les deux
commandes ci-dessous et en étudier attentivement les résultats.
<<echo=FALSE>>=
exec("sed", c("'s/a/!/'", "chanson.txt"), eval = FALSE)
@
<<echo=FALSE>>=
exec("sed", c("'s/am/--/'", "chanson.txt"), eval = FALSE)
@

Le \autoref{tab:texte:operateurs} présente les opérateurs des
expressions régulières étendues. Dans la suite, nous allons
graduellement les intégrer dans les expressions régulières afin de
sans cesse augmenter l'éventail des motifs disponibles.

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.1}
  \caption{Principaux opérateurs des expressions régulières étendues}
  \label{tab:texte:operateurs}
  \begin{tabular}{cp{9cm}}
    \toprule
    Opérateur  & Fonction \\
    \midrule
    \index{{"|}@\code{\textbar} (regex)}\code{\textbar} & alternance
                                                          («ou») \\
    \index{\string^@\code{\string^} (regex)}\code{\string^} & début de la ligne;
                                                négation (à
                                                l'intérieur d'une
                                                classe) \\
    \index{\string$@\code{\$} (regex)}\code{\$} & fin de la ligne \\
    \icode[regex]{.} & caractère de remplacement \\
    \icode[regex]{*} & zéro, une ou plusieurs occurrences \\
    \icode[regex]{?} & zéro ou une occurrence \\
    \icode[regex]{+} & une ou plusieurs occurrences \\
    \icode[regex]{(~)} & groupe de caractères \\
    \icode[regex]{[~]} & classe de caractères \\
    \icode[regex]{\{~\}} & quantificateur du nombre d'occurrences \\
    \index{\string\@\code{\bs} (regex)}\code{\bs} & caractère d'échappement \\
    \bottomrule
  \end{tabular}
\end{table} %$

\importantbox{L'espace est un «caractère» comme les autres dans les
  expressions régulières. Le motif \regex{e} correspond donc à
  \chaine{Gav\matches{e}-moi de ton amour}, alors que le motif
  \regex{e\aspace} correspond plutôt à \chaine{Gave-moi
    d\matches{e~}ton amour}.}

\subsection{Caractères de remplacement, de répétition et d'échappement}
\label{sec:texte:regex:wildcards}

Nous avons établi que l'un des principes de base des expressions
régulière est qu'un caractère littéral correspond à lui-même dans un
motif. Ce qu'il nous manque pour augmenter considérablement l'éventail
des motifs disponibles, c'est une façon de signifier «n'importe quel
caractère» et «n'importe quelle suite de caractères». C'est le rôle du
caractère de remplacement et des opérateurs de répétition.

Dans les expressions régulières, le point «\Icode[regex]{.}» est le
\index{caractere de remplacement@caractère de remplacement}%
\index{wildcard@\emph{wildcard character}|see{caractère de
    remplacement}}caractère de remplacement (\emph{wildcard
  character}). Par exemple, le motif \regex{le.} correspond à
\chaine{le} suivi d'un caractère quelconque, \emph{y compris
  l'espace}. Par conséquent, tant \chaine{\matches{les}} que
\chaine{\matches{len}t} ou \chaine{el\matches{le~}mange} correspondent
à ce motif, mais pas \chaine{belle} placé en fin de ligne.

Effectuons une autre recherche dans le fichier \code{chanson.txt}: les
lignes contenant un mot se terminant par \chaine{ou} et une lettre
quelconque. Nous allons délimiter un mot en supposant que la chaine
recherchée est suivie d'une espace --- ce qui a pour effet d'exclure
les mots situés en fin de vers. Le motif approprié pour la recherche
est \regex{ou.\aspace}.
<<echo=FALSE>>=
exec("grep", c("'ou. '", "chanson.txt"))
@

Affichons, à l'aide de l'option \code{-o} de \icode{grep}, la portion
de chaque ligne qui correspond au motif dans l'exemple précédent.
<<echo=FALSE>>=
exec("grep", c("-o", "'ou. '", "chanson.txt"))
@

Les \index{operateur de repetition@opérateur de répétition}opérateurs
de répétition (ou de quantification), quant à eux, permettent de
décrire des suites de caractères. Comme le montre le
\autoref{tab:texte:operateurs}, il existe quatre opérateurs de
répétition dans les expressions régulières (étendues): les caractères
réservés «\icode[regex]{*}», «\icode[regex]{?}» et «\icode[regex]{+}»,
ainsi que les accolades «\icode[regex]{\{~\}}».

L'opérateur «\Icode[regex]{*}» signifie: «ce qui précède, zéro ou
plusieurs fois». Ainsi le motif \regex{a*b} correspond, entre autres,
aux chaines \chaine{\matches{b}}, \chaine{\matches{ab}} ou
\chaine{\matches{aaab}}. C'est le seul opérateur de répétition aussi
pris en charge par les expressions régulières basiques.

L'opérateur «\Icode[regex]{?}» signifie: «ce qui précède, zéro ou une
fois». Le motif \regex{a?b} correspond donc aux chaines
\chaine{\matches{b}} et \chaine{\matches{ab}}, mais à aucune variante
contenant des répétitions de la lettre \chaine{a}.

Quant à l'opérateur «\Icode[regex]{+}», il signifie: «ce qui précède,
une ou plusieurs fois». Ainsi le motif \regex{a+b} correspond aux
chaines \chaine{\matches{ab}} ou \chaine{\matches{aaab}}, mais pas à
\chaine{b}.

Combinés avec le caractère de remplacement, les trois opérateurs de
répétition ci-dessus permettent de décrire des chaines de caractères
très générales puisque l'opération «n'importe quel caractère» s'en
trouve repétée autant de fois que nécessaire. Ce sont les combinaisons
d'opérateurs les plus utilisées dans les expressions régulières.
\begin{ttscript}{\regex{mm}}
\item[\regex{.*}] correspond à une chaine de caractères quelconques de
  longueur arbitraire, y compris zéro.
\item[\regex{.?}] correspond à aucun ou un seul caractère quelconque.
\item[\regex{.+}] correspond à une chaine de caractères quelconques
  longue d'au moins un caractère; équivalent à \regex{..*}\,.
\end{ttscript}
Comparez attentivement les résultats des deux exemples ci-dessous.
<<echo=FALSE>>=
exec("grep", c("-E", "'Le .*e'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("-E", "'Le .?e'", "chanson.txt"))
@

Enfin, les accolades «\Icode[regex]{\{~\}}» font office de
quantificateurs bornés, c'est-à-dire qu'elles permettent de spécifier
le nombre minimal de répétitions \emph{requises} et, de manière
optionnelle, le nombre maximal de répétitions \emph{permises}. Il
existe trois manières de les utiliser. (Dans ce qui suit, $n$ et $m$
sont des entiers et $m > n$.)
\begin{ttscript}{\code{\{$n$,$m$\}}}
\item[\code{\{$n$\}}] répète ce qui précède exactement
  $n$ fois.
\item[\code{\{$n$,$m$\}}] répète ce qui précède au moins $n$ fois et
  jusqu'à $m$ fois.
\item[\code{\{$n$,\}}] répète ce qui précède au moins $n$ fois.
\end{ttscript}
Les opérateurs «\icode[regex]{*}», «\icode[regex]{?}» et
«\icode[regex]{+}» sont donc simplement des raccourcis pour, dans
l'ordre, \code{\{0,\}}, \code{\{0,1\}} et \code{\{1,\}}. Le
\autoref{tab:texte:accolades} fournit des exemples de correspondances
pour chaque variante des accolades.

\begin{table}
  \centering
  \caption{Comparaison des trois variantes des quantificateurs bornés}
  \label{tab:texte:accolades}
  \begin{tabular}{*{7}{l}}
    \toprule
    Motif & \multicolumn{6}{c}{Correspondances} \\
    \midrule
    \regex{ah\{2\}}   & \chaine{ah} & \chaine{\matches{ahh}} & \chaine{\matches{ahh}h} & \chaine{\matches{ahh}hh} & \chaine{\matches{ahh}hhh} & \chaine{\matches{ahh}hhhh} \\ \addlinespace[6pt]
    \regex{ah\{2,4\}} & \chaine{ah} & \chaine{\matches{ahh}} & \chaine{\matches{ahhh}} & \chaine{\matches{ahhhh}} & \chaine{\matches{ahhhh}h} & \chaine{\matches{ahhhh}hh} \\ \addlinespace[6pt]
    \regex{ah\{2,\}}  & \chaine{ah} & \chaine{\matches{ahh}} & \chaine{\matches{ahhh}} & \chaine{\matches{ahhhh}} & \chaine{\matches{ahhhhh}} & \chaine{\matches{ahhhhhh}} \\
    \bottomrule
  \end{tabular}
\end{table}

\tipbox{Les quantificateurs des expressions régulières sont par défaut
  gloutons (\emph{greedy}), c'est-à-dire qu'ils trouvent la plus
  longue chaine possible en accord avec un motif. Par exemple, le
  motif \regex{J.+e} correspond à \chaine{\matches{Je le connais
      bie}n}, et non seulement à \chaine{\matches{Je le} connais
    bien}. Sachez qu'il existe aussi des quantificateurs non gloutons.
  Vous pourrez les rechercher lorsque vous souhaiterez restreindre la
  portée d'un quantificateur à la plus petite chaine possible --- et
  ça va arriver.}

\subsection{Caractère d'échappement}
\label{sec:texte:escape}

Si les caractères «\code{*}», «\code{?}», «\code{+}», «\code{\{}» et
«\code{\}}» ont une signification particulière dans les expressions
régulières, comment alors rechercher ces caractères dans du texte?
C'est là qu'entre en jeu le \index{caractere d'echappement@caractère
  d'échappement}caractère d'échappement «\Index{\string\@\code{\bs}
  (regex)}\bs». Lorsqu'il précède un symbole, le caractère
d'échappement désactive la signification spéciale de ce symbole. Par
exemple, le motif \regex{\bs.} trouve un accord avec le caractère
«\chaine{.}». Pour rechercher un nom de fichier long d'un à huit
caractères et suivi d'une extension \code{.txt}, un motif
approprié\footnote{%
  Cet exemple très simplifié ne tient pas compte des éventuelles
  règles de validité d'un nom de fichier.} %
serait donc: \regex{.\{1,8\}\bs.txt}\,.

\subsection{Marqueurs de position}
\label{sec:texte:regex:marqueurs}

Les expressions régulières comportent deux marqueurs de position qui
permettent de fixer une condition pour qu'un motif trouve un accord
dans une chaine de caractères: le
\index{caret|see{\code{\string^} (regex)}}caret (ou accent circonflexe)
\index{\string^@\code{\string^} (regex)}«\code{\string^}» et le signe
de dollar \index{\string$@\code{\$} (regex)}«\code{\$}». Ils
identifient respectivement le début et la fin d'une ligne de texte.

Par exemple, la première commande ci-dessous identifie uniquement les
lignes qui contiennent \chaine{la} en début de ligne, alors que la
seconde retient seulement les lignes qui contiennent \chaine{que} en
fin de ligne. (Il est laissé en exercice de comparer avec les
résultats sans les marqueurs de position.)
<<echo=FALSE>>=
exec("grep", c("'^la'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'que$'", "chanson.txt"))
@

Combien de lignes de \code{chanson.txt} débutent par \chaine{la}?
C'est un travail pour \icode{grep} muni de l'option \code{-c}.
<<echo=FALSE>>=
exec("grep", c("-c", "'^la'", "chanson.txt"))
@

Observez maintenant le motif particulier \regex{\string^\$} et prenez
une minute pour déterminer à quoi il correspond.

Vous avez trouvé?

Le motif décrit un début de ligne suivi immédiatement d'une fin de
ligne, soit\dots\ une ligne blanche! Ce motif est surtout utile
lorsque combiné avec l'option \code{-v} de \icode{grep} qui permet
d'inverser les résultats. Ainsi, la commande suivante retourne toutes
les lignes du fichier \code{chanson.txt} qui ne sont \emph{pas} vides.
Autrement dit, la commande supprime les lignes blanches du fichier.
(Question d'économiser de l'espace en ces pages, je vous laisse le
soin d'en faire la vérification.)
<<echo=FALSE>>=
exec("grep", c("-v", "'^$'", "chanson.txt"), eval = FALSE)
@

\subsection{Classes de caractères}
\label{sec:texte:regex:classes}

La rectification de l'orthographe du français --- ou
\link{http://www.nouvelleorthographe.info}{nouvelle orthographe} --- a
mené à la disparition de l'accent circonflexe sur les lettres \emph{i}
et \emph{u}: «chaine» plutôt que «chaîne», «disparaitre» plutôt que
«disparaître», «bruler» plutôt que «brûler», etc.\ Si vous devez
rechercher l'une ou l'autre graphie dans un texte, vous souhaiterez
pouvoir les décrire toutes les deux à l'aide d'une seule expression
régulière. C'est le rôle des opérateurs «\Icode[regex]{[~]}» qui
définissent ce que l'on appelle une \index{classe de caracteres@classe
  de caractères}\emph{classe de caractères}. Par exemple,
\regex{cha[iî]ne} correspond à la fois à \matches{chaine} et à
\matches{chaîne}.

Rappelez-vous la seconde règle fondamentale de la syntaxe des expressions
régulières énoncée à la \autoref{sec:texte:regex:syntaxe}: il y a un
«et» implicite entre les composantes d'une expression régulière. À
l'intérieur d'une classe de caractères, c'est l'inverse: les
composantes de la classe sont reliées par un «ou».

Voici un autre exemple pour lequel les classes de caractères sont
souvent utilisées: permettre qu'un mot débute par une majuscule ou une
minuscule.
<<echo=FALSE>>=
exec("grep", c("'[Mm]ême'", "chanson.txt"))
@

Une classe peut contenir autant de caractères que vous le souhaitez.
Par exemple, \regex{[123456]} trouve une correspondance avec n'importe
lequel des entiers de 1 à 6. Question de simplifier la composition de
longues listes de caractères, le tiret «\Icode[regex]{-}» a une
signification particulière lorsqu'il est employé à l'intérieur d'une
classe: il définit une plage de caractères. Ainsi, \regex{[1-6]} est
équivalent à l'exemple précédent. Les plages les plus fréquemment
employées sont les suivantes.
\begin{ttscript}{\regex{[abc]}}
\item[\regex{[0-9]}] les entiers de 0 à 9.
\item[\regex{[a-z]}] les lettres minuscules de a à z, sans les lettres
  accentuées.
\item[\regex{[A-Z]}] les lettres majuscules de A à Z, sans les lettres
  accentuées.
\end{ttscript}

Je dois immédiatement apporter une précision à ce qui précède: le
\index{-@\code{-} (regex)}tiret devient un opérateur à l'intérieur
d'une classe de caractères seulement lorsqu'il est employé
\emph{ailleurs que comme premier caractère} de la classe. Comme il ne
saurait définir une plage en se trouvant au début de la classe, il
conserve alors son rôle de caractère littéral. Cela permet d'inclure
le tiret lui-même dans une classe de caractères: le motif \regex{-A-F}
recherche le tiret en plus des lettres majuscules de A à F.

Lorsque le caret %
\index{\string^@\code{\string^} (regex)}«\code{\string^}» suit
immédiatement le crochet ouvrant d'une classe, la signification de
celle-ci est renversée pour correspondre à tous les caractères qui ne
se trouvent \emph{pas} dans la classe. Par exemple, le motif
\regex{[\string^aeiouy]} correspond à toute consonne, ce qui est plus
simple que de dresser la liste des vingt lettres. L'expression
ci-dessous permet, quant à elle, d'identifier dans le fichier
\code{chanson.txt} les occurrences de \chaine{ou} qui se sont suivies
ni de la lettre \chaine{r}, ni de la lettre \chaine{s}.
<<echo=FALSE>>=
exec("grep", c("'ou[^rs]'", "chanson.txt"))
@

\tipbox{Comme vous pouvez le voir, les classes de caractères
  comportent en quelque sorte leur propre syntaxe et leurs opérateurs
  spécifiques. Il s'avère simplement que certains symboles --- en
  particulier «\code{\string^}» --- jouent un rôle différent à
  l'intérieur et à l'extérieur des classes de caractères.}

Il y aurait encore une foule de petits détails à couvrir au sujet des
classes de caractères, mais pour les fins de cet ouvrage je me
contenterai de traiter brièvement des classes prédéfinies.\footnote{%
  J'ai tenté de contourner une source possible de confusion dans la
  terminologie anglaise relative aux classes de caractères. Alors que
  plusieurs auteurs les nomment tout simplement \emph{character
    class}, la norme POSIX --- déjà abordée au \autoref{chap:donnees}
  lorsqu'il s'agissait de la représentation des dates --- réserve
  cette expression aux classes prédéfinies. Une classe de caractères
  telle que généralement entendue est plutôt nommée \emph{bracket
    expression}. Prenez garde à cette nuance si vous consultez de la
  documentation en anglais.} %
Celles-ci peuvent s'avérer particulièrement utiles pour travailler
avec des lettres accentuées ou des caractères invisibles. La liste des
classes prédéfinies varie beaucoup d'un système d'expressions
régulières à un autre. Je fournis au \autoref{tab:texte:POSIXclasses}
les classes prédéfinies de ce qui constitue généralement le
dénominateur commun, soit la norme \index{POSIX}POSIX.

\begin{table}
  \centering
  \caption{Classes de caractères prédéfinies de la norme POSIX}
  \label{tab:texte:POSIXclasses}
  \begin{tabularx}{1.0\linewidth}{lX}
    \toprule
    Nom & Signification \\
    \midrule
    \code{[:alnum:]} & caractères alphabétiques et numériques \\
    \code{[:alpha:]} & caractères alphabétiques selon les paramètres
                       régionaux en vigueur \\
    \code{[:blank:]} & espace et tabulation \\
    \code{[:cntrl:]} & caractères de contrôle \\
    \code{[:digit:]} & caractères numériques \\
    \code{[:graph:]} & caractères visibles (tout sauf les espaces et les caractères de contrôle) \\
    \code{[:lower:]} & minuscules \\
    \code{[:print:]} & caractères et espaces visibles \\
    \code{[:punct:]} & ponctuations et symboles \\
    \code{[:space:]} & tous les caractères d'espacement, y compris les sauts de ligne \\
    \code{[:upper:]} & majuscules \\
    \code{[:xdigit:]} & caractères numériques hexadécimaux (0--9, a--f, A--Z) \\
    \bottomrule
  \end{tabularx}
\end{table}

\importantbox{Les crochets font partie intégrante du nom des classes
  prédéfinies. Comme nous utilisons celles-ci dans une classe de
  caractères, il faut dédoubler les crochets. Par exemple, le motif
  pour rechercher un caractère numérique à l'aide d'une classe
  prédéfinie est \regex{[[:digit:]]}\,, alors que celui pour exclure
  toute lettre majuscule est \regex{[\string^[:upper:]]}\,.}

\subsection{Alternance}
\label{sec:texte:regex:alternance}

Nous arrivons à l'un des derniers opérateurs du
\autoref{tab:texte:operateurs}: le symbole %
\Index{{"|}@\code{\textbar} (regex)}«\code{\textbar}» qui représente
l'alternance, ou le choix, entre deux sous-expressions d'une
expression régulière. Par exemple, tel que déjà mentionné à la
\autoref{sec:texte:regex:types}, le motif \regex{chien|chat}
correspond à \chaine{\matches{chien}} ou \chaine{\matches{chat}}.
Voici un autre exemple ayant recours à notre fichier
\code{chanson.txt}.\footnote{%
  Rappelons que le caractère «\code{\textbar}» n'est un opérateur que
  dans les expressions régulières étendues, ce qui nous oblige à
  utiliser l'option \code{-E} dans \icode{grep} et \icode{sed}.}
<<echo=FALSE>>=
exec("grep", c("-E", "'mouvement|fatigue'", "chanson.txt"))
@

Retournons à notre exemple \regex{cha[iî]ne} de la
\autoref{sec:texte:regex:classes}. Nous pouvons réécrire le motif
ainsi: \regex{chaine|chaîne}\,, ou encore \regex{cha(i|î)ne}. Dans ce
dernier cas, nous devons avoir recours aux parenthèses --- sur
lesquelles nous élaborerons à la section suivante --- afin de limiter
la portée de l'alternance. Attention, toutefois: \regex{cha[i|î]ne}
n'est pas ce que nous voulons, car «\code{\textbar}» est un caractère
littéral à l'intérieur d'une classe de caractères.

À ce stade, vous devez faire la distinction entre les concepts
d'alternance et de classe de caractère. La classe de caractère ne
trouve des correspondances qu'avec \emph{un seul caractère} à
l'intérieur de la classe. En revanche, chaque possibilité d'une
alternance étant une expression régulière en soi, cette opération peut
décrire une quantité de texte de longueur quelconque.

Terminons cette section avec un exemple de substitution de texte qui
regroupe plusieurs concepts. Supposons que l'on souhaite remplacer les
mots \emph{mouvement} et \emph{fatigue} dans «La journée qui s'en
vient est flambant neuve» par \emph{pendule} (un choix complètement
arbitraire). Le mot étant masculin, il faut également modifier le
déterminant. Voici quatre commandes \icode{sed} pour effectuer le
traitement. Analysez ces commandes attentivement et essayez
d'identifier leurs différences, s'il y en a. Nous y reviendrons plus
loin.
%% les commandes sont trop longues et l'insfrastructure de la fonction
%% 'exec' ne permet pas de les couper; j'inclus néanmoins les
%% commandes dans des blocs de code afin de valider qu'elles
%% fonctionnent correctement
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's/le mouvement|la fatigue/le pendule/' \
chanson.txt
<<echo=FALSE, results=hide>>=
exec("sed", c("-E", "'s/le mouvement|la fatigue/le pendule/'", "chanson.txt"))
@
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's/l[e|a] (mouvement|fatigue)/le pendule/' \
chanson.txt
<<echo=FALSE, results=hide>>=
exec("sed", c("-E", "'s/l[e|a] (mouvement|fatigue)/le pendule/'", "chanson.txt"))
@
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's/le|la mouvement|fatigue/le pendule/' \
chanson.txt
<<echo=FALSE, results=hide>>=
exec("sed", c("-E", "'s/le|la mouvement|fatigue/le pendule/'", "chanson.txt"))
@
\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's/(le|la) (mouvement|fatigue)/le pendule/' \
chanson.txt
<<echo=FALSE, results=hide>>=
exec("sed", c("-E", "'s/(le|la) (mouvement|fatigue)/le pendule/'", "chanson.txt"))
@
\end{Verbatim}
\end{Schunk}

\subsection{Groupes}
\label{sec:texte:regex:groupes}

Les parenthèses \Icode[regex]{(~)} sont des opérateurs de regroupement
dans les expressions régulières étendues. Elles ont trois rôles
principaux. Nous avons vu le premier à la section précédente, soit
de limiter la portée de l'opérateur d'alternance %
\index{{"|}@\code{\textbar} (regex)}«\code{\textbar}».

Nous pouvons également utiliser les parenthèses pour créer un
\index{groupe de caractères}%
\index{groupe|see{\code{(~)} (regex)}}%
groupe de caractères auquel sera appliqué un des opérateurs de
répétition de la \autoref{sec:texte:regex:wildcards}. Cela permet de
répéter autre chose qu'un caractère seul. Par exemple, le motif
\regex{(co)\{2\}} permet d'identifier dans un dictionnaire
français\footnote{%
  Comme, par exemple, les
  \link{https://extensions.libreoffice.org/extensions/dictionnaires-francais/}{dictionnaires
    français} de la suite bureautique Libre~Office.} %
des mots comme \chaine{\matches{coco}n}, \chaine{\matches{coco}tier}
ou \chaine{ro\matches{coco}}.

Enfin, les parenthèses permettent de créer des \index{groupe de
  capture}groupes de capture numérotés. C'est une fonctionnalité à
laquelle on a principalement recours avec \icode{sed}. Le texte qui
correspond à un motif entre parenthèses est «capturé» --- ou mémorisé
--- et devient disponible pour être réutilisé dans le texte de
substitution sous un numéro: \code{\bs1} pour le premier groupe,
\code{\bs2} pour le second groupe, etc.

Clarifions le tout par un exemple. Tous les vers du fichier
\code{chanson.txt} qui débutent par \chaine{Le} comptent exactement
quatre mots après ce déterminant.
<<echo=FALSE>>=
exec("grep", c("'^Le'", "chanson.txt"))
@

Amusons-nous à créer des nouveaux vers en changeant l'ordre des mots.
Pour ce faire, nous allons créer trois groupes: les deux mots qui
suivent immédiatement \chaine{Le}; l'avant-dernier mot du vers; le
dernier mot du vers. Le motif pour capturer ces trois groupes est
\regex{Le (.*) (.*) (.*)}\,. Rappelez-vous: les opérateurs de
répétition sont gloutons, donc le premier groupe capture deux mots
pour ensuite laisser un mot à chacun des deux autres groupes.
Confirmons d'abord le contenu de chacun des groupes.
\begin{Schunk}
\begin{Verbatim}
$ grep '^Le' chanson.txt | \
sed -E 's/Le (.*) (.*) (.*)/Premier groupe: \1/'
<<echo=FALSE, results=tex>>=
exec("grep", c("'^Le'", "chanson.txt", "| sed -E 's/Le (.*) (.*) (.*)/Premier groupe: \\1/'"), echo = FALSE)
@

\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ grep '^Le' chanson.txt | \
sed -E 's/Le (.*) (.*) (.*)/Deuxième groupe: \2/'
<<echo=FALSE, results=tex>>=
exec("grep", c("'^Le'", "chanson.txt", "| sed -E 's/Le (.*) (.*) (.*)/Deuxième groupe: \\2/'"), echo = FALSE)
@

\end{Verbatim}
\end{Schunk}
\begin{Schunk}
\begin{Verbatim}
$ grep '^Le' chanson.txt | \
sed -E 's/Le (.*) (.*) (.*)/Troisième groupe: \3/'
<<echo=FALSE, results=tex>>=
exec("grep", c("'^Le'", "chanson.txt", "| sed -E 's/Le (.*) (.*) (.*)/Troisième groupe: \\3/'"), echo = FALSE)
@

\end{Verbatim}
\end{Schunk}

Nous sommes maintenant prêts à changer l'ordre des mots en réutilisant
tous les groupes dans la chaine de substitution.
\begin{Schunk}
\begin{Verbatim}
$ grep '^Le' chanson.txt | \
sed -E 's/Le (.*) (.*) (.*)/Le \2 \3 \1/'
<<echo=FALSE, results=tex>>=
exec("grep", c("'^Le'", "chanson.txt", "| sed -E 's/Le (.*) (.*) (.*)/Le \\2 \\3 \\1/'"), echo = FALSE)
@

\end{Verbatim}
\end{Schunk}

Terminons cette très longue section sur les expressions régulières en
revenant, comme promis, sur les quatre commandes de substitution de
mots de la fin de la \autoref{sec:texte:regex:alternance}.
\begin{itemize}
\item La première commande effectue le traitement désiré, de surcroit
  avec la syntaxe la plus simple. Le motif trouve des correspondances
  avec \chaine{\matches{le mouvement}} ou avec \chaine{\matches{la
      fatigue}} et le texte est remplacé par \chaine{le pendule}.
\item Il faut lire le motif de la seconde commande ainsi: «\chaine{l}
  suivi de \chaine{a} ou de \chaine{e}, suivi d'une espace, suivi de
  \chaine{mouvement} ou de \chaine{fatigue}». Cela correpond bien au
  texte que nous voulons remplacer par \chaine{le pendule}. Cependant,
  à la différence de la première variante, le motif correspond aussi à
  \chaine{\matches{la mouvement}} et à \chaine{\matches{le fatigue}}.
  C'est sans conséquence ici.
\item La troisième commande n'effectue pas le traitement attendu. En
  l'absence de parenthèses pour limiter la portée de l'opérateur %
  \index{{"|}@\code{\textbar} (regex)}«\code{\textbar}», le motif
  correspond à \chaine{\matches{le}} ou à \chaine{\matches{la
      mouvement}} ou à \chaine{\matches{fatigue}}. Cette commande
  remplacerait toutes les occurrences de \chaine{le} dans le texte de
  la chanson --- y compris dans \chaine{Frôle} --- par la chaine
  \chaine{le pendule}. Ce n'est certainement pas ce que nous voulons!
\item Par l'utilisation de parenthèses dans le motif, la quatrième
  commande vient corriger la troisième. Elle est fonctionnellement
  équivalente à la seconde commande.
\end{itemize}




\section{Traitement de texte divisé en champs avec \code{awk}}
\label{sec:texte:awk}

Noms des créateurs -> Kernighan -> syntaxe similaire au C. Véritable couteau suisse, souvent plus simple que sed, surtout s'il faut effectuer des opérations sur plusieurs lignes du texte à traiter. Caractéristique principale demeure le fait de séparer automatiquement une ligne de texte en champs et de faciliter les opérations sur ceux-ci.

\section{Fonctions internes utiles}
\label{sec:texte:internes}

Cette section présente quelques unes seulement des fonctions internes
qu'offre R pour rechercher et remplacer du texte à l'aide
d'expressions régulières. Consultez la rubrique d'aide (commune) de
n'importe laquelle de celles-ci pour connaitre l'ensemble des
fonctions disponibles et les détails concernant leur fonctionnement.
Vous trouverez également dans la rubrique d'aide de nombreux exemples
d'utilisation additionnels.

Les exemples de cette section utilisent le vecteur \icode{state.name}
fourni avec R et qui contient les noms des cinquante États américains.
<<echo=FALSE>>=
op <- options(width=55)                 # trois colonnes
@
<<echo=TRUE>>=
state.name
@
<<echo=FALSE>>=
options(op)                             # rétablir défaut
@

\warningbox{Rappelons qu'en R un vecteur de mode \icode{character} peut
  contenir plusieurs chaines de caractères. Les fonctions ci-dessous
  effectuent leur traitement sur chacune des chaines d'un vecteur.}

\begin{ttscript}{regexpr}
\item[\code{grep}] \index{grep@\code{grep} (R)|bfhyperpage} recherche
  d'une expression régulière dans un vecteur de chaines de caractères.
<<echo=TRUE>>=
grep("na$", state.name)
grep("na$", state.name, value = TRUE)
@
\item[\Icode{regexpr}] comme \index{grep@\code{grep} (R)}grep, mais
  avec des informations additionnelles sur la position et la longueur
  des appariements dans les résultats.
<<echo=TRUE>>=
regexpr("na$", state.name)
@
\item[\Icode{sub}] recherche une expression régulière dans un vecteur
  de chaines de caractères et remplace uniquement la première
  occurence dans chaque chaine par une autre chaine.
<<echo=TRUE>>=
sub("i", "*", state.name)
@
\item[\Icode{gsub}] comme \icode{sub}, mais remplace toutes les
  occurences dans chaque chaine par une autre chaine.
<<echo=TRUE>>=
gsub("i", "*", state.name)
@
\end{ttscript}

\tipbox{Plusieurs langages de programmation contiennent des
  utilitaires \code{grep}, \code{sub} et \code{gsub}. Par exemple,
  dans \icode{awk} des fonctions \code{sub} et \code{gsub} permettent
  d'effectuer des remplacements à l'intérieur des champs.}


\section{Exemples additionnels}
\label{sec:texte:exemples}

Exceptionnellement, je présente les exemples additionnels de ce
chapitre en texte normal plutôt que sous forme de fichier de script.

Les exemples ci-dessous utilisent des fichiers distribués avec le
présent document dans l'archive \code{programmer-avec-r.zip}.
Assurez-vous d'avoir extrait les fichiers de l'archive quelque part
sur votre disque et notez bien cet endroit: vous en aurez besoin dans
un instant.

Vous devez entrer les expressions ci-dessous à une ligne de commande
du \index{Terminal}Terminal sous macOS, ou de \index{Git~Bash}Git~Bash
ou MSYS sous Windows.

\importantbox{L'espace horizontal étant compté dans un document en
  format PDF, il est parfois nécessaire de scinder une commande sur
  deux lignes ou plus. Pour ces cas, j'ai inséré le symbole de
  continuation de ligne «\bs» de Bash à la fin des lignes. Vous pouvez
  ainsi copier les commandes directement du document et les coller
  dans une ligne de commande. Le symbole {\bs} ne fait \emph{pas}
  partie des commandes.}

En premier lieu, déplacez, à l'aide de la commande \icode{cd},
l'invite de commande dans le répertoire où vous avez extrait les
fichiers de l'archive.

Comme premier exemple, dressons la liste de toutes les utilisations de
la fonction \code{matrix} dans les fichiers d'exemples. C'est un
travail pour l'utilitaire \icode{grep}.
\begin{Schunk}
\begin{Verbatim}
$ grep matrix *.R
\end{Verbatim}
\end{Schunk}

L'option \code{-l} de \icode{grep} permet de limiter les résultats à
la liste des fichiers contenant au moins une utilisation de
\code{matrix}.
\begin{Schunk}
\begin{Verbatim}
$ grep -l matrix *.R
\end{Verbatim}
\end{Schunk}

Pour connaitre les fichiers d'exemples dans lesquels apparaissent les
objets \code{letters} et \code{LETTERS}, nous devons rechercher sans
égard à la casse pour attraper les deux cas.
\begin{Schunk}
\begin{Verbatim}
$ grep -i letters *.R
\end{Verbatim}
\end{Schunk}

Allons-y maintenant d'une expression régulière plus élaborée pour
trouver toutes les utilisations de la fonction \code{g} dans les
fichiers d'exemples, c'est-à-dire la chaine \code{g(} précédée d'au
moins une espace ou en début de ligne.
\begin{Schunk}
\begin{Verbatim}
$ grep -E '( |^)g\(' *.R
\end{Verbatim}
\end{Schunk}

Tel que mentionné à la \autoref{sec:texte:outils}, la fonction
\icode{sed} sert surtout pour rechercher et remplacer dans un fichier,
et ce, ligne par ligne par défaut. Remplaçons les symboles de
commentaires triples «\code{\#\#\#}» en début de ligne (à la Emacs) dans
le fichier \code{pratiques.R} par un symbole unique «\code{\#}» (à
la RStudio). Pour faire bonne mesure, plaçons le résultat dans un
nouveau fichier \code{pratiques-new.R} à l'aide de l'opérateur de
redirection Unix \index{>@\code{>} (Unix)}«\code{>}».
\begin{Schunk}
\begin{Verbatim}
$ sed 's/^###/#/' pratiques.R > pratiques-new.R
\end{Verbatim}
\end{Schunk}

Le programme \icode{awk} est particulièrement utile pour traiter des
fichiers dont les lignes sont séparées en «champs», comme des colonnes
de données, par exemple. Or, le présent document est justement livré
avec le fichier \code{100metres.data} qui contient la liste des 31
meilleurs temps enregistrés au 100~mètres homme entre 1964 et 2005
(voir l'\autoref{ex:tri:100metres}).
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data
\end{Verbatim}
\end{Schunk}

Effectuons dans un premier temps l'extraction des temps des records
(second champ). La première commande utilise un transfert de données
du programme \icode{cat} vers \icode{awk} avec le tuyau Unix
\index{{"|}@\code{\textbar} (tuyau Unix)} «\code{\textbar}», alors que
la seconde, plus usuelle et tout à fait équivalente, emploie un
fichier en entrée.
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data | awk '{ print $2 }'
$ awk '{ print $2 }' 100metres.data
\end{Verbatim}
\end{Schunk}

L'inversion des deux colonnes du fichier est simple à réaliser avec
\icode{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $2, $1 }' 100metres.data
\end{Verbatim}
\end{Schunk}

Les colonnes du fichier \code{100metres.data} sont séparées par une
espace. Remplaçons ces espaces par des virgules pour convertir le
fichier en format CSV. Je fournis deux solutions, avec \icode{awk} et avec
\icode{sed}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $1","$2 }' 100metres.data
$ sed 's/ /,/' 100metres.data
\end{Verbatim}
\end{Schunk}

Changeons maintenant le format de la date du format
\link{https://fr.wikipedia.org/wiki/ISO_8601}{ISO~8601} aaaa-mm-qq
vers le format américain qq/mm/aa. D'abord une solution avec
\icode{awk}. En premier lieu, nous devons changer le séparateur de
champs de \code{awk} (l'espace par défaut) pour l'espace et le tiret.
Ainsi, \code{awk} va non seulement séparer les deux colonnes du
fichier, mais aussi les champs de la date. Ensuite, nous replaçons les
champs dans l'ordre voulu avec les bons séparateurs. La fonction
\index{substr@\code{substr} (awk)}\code{substr} de \code{awk} permet
de sélectionner une partie d'une chaine de caractères
\citep[section~9.1.3]{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk 'BEGIN { FS = "[ -]" } \
       { print $2"/"$3"/"substr($1, 3), $4 }' \
       100metres.data
\end{Verbatim}
\end{Schunk}

La solution avec \icode{sed} maintenant, qui repose non pas sur des
champs détectés automatiquement, mais plutôt sur la recherche et le
remplacement d'expressions régulières. Nous recherchons l'expression
régulière suivante en capturant chaque élément trouvé (sauf les
tirets): les nombres 19 ou 20; deux chiffres; un tiret; deux chiffres;
un tiret; deux chiffres; tout le reste de la ligne. Nous replaçons
ensuite les éléments capturés dans l'ordre souhaité avec des barres
obliques \code{/} entre les éléments de dates. Comme le symbole
\code{/} est utilisé dans la chaine de sortie, il faut utiliser un
autre symbole pour séparer les champs de la commande \code{sed}. J'ai
utilisé le symbole «\verb|~|» ici.
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's~(19|20)([0-9]{2})-([0-9]{2})-([0-9]{2})(.*)~'\
'\3/\4/\2\5~' 100metres.data
\end{Verbatim}
\end{Schunk}

Amusons-nous maintenant avec le fichier \code{NEWS} qui contient
l'historique des versions du document. La commande suivante dresse la
liste des numéros de versions.
\begin{Schunk}
\begin{Verbatim}
$ grep '^# [[:digit:]]' NEWS
$ grep -E '^# [[:digit:]]' NEWS
\end{Verbatim}
\end{Schunk}

Un dernier exemple plus avancé. Nous souhaitons extraire du fichier
\code{NEWS} les notes de mise à jour de la plus récente version. Si
vous examinez le fichier, vous constaterez que les notes de mise à
jour relatives à une version donnée débutent toujours à une ligne
marqué par %
\verb*|# |. %
Le meilleur outil pour effectuer des opérations sur plusieurs lignes
d'un fichier est \icode{awk}, tel que mentionné à la
\autoref{sec:texte:outils}.

L'idée, ici, consiste à avoir recours à une variable dite d'«état».
Avant qu'elle ne soit explicitement définie, la valeur de cette
variable est $0$ (faux). Lorsque la chaine marquant le début des notes
d'une version est trouvée, on donne une valeur de $1$ (vrai) à la
variable, puis l'on affiche les lignes jusqu'à ce que l'on rencontre
une nouvelle ligne débutant par %
\verb*|# |, %
moment où cesse le traitement du fichier.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state == 1 { print }' NEWS
\end{Verbatim}
\end{Schunk}

Nous pouvons écrire la commande ci-dessus de manière légèrement plus
compacte. En effet, écrire \code{state == 1} pour tester que la
variable \code{state} est vraie n'est pas nécessaire dans la mesure où
il est sous-entendu que l'expression qui précède l'action dans une
commande \icode{awk} est un test conditionnel et que \code{awk} traite
la valeur
$1$ comme vraie. De plus, la commande \code{print} est implicite avec
\code{awk}. Il n'est donc pas nécessaire de la demander explicitement.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state' NEWS
\end{Verbatim}
\end{Schunk}

\notebox{Les opérations de composition du présent document, de
  publication dans GitLab et de mise à jour de la page web sont
  entièrement automatisées à l'aide de
  \link{https://fr.wikipedia.org/wiki/Make}{\code{make}}, un autre de
  ces outils standards sur les systèmes Unix. Vous pouvez retrouver
  une variante un peu plus élaborée de la commande \code{awk}
  ci-dessus dans la règle \code{create-release} du fichier de
  configuration \code{Makefile} qui se trouve dans le
  \link{\reposurl}{code source} du document. Jetez-y un coup d'œil!}


\section{Exercices}
\label{sec:texte:exercices}

\Opensolutionfile{solutions}[solutions-texte]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:texte}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:texte}}

\end{Filesave}

\begin{exercice}
  Données BIXI:
  - déterminer si une station sur rue Unetelle
  - déterminer comment identifier ligne des titres de colonnes
  - sélectionner seulement certaines locations
\end{exercice}

\begin{exercice}
  Dans chacun des cas ci-dessous, déterminer à laquelle ou auxquelles
  des chaines de caractères correspond l'expression régulière donnée.
  Les symboles \verb=/= ne servent qu'à délimiter le début et la fin
  des expressions régulières. Ne pas tenir compte des espaces avant ou
  après les chaines.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/extra_regexps.html}.}
  \begin{enumerate}
    \setlength{\multicolsep}{2pt}
  \item \verb~/a(ab)*a/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abababa~
      \item \verb~aaba~
      \item \verb~aabbaa~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~aba~
      \item \verb~aabababa~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/ab+c?/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~ac~
      \item \verb~abbb~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~bbc~
      \item \verb~abcc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/a.[bc]+/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~abbbbbbbb~
      \item \verb~azc~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~abcbcbcbc~
      \item \verb~ac~
      \item \verb~asccbbbbcbcccc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/abc|xyz/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~xyz~
      \item \verb~abc|xyz~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z]+[\.\?!]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~battle!~
      \item \verb~Hot~
      \item \verb~green~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~swamping.~
      \item \verb~jump up.~
      \item \verb~undulate?~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~is.?~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-zA-Z]*[^,]=/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~Butt=~
      \item \verb~BotHEr,=~
      \item \verb~Ample~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~FIdDlE7h=~
      \item \verb~Brittle =~
      \item \verb~Other.=~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z][\.\?!]\s+[A-Z]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~A. B~
      \item \verb~c! d~
      \item \verb~e f~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~g. H~
      \item \verb~i? J~
      \item \verb~k L~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/<[^>]+>/~
    \begin{enumerate}[1)]
      \begin{multicols}{2}
      \item \verb~<an xml tag>~
      \item \verb~<opentag> <closetag>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~</closetag>~
      \item \verb~<>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~<with attribute=”77”>~
      \end{multicols}
    \end{enumerate}
  \end{enumerate}

  \begin{sol}
    \begin{enumerate}
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de zéro, une ou plusieurs occurrences des
      lettres minuscules «\verb=ab=», suivies de la lettre minuscule
      «\verb=b=». Les choix 2 et 5 satisfont ces conditions.
    \item L'expression régulière identifie la lettre
      «\verb=a=», suivie d'au moins une occurrence de la lettre
      minuscule «\verb=b=», suivie de zéro ou une occurrence de la
      lettre minuscule «\verb=c=». Les choix 1 et 3 satisfont ces
      conditions.
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de n'importe quel caractère (incluant les
      lettres «\verb=b=» et «\verb=c=»), suivi d'au moins une
      occurrence des lettres minuscules «\verb=b=» ou «\verb=c=». Les
      choix 1, 2, 3, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie les suites de lettres
      minuscules «\verb=abc=» ou «\verb=xyz=». Les choix 1 et 2
      satisfont la condition. Le troisième choix n'est pas valide
      puisque l'expression n'identifie pas le symbole «\verb=|=».
    \item L'expression régulière identifie au moins une lettre
      minuscule (à l'exclusion de tout autre symbole), suivie de l'un
      ou l'autre des symboles «\verb=.=», «\verb=?=», «\verb=!=» (sans
      répétition). Les choix 1, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie zéro, une ou plusieurs
      lettres minuscules ou majuscule (mais aucun autre symbole),
      suivies de tout caractère autre qu'une virgule, suivi du symbole
      «\verb|=|». Les choix 1, 5 et 6 satisfont ces conditions.
    \item L'expression régulière identifie une lettre minuscule,
      suivie de l'un ou l'autre des symboles «\verb=.=», «\verb=?=»,
      «\verb=!=» (sans répétition), suivi d'au moins une espace,
      suivie d'une lettre majuscule. Les choix 4 et 5 satisfont ces
      conditions.
    \item L'expression régulière identifie le symbole «\verb=<=»,
      suivi d'au moins un symbole autre que «\verb=>=», suivi du symbole
      «\verb=>=». Les choix 1, 3 et 5 satisfont ces conditions. Dans
      le choix 2, tant \verb~<opentag>~ que \verb~<closetag>~
      satisfont la condition, mais pas les deux ensemble.
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui correspond à tous les mots de
  la liste de gauche, ci-dessous, mais à aucun des mots de la liste de
  droite.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/cgi/ex1.cgi}.}
  \begin{center}
    \begin{minipage}[t]{0.3\linewidth}
      pit \\
      spot \\
      spate \\
      slap two \\
      respite
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      pt \\
      Pot \\
      peat \\
      part
    \end{minipage}
  \end{center}
  \begin{sol}
    L'expression doit identifier la lettre minuscule «\verb=p=»
    précédée ou non d'une ou de plusieurs lettres (ou symboles, ce n'est
    pas spécifié), suivie d'une (et une seule) lettre ou d'une espace,
    de la lettre «\verb=t=» et, enfin, de zéro ou de plusieurs
    lettres. Il y a assurément plusieurs réponses valides. En voici
    une: \verb=/.*p[a-z ]t.*/=.
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui permet de vérifier la validité
  d'un code postal canadien dans un formulaire électronique. Ne pas
  tenir compte des règles précises de composition d'un code postal,
  mais bien seulement qu'il s'agit d'une suite de six caractères
  alternant entre une lettre et un chiffre. Les lettres peuvent être
  fournies en majuscule ou en minuscule et l'espace entre le troisième
  et le quatrième symbole peut être présent ou non.
  \begin{sol}
    L'expression \verb=[a-zA-z][0-9][a-zA-z]\s?[0-9][a-zA-z][0-9]=
    convient si l'on ne permet que zéro ou une espace entre les deux
    blocs. S'il n'y a pas de limite au nombre d'espaces, remplacer
    «\verb=?=» par «\verb=*=».
  \end{sol}
\end{exercice}

\begin{exercice}
  Écrire une commande \code{sed} permettant de changer le séparateur
  décimal dans les temps du fichier \code{100metres.data} pour une
  virgule.
  \begin{sol}
    \code{sed} est l'outil idéal pour de tels traitements simples à
    effectuer ligne par ligne.
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data
\end{Verbatim}
    \end{Schunk}
    Pour placer le fichier modifié dans, disons,
    \code{100metres-dec.data}, utiliser
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data > 100metres-dec.data
\end{Verbatim}
    \end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Extraire du fichier \code{100metres.data} les informations des
    temps réalisés au mois d'aout.
  \item Extraire les informations des temps de moins de 10~secondes.
  \item Extraire les lignes du fichier satisfaisant les deux
    conditions précédentes. Vous pouvez avoir recours à l'opérateur de
    tuyau Unix \index{{"|}@\code{\textbar} (tuyau Unix)}%
    «\code{\textbar}» pour combiner les commandes des parties a) et
    b).
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item C'est un travail pour \code{grep}. La solution la plus
      simple serait:
      \begin{Schunk}
\begin{Verbatim}
$ grep '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Cependant, \code{grep} n'aime pas cette commande puisque le
      symbole \verb=-= est utilisé pour passer des options. Dans ce
      cas, il vaut mieux utiliser une option \verb=-e= pour déclarer
      explicitement à \code{grep} que ce qui suit est l'expression à
      rechercher:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Autrement, simplement ajouter quelque chose à chercher avant le tiret:
      \begin{Schunk}
\begin{Verbatim}
$ grep '.*-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Le plus simple, ici, consiste à utiliser \code{awk} puisque
      les seconds champs --- les temps --- seront automatiquement
      disponibles.
      \begin{Schunk}
\begin{Verbatim}
$ awk '$2 < 10 { print }' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Malheureusement, cette commande risque de ne pas fonctionner sur
      certains systèmes qui traitent la virgule comme le séparateur
      décimal, notamment les Mac en configuration française. Dans ce
      cas, essayer plutôt (j'ai supprimé la commande \verb={ print }=
      ci-dessous puisqu'elle est implicite):
      \begin{Schunk}
\begin{Verbatim}
$ LC_NUMERIC="en_US.UTF-8" awk '$2 < 10' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Une solution avec \code{grep} consisterait à rechercher un
      «\verb=9.=» après l'espace sur chaque ligne:
      \begin{Schunk}
\begin{Verbatim}
$ grep ' 9\.' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Nous pouvons combiner les deux commandes ainsi:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | awk '$2 < 10'
\end{Verbatim}
      \end{Schunk} %$
      ou
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | grep ' 9\.'
\end{Verbatim}
      \end{Schunk}
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Pour tous les appels à une fonction \code{f} comportant deux
  arguments dans le fichier \code{environnement.R} livré avec le
  présent document, changer le nom de la fonction pour \code{fun} et
  inverser l'ordre des deux arguments.
  \begin{sol}
    Ce traitement s'effectue bien avec \code{sed}:
    \begin{Schunk}
\begin{Verbatim}
$ sed -E 's/( |^)f\((.*), (.*)\)/fun(\3, \2)/' \
  environnement.R
\end{Verbatim}
    \end{Schunk}
    Le premier groupe \verb=( |^)= capture une espace avant \code{f}
    ou le début de la ligne.
  \end{sol}
\end{exercice}

\begin{exercice}
  Résoudre le présent exercice dans R en utilisant le vecteur interne
  de données \icode{state.name}.
  \begin{enumerate}
  \item Déterminer les positions, dans l'ordre alphabétique, des États
    dont le nom comporte deux «s» de suite.
  \item Extraire les États dont le nom comporte au moins trois fois la
    lettre «s», qu'elles soient successives ou non.
  \item Extraire les États dont le nom comporte un double «s» parmi
    les quatre premiers caractères, puis abréger leur nom après ce
    double «s» et faire suivre d'un point. Par exemple:
    «Massachusetts» devient «Mass.».
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item On utilise la fonction \icode{grep}. L'expression régulière
      est très simple dans le cas présent. Avec l'argument
      \code{value} à \code{FALSE} (la valeur par défaut), la fonction
      retourne les positions dans le vecteur des chaines de caractères
      qui correspondent à l'expression régulière. Comme le vecteur de
      noms est trié, il s'agit des valeurs demandées.
<<echo=TRUE,eval=FALSE>>=
grep("ss", state.name)
@
    \item C'est toujours un travail pour \icode{grep}, mais
      l'expression régulière est cette fois un peu plus complexe. Deux
      solutions sont proposées ci-dessous. Il faut utiliser l'argument
      \code{value = TRUE} pour obtenir les noms des États, et non
      seulement leurs positions dans \code{state.name}.
<<echo=TRUE,eval=FALSE>>=
grep("(.*s){3,}", state.name, value = TRUE)
grep(".*s.*s.*s", state.name, value = TRUE)
@
    \item Nous devons extraire les États avec \icode{grep}, puis
      utiliser \icode{sub} pour remplacer les caractères après le
      quatrième par un point. Ceci requiert de sauvegarder les
      caractères jusqu'aux deux «s» successifs pour les réutiliser
      dans la chaine de remplacement.
<<echo=TRUE,eval=FALSE>>=
sub("(^.{0,2}ss).*", "\\1.",
    grep("(^.{0,2}ss)", state.name, value = TRUE))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
