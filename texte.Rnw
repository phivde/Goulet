%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Analyse et contrôle de texte}
\label{chap:texte}

<<echo=FALSE>>=
options(width=50)

##
## Affiche une commande exécutée par le système et son résultat.
##
exec <- function(command, args, eval = TRUE)
{
    cmd <- paste("$", command, paste(args, collapse = " "))
    if (eval)
    {
        res <- system2(command, args, stdout = TRUE)
        cat(paste(cmd, paste(res, collapse = "\n"), sep = "\n"))
    }
    else
        cat(cmd)
}
@

\begin{objectifs}
\item Utiliser les expressions régulières pour décrire ou identifier
  une chaine de caractères.
\item Effectuer l'analyse et le contrôle de texte à l'aide des outils
  informatiques standards \code{grep}, \code{sed} et \code{awk}.
\item Effectuer des opérations de recherche et de remplacement de
  texte à l'aide d'expressions régulières avec les divers outils de R.
\end{objectifs}

Vous êtes-vous déjà demandé comment s'effectue la validation de
certains champs comme le code postal ou l'adresse de courrier
électronique dans les formulaires électroniques? Sûrement pas en
vérifiant si l'entrée figure dans la liste des quelques 17,5 millions
de codes postaux possibles au Canada ou, pire, parmi les milliards
d'adresse de courriel que les
\link{https://tools.ietf.org/html/rfc3696}{règles internationales}
permettent de concevoir! Non, ce qu'il faut, c'est un «langage» qui
permet de décrire \emph{comment} une chaine de caractères peut être
composée, sans toutefois en fixer la composition exacte. Un tel
langage existe: ce sont les \emph{expressions régulières} ou
expressions rationnelles.

Une \index{expression régulière}expression régulière (\emph{regular
  expression}, ou regex ou regexp) est une suite de caractères
typographiques qui décrit, selon une syntaxe précise, un ensemble de
chaines de caractères possibles
\citep{Wikipedia:Expression_reguliere}. L'expression elle-même est
souvent appelée un \Index{motif}«motif» (\emph{pattern}). Les
expressions régulières s'avèrent particulièrement utiles dans
l'analyse de données textuelles et dans le traitement de la langue
naturelle (\emph{natural language processing}, NLP), une branche
importante de l'intelligence artificielle.

Voici quelques utilisations possibles des \index{expression
  régulière}expressions régulières.
\begin{itemize}
\item Rechercher du texte pouvant contenir des variations ou des
  fautes d'orthographe comme, par exemple, «je transfert» plutôt que
  «je transfère», ou encore les multiples variations autour du verbe
  «appeler»: appel, appelle, appellent, appeler, appelez, etc.
\item Extraire les coordonnées géographiques d'un lieu (latitude et
  longitude) de l'URL d'une carte Google Maps. Par exemple, l'%
  \link{https://www.google.ca/maps/place/Universite+Laval/@46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d46.7817463!4d-71.2747424}{URL
    correspondant à la recherche «Université Laval»} est
  \begin{Schunk}
\begin{Verbatim}
https://www.google.ca/maps/place/Universite+Laval/
  @46.7817463,-71.2769311,17z/data=!3m1!4b1!4m5!3m4!
  1s0x4cb896c469ff32f9:0x15feb853bd2f8247!8m2!3d
  46.7817463!4d-71.2747424
\end{Verbatim}
  \end{Schunk}
  dont on décode que le lieu se trouve à une latitude de
  $\nombre{46,7817463}$ et à une longitude de $\nombre{-71.2769311}$
  en degrés décimaux.
\item Extraire d'une base de données les adresses se trouvant sur une
  rue ou une avenue numérotée («1{\iere} Avenue» ou «4{\ieme} Rue»).
\item Sélectionner les entrées d'une base de données qui débutent ou
  qui se terminent par un caractère spécifique.
\item Déterminer par programmation si un dépôt Git contient une
  branche autre que \code{master} en examinant le résultat de la
  commande \code{git branch}.
\item Mettre en italique tous les mots d'un texte qui se trouvent
  entre guillemets (mais pas les guillemets eux-mêmes), et ce, quels
  que soient les mots.
\end{itemize}

Un jour ou l'autre, vous aurez à traiter des chaines de caractères en
programmation ou en analyse de données. Ce jour-là, connaitre les
expressions régulières vous sauvera énormément de temps.

\begin{figure}[t]
  \centering
  \begin{minipage}{0.9\linewidth}
    \setkeys{Gin}{width=\textwidth}
    \includegraphics{images/regular_expressions} \\
    \footnotesize\sffamily%
    Tiré de \href{https://xkcd.com/208/}{XKCD.com}
  \end{minipage}
\end{figure}


\section{Conventions typographiques et texte des exemples}
\label{sec:texte:conventions}

La présentation des expressions régulières exige souvent de clairement
délimiter un \index{motif}motif et d'afficher certains caractères
invisibles, comme les espaces ou les retours à la ligne. Pour ce
chapitre, lorsque le contexte l'exige:
\begin{itemize}
\item les motifs sont encadrés de «coins» de couleur contrastante,
  comme \regex{ceci} \citep[une notation que j'emprunte
  à][]{Friedl:regex:2006};
\item les espaces sont représentées par le symbole \aspace, ce qui
  permet, par exemple, de bien discerner que le motif
  \regex{\#\aspace\aspace\aspace\aspace A} compte quatre espaces entre
  \code{\#} et \code{A};
\item le caractère de retour à la ligne (\emph{newline}) est
  représenté par {\NLsymbol} et celui de retour chariot (\emph{carriage
    return}) est représenté par \CRsymbol.
\end{itemize}

Dans les exemples, nous utiliserons le texte de la chanson «La journée
qui s'en vient est flambant neuve» de l'album \emph{Astronomie} (2012)
du groupe québécois Avec pas d'casque. Le texte est fourni avec le
présent document dans le fichier \code{chanson.txt}. Pour référence,
il est également reproduit à la \autoref{fig:texte:chanson}.

\begin{figure}
  \centering
  \lstinputlisting[frame=single,numbers=none]{chanson.txt}
  \caption{Texte de la chanson «La journée qui s'en vient est flambant
    neuve» de Avec pas d'casque}
  \label{fig:texte:chanson}
\end{figure}


\section{Outils d'analyse et de contrôle du texte}
\label{sec:texte:outils}

L'\index{expression régulière}expression régulière n'est qu'un langage
de description d'une chaine de texte. Pour exploiter ce langage, des
outils sont nécessaires. Aux fins de cet ouvrage, j'ai choisi de
concentrer notre étude sur les utilitaires Unix standards en ligne de
commande \icode{grep}, \icode{sed} et \icode{awk}. Ils font partie
intégrante des systèmes d'exploitation macOS et Linux et, sous
Windows, ils sont livrés avec les interpréteurs de commande
\index{MSYS}MSYS de \index{MSYS2}\link{https://www.msys2.org}{MSYS2}
et \index{Git~Bash}Git~Bash de
\link{https://git-scm.com/downloads}{Git for Windows}.

Il va sans dire que les utilitaires \icode{grep}, \icode{sed} et
\icode{awk} s'utilisent depuis une ligne de commande \index{Unix}Unix:
dans le \index{Terminal}Terminal sous macOS, ou dans
\index{Git~Bash}Git~Bash ou MSYS sous Windows. Si vous n'êtes pas
familier avec la ligne de commande,
\citet{Goulet:laboratoire-cli-git:2019} offre une rapide introduction
suffisante pour suivre la matière de ce chapitre. Nous reviendrons à R
à la \autoref{sec:texte:internes} lorsque nous étudierons les
fonctions internes de R aux fonctionnalités équivalentes à \code{grep}
et \code{sed}.

Comme la plupart des utilitaires Unix, \icode{grep}, \icode{sed} et
\icode{awk} prennent en entrée un flux de texte ou un ou plusieurs
fichiers en format texte brut. Ils opèrent ensuite sur cette entrée
\emph{ligne par ligne}. Le résultat du traitement est affiché à la
sortie standard (le terminal), transféré à un autre programme avec le
tuyau \index{{"|}@\code{\textbar} (tuyau Unix)} «\code{\textbar}», ou
encore redirigé vers un fichier avec l'opérateur «\code{>}». La
\autoref{fig:texte:flux-cli}, reprise de
\citet{Goulet:laboratoire-cli-git:2019} avec quelques simplifications,
illustre ce flux des données.

\begin{figure}
  \centering
  \setlength{\unitlength}{4mm}
  \small
  \begin{picture}(31.25,8.5)(-0.25,0)
    \thicklines
    \put(3,6){\makebox(0,0)[t]{\parbox{6.5\unitlength}{
          \centering{\LARGE\faStream~\faFile*[regular]} \\[4pt]
          entrée standard ou fichier}}}
    \put(6,5){\vector(1,0){3.5}}
    \put(12,6){\makebox(0,0)[t]{\parbox{6\unitlength}{
          \centering{\LARGE\faCogs} \\[4pt]
          \code{grep}, \code{sed}, \code{awk}}}}
    \put(14.75,5){\line(1,0){1.5}}
    \put(16.25,7){\line(0,-1){4}}
    \put(16.25,7){\vector(1,0){1.75}}
    \put(16.25,3){\vector(1,0){1.75}}
    \put(21,8){\makebox(0,0)[t]{\parbox{6.5\unitlength}{
          \centering{\LARGE\faStream} \\[4pt]
          erreur standard}}}
    \put(21,4){\makebox(0,0)[t]{\parbox{6\unitlength}{
          \centering{\LARGE\faStream} \\[4pt]
          sortie standard}}}
    \put(23.75,3){\vector(1,0){2.75}}
    \put(25,3.75){\makebox(0,0){\color{regex}\code{>}}}
    \put(28,4){\makebox(0,0)[t]{\parbox{4\unitlength}{
          \centering{\LARGE\faFile*[regular]} \\[4pt]
            fichier}}}
    \Line(21,0.75)(21,0)(3,0)
    \put(3,0){\vector(0,1){1.5}}
    \put(16.25,0.75){\makebox(0,0){\color{regex}\code{\textbar}}}
  \end{picture}
  \caption{Flux des données à la ligne de commande Unix}
  \label{fig:texte:flux-cli}
\end{figure}

Les outils \icode{grep}, \icode{sed} et \icode{awk} diffèrent quant au
type de traitement qu'ils peuvent effectuer.
\begin{ttscript}{grep}
\item[\code{grep}] sélectionne les lignes en entrée correspondant à
  une \index{expression régulière}expression régulière;
\item[\code{sed}] sert surtout pour rechercher et remplacer du texte;
\item[\code{awk}] permet de traiter aisément du texte séparé en
  champs, ainsi que du texte réparti sur plusieurs lignes.
\end{ttscript}

Puisque nous utiliserons les utilitaires \icode{grep} et \icode{sed} à
profusion dans la présentation sur les expressions régulières à la
\autoref{sec:texte:regex}, prenons un moment pour apprendre comment
les utiliser. L'utilitaire \icode{awk}, quant à lui, fera l'objet
de la \autoref{sec:texte:awk}.

\notebox{Dans la littérature informatique, la présentation des
  \index{expression régulière}expressions régulières s'accompagne
  généralement de celle du langage de programmation \index{Perl}Perl.
  En effet, Perl a été créé par Larry Wall en 1987 justement pour
  traiter facilement du texte. Le langage prend en charge les
  expressions régulières dans sa syntaxe même et il comporte plusieurs
  extensions aux expressions prises en charge par \icode{grep} et
  \icode{sed}. Cet ouvrage ne traite pas de \icode{Perl}.}

\subsection{Extraction de lignes avec \code{grep}}
\label{sec:texte:outils:grep}

L'utilitaire \Icode{grep}\footnote{%
  Le nom de l'utilitaire provient de la commande \code{:g/re/p} de
  l'antédiluvien éditeur de texte \icode{ed} qui permet de rechercher
  globalement (\code{g}) une expression régulière (\emph{regular
    expression}, \code{re}) et d'afficher les lignes qui correspondent
  (\emph{print}, \code{p}).} %
prend en argument une \index{expression régulière}expression
régulière, lit l'entrée standard ou une liste de fichiers ligne par
ligne, puis retourne sur la sortie standard les lignes qui contiennent
des correspondances avec l'expression régulière. C'est très utile pour
savoir si un fichier contient --- ou quels fichiers contiennent --- un
mot ou une expression, assez pour que le nom de l'utilitaire soit
devenu, en anglais, un verbe dans le %
\link{http://www.catb.org/jargon/html/G/grep.html}{jargon
  informatique} %
(\emph{to grep}).

Les trois exemples ci-dessous permettent, dans l'ordre, d'extraire du
fichier \code{chanson.txt}: le vers de la chanson qui contient le mot
«temps»; les vers qui débutent par «M»; le vers qui contient le mot
«chat» (aucun\footnote{%
  Sachez que la \link{https://youtu.be/eR_44AzYIZs}{vidéo} de la
  chanson est, elle, emplie de chatons très mignons.}).
<<echo=FALSE>>=
exec("grep", c("'temps'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'^M'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'chat'", "chanson.txt"))
@

En combinant \icode{grep} avec l'utilitaire \Icode{wc} (\emph{word
  count}), nous pouvons obtenir le nombre total de lignes, de mots et
de caractères des vers dans lesquels le mot «flambant» apparait dans
la chanson.
<<echo=FALSE>>=
exec("grep", c("'flambant'", "chanson.txt", "| wc"))
@

L'option \code{-c} de \icode{grep} donne encore plus rapidement accès
au nombre de lignes qui correspondent à l'\index{expression
  régulière}expression régulière.
<<echo=FALSE>>=
exec("grep", c("-c", "'flambant'", "chanson.txt"))
@

L'option \code{-v} de \icode{grep} permet d'inverser les résultats ou,
autrement dit, d'extraire les lignes qui ne contiennent \emph{aucune}
correspondance avec \index{expression régulière}l'expression
régulière. Par exemple, la commande ci-dessous permet d'extraire les
vers qui ne contiennent pas la lettre «e» (ce qui inclut les lignes
blanches entre les strophes).
<<echo=FALSE, strip.white=false>>=
exec("grep", c("-v", "'e'", "chanson.txt"))
@

\subsection{Recherche et remplacement avec \code{sed}}
\label{sec:texte:outils:sed}

L'utilitaire \Icode{sed}\footnote{Pour \emph{stream editor}, ou
  éditeur de flux de texte. Comme \code{grep}, \code{sed} tire son
  origine de l'éditeur \icode{ed}.} %
est en quelque sorte un éditeur de texte qui opère sur un texte une
ligne à la fois et de manière non-interactive. (Vous pourriez objecter
que cela ne correspond en rien à l'idée que l'on se fait d'un éditeur
de texte, mais il n'est reste pas moins que le programme effectue des
tâches d'édition sur du texte.) L'éventail des traitements que
\icode{sed} peut appliquer à un texte est très vaste, mais la syntaxe
des commandes qu'il faut entrer pour y arriver est particulièrement
ésotérique\footnote{%
  Jugez-en: la commande pour supprimer l'une de deux lignes blanches
  consécutives dans un texte est \code{N;/\string^\bs n\$/D;P;D;}.}. %
Nous nous attarderons donc à une seule commande de \icode{sed}, celle
qui permet de rechercher et de remplacer à l'intérieur d'un texte. La
syntaxe de cette commande est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
s/\meta{motif}/\meta{remplacement}/\meta{modificateur}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \code{s} est le nom de la commande \icode{sed} qui sert à
  rechercher et remplacer.
\item \index{motif}\meta{motif} est une \index{expression
    régulière}expression régulière qui définit le texte à rechercher.
\item \meta{remplacement} est le texte qui sert à remplacer le texte
  qui correspond à \meta{motif}.
\item \meta{modificateur} est un symbole qui permet de modifier le
  comportement de la commande; nous utiliserons uniquement le
  modificateur \code{g} (pour «global») qui indique de remplacer
  toutes les correspondances de \meta{motif} sur une ligne, et non
  seulement la première.
\item «\code{/}» est un symbole qui sert à délimiter les différentes
  parties de la commande; n'importe quel symbole (qui ne se trouve pas
  autrement dans la commande) fait l'affaire, mais «\code{/}» est le
  symbole le plus couramment utilisé.
\end{itemize}

La commande de remplacement est fournie en argument à \icode{sed}.
L'utilitaire lit ensuite l'entrée standard ou une liste de fichiers
ligne par ligne, puis retourne sur la sortie standard le texte modifié
(sans modifier le fichier d'origine).

Les trois exemples ci-dessous permettent de faire les changements
suivants dans le texte du fichier \code{chanson.txt}, dans l'ordre:
remplacer «Oh» par «Ah»; remplacer «mm» par «MM»; remplacer toutes les
occurrences de «promets» sur une ligne par «jure». (J'ai abrégé les
sorties des commandes pour économiser de l'espace.)
\begin{Schunk}
\begin{Verbatim}
$ sed 's/Oh/Ah/' chanson.txt
Ah comme il est lourd
Le temps qui s'appelle hier
...
\end{Verbatim}
\end{Schunk} %$

\begin{Schunk}
\begin{Verbatim}
$ sed 's/mm/MM/' chanson.txt
Oh coMMe il est lourd
Le temps qui s'appelle hier
...
Mes bras désolés
Rampent coMMe des chiens
...
Gave-moi de ton amour
Pour shiMMer l'Univers
...
\end{Verbatim}
\end{Schunk} %$

\begin{Schunk}
\begin{Verbatim}
$ sed 's/promets/jure/g' chanson.txt
...
Dans ma tête il est pour toi
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Rampent comme des chiens
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Voudrait que tu deviennes
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Il manque la manière
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Pour shimmer l'Univers
Je jure, je jure que
la journée qui s'en vient est flambant neuve
...
Nos plus beaux accidents
Je jure, je jure que
la journée qui s'en vient est flambant neuve
\end{Verbatim}
\end{Schunk} %$

Il n'est pas tout à fait exact de dire que \icode{sed} traite une
seule ligne à la fois. En effet, il est également possible d'appliquer
des commandes sur un intervalle de lignes par le biais d'une mémoire
tampon (\emph{hold space}). Nous n'aurons pas recours à la mémoire
tampon de \icode{sed} dans le présent ouvrage.

\warningbox{Il existe plusieurs versions différentes de \icode{grep},
  \icode{sed} et \icode{awk}, parfois avec des différences
  importantes, surtout dans le cas de \code{sed}. Les versions sous
  Linux, \index{MSYS2}MSYS2 et \index{Git~Bash}Git~Bash sont
  généralement celles du \link{https://www.gnu.org/}{projet GNU}. Dans
  macOS, elles proviennent de
  \link{https://en.wikipedia.org/wiki/Berkeley_Software_Distribution}{BSD}.
  J'ai tâché de fournir ici des expressions universelles qui
  fonctionnent dans ces deux principales variantes.}

\section{Expressions régulières}
\label{sec:texte:regex}

Tel que mentionné dans l'introduction de ce chapitre, une
\index{expression régulière}expression régulière, ou expression
rationnelle, est un langage, muni d'une syntaxe précise, qui permet de
décrire un ensemble de chaines de caractères possibles. Vous avez
rencontré quelques expressions régulières très simples et intuitives à
la section précédente. Ainsi, l'expression régulière \regex{chat}
correspond à la chaine «chat», mais aussi à «chats», «chaton» ou
«achat». Nous verrons dans la suite comment restreindre l'expression
au seul mot «chat».

Cette section propose une introduction au langage des expressions
régulières. Il existe une multitude de tutoriels et de documents de
référence sur le sujet dans Internet et sous forme de livre. Pour vous
accompagner dans l'atteinte des objectifs d'apprentissage mentionnés
au début du chapitre, je me suis inspiré de l'excellent
\link{https://developer.apple.com/library/content/documentation/OpenSource/Conceptual/ShellScripting/}{\emph{Shell
    Scripting Primer}} de la bibliothèque pour développeurs de Apple
\citep{Apple:shellprimer}. Si vous souhaitez étudier les expressions
régulières vraiment en profondeur, je vous recommande l'ouvrage
classique de \citet{Friedl:regex:2006}.

\subsection{Types d'expressions régulières}
\label{sec:texte:regex:types}

Avant d'aller plus loin, vous devez savoir qu'il existe trois grands
types d'\index{expression régulière}expressions régulières: les
\index{expression régulière!basique}expressions régulières basiques ou
classiques (\emph{Basic Regular Expressions}, \index{BRE}BRE), les
\index{expression régulière!étendue}expressions régulières étendues
(\emph{Extended Regular Expressions}, \index{ERE}ERE) et les
\index{expression régulière!Perl}expressions régulières de Perl
(\emph{Perl Compatible Regular Expressions}, \index{PCRE}PCRE). Les
utilitaires \icode{grep} et \icode{sed} utilisent les expressions
régulières basiques par défaut.

Voici les principales différences entre les \index{expression
  régulière!basique}expressions régulières basiques et
\index{expression régulière!étendue}étendues. Si ce qui suit n'est pas
tout à fait clair à la première lecture, ça le deviendra dès la
prochaine section lorsque nous entamerons l'étude des opérateurs des
expressions régulières.
\begin{itemize}
\item Dans les expressions régulières étendues, les symboles
  «\icode[regex]{+}» et «\icode[regex]{?}» sont des opérateurs de
  répétition. Dans les expressions régulières basiques, ce sont des
  caractères ordinaires et il n'existe aucun équivalent pour leur
  fonctionnalité respective.
\item Dans les expressions régulières étendues, le symbole
  \index{{"|}@\code{\textbar} (regex)}«\code{\textbar}» est un
  opérateur de choix entre plusieurs possibilités. Dans les
  expressions régulières basiques, c'est un caractère ordinaire et il
  n'existe aucun équivalent pour sa fonctionnalité.
\item Dans les expressions régulières étendues, les parenthèses
  «\icode[regex]{(~)}» et les accolades «\icode[regex]{\{~\}}» sont,
  respectivement, des opérateurs de regroupement et de quantificateur
  borné. Dans les expressions régulières basiques, ce sont des
  caractères ordinaires et il faut les précéder du caractère
  d'échappement «\code{\bs}» pour les convertir en opérateurs.
\end{itemize}

Dans la suite, lorsqu'il existe une différence entre les expressions
régulières basiques et les expressions régulières étendues, nous
utiliserons toujours ces dernières. Pour indiquer à \icode{grep} et à
\icode{sed} d'utiliser la syntaxe des \index{expression
  régulière!étendue}expressions régulières étendues, il suffit de leur
ajouter l'option \code{-E}. Dans le premier exemple ci-dessous, le
motif est une \index{expression régulière basique}expression régulière
basique qui ne reconnait aucune ligne du fichier \code{chanson.txt}
puisque le fichier ne contient pas la chaine «chien{\textbar}chat».
Dans le second exemple, en revanche, le motif est une expression
régulière étendue dans laquelle l'opérateur
«\index{{"|}@\code{\textbar} (regex)}\code{\textbar}» permet de
reconnaitre «chien» ou «chat».
<<echo=FALSE>>=
exec("grep", c("'chien|chat'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("-E", "'chien|chat'", "chanson.txt"))
@

\tipbox{Pour effacer tout doute, utilisez simplement toujours
  \icode{grep} et \icode{sed} avec l'option \code{-E}. La plupart des
  systèmes fournissent aussi un utilitaire \icode{egrep} en tous
  points équivalent à \code{grep -E}.}

\subsection{Syntaxe de base}
\label{sec:texte:regex:syntaxe}

Comme mentionné précédemment, une \index{expression
  régulière}expression régulière est une suite de caractères
typographiques qui décrit une chaine de texte. Elle est composée de
caractères littéraux (dont la «valeur» correspond au symbole lui-même)
et de caractères spéciaux qui font office d'opérateurs\footnote{%
  Les opérateurs ou caractères spéciaux des expressions régulières
  sont aussi parfois appelés \emph{métacaractères}.}. %
La syntaxe obéit à quelques règles fondamentales en définitive assez
simples.
\begin{enumerate}
\item Un caractère littéral correspond à la \emph{première} occurrence
  de ce caractère dans la chaine de texte. Par exemple, le motif
  \regex{a} correspond uniquement au «a» qui suit le «G» dans
  «Gave-moi de ton amour». Que la lettre se trouve à l'intérieur d'un
  mot n'a pas d'importance.
\item Une expression régulière peut être formée par
  \index{concaténation}concaténation de deux ou plusieurs expressions
  régulières. Elle correspond alors à toute chaine de texte qui
  correspond aux sous-expressions. Autrement dit, les composantes
  d'une expression régulière sont par défaut reliées par une clause
  «et». Pour reprendre l'exemple précédent, le motif \regex{am}
  correspond à la lettre «a» immédiatement suivie de la lettre «m»,
  soit les deux premières lettres du mot «amour».
\item Une douzaine d'opérateurs permettent de rechercher dans une
  chaine de texte autre chose que des caractères littéraux.
\end{enumerate}

Le \autoref{tab:texte:operateurs} présente les opérateurs des
expressions régulières étendues. Nous reviendrons plus en détail sur
ces opérateurs dans la suite. Entretemps, gardez en tête qu'un
opérateur s'applique uniquement à l'expression (ou la sous-expression)
qui le précède.

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.1}
  \caption{Principaux opérateurs des expressions régulières étendues}
  \label{tab:texte:operateurs}
  \begin{tabular}{cp{9cm}}
    \toprule
    Opérateur  & Fonction \\
    \midrule
    \index{{"|}@\code{\textbar} (regex)}\code{\textbar} & choix entre
                                                          deux
                                                          sous-expressions
                                                          («ou») \\
    \index{\string^@\code{\string^} (regex)}\code{\string^} & début de la ligne;
                                                négation (à
                                                l'intérieur d'une
                                                classe) \\
    \index{\string$@\code{\$} (regex)}\code{\$} & fin de la ligne \\
    \icode[regex]{.} & caractère de remplacement \\
    \icode[regex]{*} & zéro, une ou plusieurs occurrences \\
    \icode[regex]{?} & zéro ou une occurrence \\
    \icode[regex]{+} & une ou plusieurs occurrences \\
    \icode[regex]{(~)} & groupe de caractères \\
    \icode[regex]{[~]} & classe de caractères \\
    \icode[regex]{\{~\}} & quantificateur du nombre d'occurrences \\
    \index{\string\@\code{\bs} (regex)}\code{\bs} & caractère d'échappement \\
    \bottomrule
  \end{tabular}
\end{table} %$

\subsection{Caractères de remplacement et de répétition}
\label{sec:texte:regex:wildcards}

Nous avons établi que l'un des principes de base des expressions
régulière est qu'un caractère littéral correspond à lui-même dans un
motif. Ce qu'il nous manque pour augmenter considérablement l'éventail
des motifs disponibles, c'est une façon de signifier «n'importe quel
caractère». Or, c'est justement le rôle du \index{caractère de
  remplacement}\index{wildcard@\emph{wildcard character}|see{caractère
    de remplacement}}caractère de remplacement (\emph{wildcard
  character}). Dans les expressions régulières, le point
«\Icode[regex]{.}» est le caractère de remplacement.

Par exemple, le motif \regex{le.} correspond à «le» suivi d'un
caractère quelconque, \emph{y compris l'espace}. Par conséquent, tant
«les» que «lent» ou «elle mange» correspondent à ce motif. Le motif
\regex{ou. } permet, quant à lui, de rechercher les lignes du fichier
\code{chanson.txt} qui contiennent un mot situé ailleurs qu'en fin de
strophe --- puisqu'il est suivi d'une espace --- se terminant par «ou»
et une lettre.
<<echo=FALSE>>=
exec("grep", c("'ou. '", "chanson.txt"))
@

Le caractère de remplacement est généralement accompagné d'un
opérateur de répétition (ou de quantification) afin de décrire non
plus seulement «n'importe quel caractère», mais plus largement
«n'importe quelle suite de caractères». Comme le montre le
\autoref{tab:texte:operateurs}, il existe quatre opérateurs de
répétition dans les expressions régulières: les caractères réservés
«\icode[regex]{*}», «\icode[regex]{?}» et «\icode[regex]{+}», ainsi
que les accolades «\icode[regex]{\{~\}}».

L'opérateur «\Icode[regex]{*}» signifie: «ce qui précède, zéro ou
plusieurs fois». Ainsi le motif \regex{a*b} correspond, entre autres,
aux chaines de caractères «b», «ab» ou «aaab». C'est le seul opérateur
de répétition pris en charge par les expressions régulières basiques.

L'opérateur «\Icode[regex]{?}» signifie: «ce qui précède, zéro ou une
fois». Le motif \regex{a?b} correspond donc uniquement aux chaines «b»
et «ab».

Quant à l'opérateur «\Icode[regex]{+}», il signifie: «ce qui précède,
une ou plusieurs fois». Ainsi le motif \regex{a+b} correspond aux
chaines «ab» ou «aaab», mais pas à «b».

Combinés avec le caractère de remplacement, les trois opérateurs de
répétition ci-dessus permettent de décrire des chaines de caractères
très générales puisque l'opération «n'importe quel caractère» s'en
trouve repétée autant de fois que nécessaire. Ce sont les combinaisons
d'opérateurs les plus utilisées dans les expressions régulières.
\begin{itemize}
\item \regex{.*} correspond à une chaine de caractères quelconques de
  longueur arbitraire, y compris zéro.
\item \regex{.?} correspond à aucun ou un seul caractère quelconque.
\item \regex{.+} correspond à une chaine de caractères quelconques
  longue d'au moins un caractère; équivalent à \regex{..*}.
\end{itemize}
Comparez attentivement les résultats des deux exemples ci-dessous.
<<echo=FALSE>>=
exec("grep", c("-E", "'Le .*e'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("-E", "'Le .?e'", "chanson.txt"))
@

Enfin, les accolades «\Icode[regex]{\{~\}}» font office de
quantificateurs bornés, c'est-à-dire qu'elles permettent de spécifier
le nombre de répétitions souhaité. Il existe quatre manières de les
utiliser. (Dans ce qui suit, $n$ et $m$ sont des entiers.)
\begin{itemize}
\item «\code{\{$n$\}}» répète ce qui précède exactement
  $n$ fois.
\item «\code{\{$n$,$m$\}}» répète ce qui précède entre $n$ et $m$
  fois.
\item «\code{\{$n$,\}}» répète ce qui précède au moins $n$ fois.
\item «\code{\{,$m$\}}» répète ce qui précède de zéro à $m$ fois.
\end{itemize}
Les opérateurs «\icode[regex]{*}», «\icode[regex]{?}» et
«\icode[regex]{+}» sont donc simplement des raccourcis pour, dans
l'ordre, «\code{\{0,\}}», «\code{\{0,1\}}» et «\code{\{1,\}}». Le
\autoref{tab:texte:accolades} fournit des exemples de correspondances
pour chaque variante des accolades.

\begin{table}
  \centering
  \caption{Comparaison des quatre variantes des quantificateurs
    bornés}
  \label{tab:texte:accolades}
  \begin{tabular}{*{6}{l}}
    Motif & \multicolumn{5}{c}{Correspondances} \\
    \midrule
    \regex{a\{2\}}   & «aa» \\
    \regex{a\{2,4\}} & «aa» & «aaa» & «aaaa» \\
    \regex{a\{2,\}}  & «aa» & «aaa» & «aaaa» & «aaaaa» & etc. \\
    \regex{a\{,4\}}  & «»   & «a» & «aa» & «aaa» & «aaaa» \\
    \bottomrule
  \end{tabular}
\end{table}

Si les caractères «\code{*}», «\code{?}», «\code{+}», «\code{\{}» et
«\code{\}}» ont une signification particulière dans les expressions
régulières, comment alors rechercher ces caractères dans du texte?
C'est là qu'entre en jeu le caractère d'échappement «\bs». Lorsqu'il
précède un symbole, le caractère d'échappement désactive la
signification spéciale de ce symbole. Par exemple, pour rechercher un
nom de fichier long d'exactement huit caractères et suivi d'une
extension \code{.txt}, un motif approprié serait:
\regex{.\{8\}\bs.txt}.\footnote{%
  Cet exemple très simplifié ne tient pas compte des éventuelles
  règles de validité d'un nom de fichier.}

\tipbox{Les quantificateurs des expressions régulières sont par défaut
  gloutons (\emph{greedy}), c'est-à-dire qu'ils trouvent la plus
  grande chaine possible qui correspond à un motif. Par exemple, dans
  la chaine «Je le connais bien», le motif \regex{J.+e} correspond à
  «Je le connais bie», et non seulement à «Je le». Sachez qu'il existe
  aussi des quantificateurs non gloutons. Vous pourrez les rechercher
  lorsque vous souhaiterez restreindre la portée d'un quantificateur à
  la plus petite chaine possible --- et ça va arriver.}

\subsection{Marqueurs de position et drapeaux}
\label{sec:texte:regex:bol-eol}

Les marqueurs de position et les drapeaux permettent de modifier la
logique de correspondance d'une expression régulière.

En premier lieu, il existe deux marqueurs de position qui permettent
de fixer une condition pour qu'un motif trouve un accord dans une
chaine de caractères: le caret (ou accent circonflexe)
«\code{\string^}» et le signe de dollar «\code{\$}». Ils identifient
respectivement le début et la fin d'une ligne de texte.

Par exemple, la première expression ci-dessous identifie uniquement
les lignes qui contiennent «la» en début de ligne, alors que la
seconde retient seulement les lignes qui contiennent «que» en fin de
ligne\footnote{%
  Cette formulation insiste sur le fait que le motif ne retient pas
  les lignes qui contiennent «la» ou «que» ailleurs qu'en début ou en
  fin de ligne. Nous aurions aussi pu mettre l'accent sur le fait que
  la première expression retient uniquement les lignes débutant par
  «la» et la seconde, celles se terminant par «que».}. %
(Il est laissé en exercice de comparer avec les résultats sans les
marqueurs de position.)
<<echo=FALSE>>=
exec("grep", c("'^la'", "chanson.txt"))
@
<<echo=FALSE>>=
exec("grep", c("'que$'", "chanson.txt"))
@

Prenez la mesure du motif particulier suivant: \regex{\string^\$}. Il
décrit un début de ligne suivi immédiatement d'une fin de ligne,
soit\dots\ une ligne blanche! Nous verrons une utilisation de ce motif
dans un instant.

En second lieu, les drapeaux (\emph{flags}) modifient le comportement
des outils comme \icode{grep} et \icode{sed}. Le premier compte un
très grand nombre de drapeaux. Ils se présentent généralement en deux
versions: courte sous forme d'une lettre unique précédée d'un tiret et
longue sous forme d'un mot précédé de deux tirets. Vous connaissez
déjà le drapeau \code{-E} qui active les expressions régulières
étendues; sa version longue est \code{--extended-regexp}. Voici deux
autres drapeaux de \icode{grep} particulièrement utiles.

\begin{ttscript}{-o, --only-matching}
\item[\code{-v, --invert-match}] sélectionne les lignes
  qui ne correspondent \emph{pas} au motif
\item[\code{-o, --only-matching}] retourne uniquement la
  portion de la ligne qui correspond au motif
\end{ttscript}

Vous avez déjà rencontré une utilisation du drapeau \code{-v} à la fin
de la \autoref{sec:texte:outils:grep} pour identifier les strophes de
la chanson qui ne contiennent pas la lettre «e». Le drapeau est aussi
très utile lorsque combiné au motif \regex{\string^\$}: la commande
suivante supprime les lignes blanches du fichier \code{chanson.txt}.
(Question d'économiser de l'espace en ces pages, je vous laisse le
soin d'en faire la vérification.)
<<echo=FALSE>>=
exec("grep", c("-v", "'^$'", "chanson.txt"), eval = FALSE)
@

Pour illustrer le drapeau \code{-o}, reprenons un exemple de la
\autoref{sec:texte:regex:wildcards} en restreignant cette fois
l'affichage à la portion de chaque ligne qui correspond au motif.
<<echo=FALSE>>=
exec("grep", c("-o", "-E", "'Le .?e'", "chanson.txt"))
@

Du côté de l'utilitaire \icode{sed}, le seul drapeau que nous
utiliserons est le modificateur \code{g} que nous avons déjà présenté
à la \autoref{sec:texte:outils:sed}.


\subsection{Classes de caractères}
\label{sec:texte:regex:classes}





\section{Traitement de texte divisé en champs avec \code{awk}}
\label{sec:texte:awk}

Noms des créateurs -> Kernighan -> syntaxe similaire au C. Véritable couteau suisse, souvent plus simple que sed, surtout s'il faut effectuer des opérations sur plusieurs lignes du texte à traiter. Caractéristique principale demeure le fait de séparer automatiquement une ligne de texte en champs et de faciliter les opérations sur ceux-ci.

\section{Fonctions internes utiles}
\label{sec:texte:internes}

Cette section présente quelques unes seulement des fonctions internes
qu'offre R pour rechercher et remplacer du texte à l'aide
d'expressions régulières. Consultez la rubrique d'aide (commune) de
n'importe laquelle de celles-ci pour connaitre l'ensemble des
fonctions disponibles et les détails concernant leur fonctionnement.
Vous trouverez également dans la rubrique d'aide de nombreux exemples
d'utilisation additionnels.

Les exemples de cette section utilisent le vecteur \icode{state.name}
fourni avec R et qui contient les noms des cinquante États américains.
<<echo=FALSE>>=
op <- options(width=55)                 # trois colonnes
@
<<echo=TRUE>>=
state.name
@
<<echo=FALSE>>=
options(op)                             # rétablir défaut
@

\warningbox{Rappelons qu'en R un vecteur de mode \icode{character} peut
  contenir plusieurs chaines de caractères. Les fonctions ci-dessous
  effectuent leur traitement sur chacune des chaines d'un vecteur.}

\begin{ttscript}{regexpr}
\item[\code{grep}] \index{grep@\code{grep} (R)|bfhyperpage} recherche
  d'une expression régulière dans un vecteur de chaines de caractères
<<echo=TRUE>>=
grep("na$", state.name)
grep("na$", state.name, value = TRUE)
@
\item[\Icode{regexpr}] comme \index{grep@\code{grep} (R)}grep, mais
  avec des informations additionnelles sur la position et la longueur
  des appariements dans les résultats
<<echo=TRUE>>=
regexpr("na$", state.name)
@
\item[\Icode{sub}] recherche une expression régulière dans un vecteur
  de chaines de caractères et remplace uniquement la première
  occurence dans chaque chaine par une autre chaine
<<echo=TRUE>>=
sub("i", "*", state.name)
@
\item[\Icode{gsub}] comme \icode{sub}, mais remplace toutes les
  occurences dans chaque chaine par une autre chaine
<<echo=TRUE>>=
gsub("i", "*", state.name)
@
\end{ttscript}

\tipbox{Plusieurs langages de programmation contiennent des
  utilitaires \code{grep}, \code{sub} et \code{gsub}. Par exemple,
  dans \icode{awk} des fonctions \code{sub} et \code{gsub} permettent
  d'effectuer des remplacements à l'intérieur des champs.}


\section{Exemples additionnels}
\label{sec:texte:exemples}

Exceptionnellement, je présente les exemples additionnels de ce
chapitre en texte normal plutôt que sous forme de fichier de script.

Les exemples ci-dessous utilisent des fichiers distribués avec le
présent document dans l'archive \code{programmer-avec-r.zip}.
Assurez-vous d'avoir extrait les fichiers de l'archive quelque part
sur votre disque et notez bien cet endroit: vous en aurez besoin dans
un instant.

Vous devez entrer les expressions ci-dessous à une ligne de commande
du \index{Terminal}Terminal sous macOS, ou de \index{Git~Bash}Git~Bash
ou MSYS sous Windows.

\importantbox{L'espace horizontal étant compté dans un document en
  format PDF, il est parfois nécessaire de scinder une commande sur
  deux lignes ou plus. Pour ces cas, j'ai inséré le symbole de
  continuation de ligne «\bs» de Bash à la fin des lignes. Vous pouvez
  ainsi copier les commandes directement du document et les coller
  dans une ligne de commande. Le symbole {\bs} ne fait \emph{pas}
  partie des commandes.}

En premier lieu, déplacez, à l'aide de la commande \icode{cd},
l'invite de commande dans le répertoire où vous avez extrait les
fichiers de l'archive.

Comme premier exemple, dressons la liste de toutes les utilisations de
la fonction \code{matrix} dans les fichiers d'exemples. C'est un
travail pour l'utilitaire \icode{grep}.
\begin{Schunk}
\begin{Verbatim}
$ grep matrix *.R
\end{Verbatim}
\end{Schunk}

L'option \code{-l} de \icode{grep} permet de limiter les résultats à
la liste des fichiers contenant au moins une utilisation de
\code{matrix}.
\begin{Schunk}
\begin{Verbatim}
$ grep -l matrix *.R
\end{Verbatim}
\end{Schunk}

Pour connaitre les fichiers d'exemples dans lesquels apparaissent les
objets \code{letters} et \code{LETTERS}, nous devons rechercher sans
égard à la casse pour attraper les deux cas.
\begin{Schunk}
\begin{Verbatim}
$ grep -i letters *.R
\end{Verbatim}
\end{Schunk}

Allons-y maintenant d'une expression régulière plus élaborée pour
trouver toutes les utilisations de la fonction \code{g} dans les
fichiers d'exemples, c'est-à-dire la chaine \code{g(} précédée d'au
moins une espace ou en début de ligne.
\begin{Schunk}
\begin{Verbatim}
$ grep -E '( |^)g\(' *.R
\end{Verbatim}
\end{Schunk}

Tel que mentionné à la \autoref{sec:texte:outils}, la fonction
\icode{sed} sert surtout pour rechercher et remplacer dans un fichier,
et ce, ligne par ligne par défaut. Remplaçons les symboles de
commentaires triples «\code{\#\#\#}» en début de ligne (à la Emacs) dans
le fichier \code{pratiques.R} par un symbole unique «\code{\#}» (à
la RStudio). Pour faire bonne mesure, plaçons le résultat dans un
nouveau fichier \code{pratiques-new.R} à l'aide de l'opérateur de
redirection Unix \index{>@\code{>} (Unix)}«\code{>}».
\begin{Schunk}
\begin{Verbatim}
$ sed 's/^###/#/' pratiques.R > pratiques-new.R
\end{Verbatim}
\end{Schunk}

Le programme \icode{awk} est particulièrement utile pour traiter des
fichiers dont les lignes sont séparées en «champs», comme des colonnes
de données, par exemple. Or, le présent document est justement livré
avec le fichier \code{100metres.data} qui contient la liste des 31
meilleurs temps enregistrés au 100~mètres homme entre 1964 et 2005
(voir l'\autoref{ex:tri:100metres}).
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data
\end{Verbatim}
\end{Schunk}

Effectuons dans un premier temps l'extraction des temps des records
(second champ). La première commande utilise un transfert de données
du programme \icode{cat} vers \icode{awk} avec le tuyau Unix
\index{{"|}@\code{\textbar} (tuyau Unix)} «\code{\textbar}», alors que
la seconde, plus usuelle et tout à fait équivalente, emploie un
fichier en entrée.
\begin{Schunk}
\begin{Verbatim}
$ cat 100metres.data | awk '{ print $2 }'
$ awk '{ print $2 }' 100metres.data
\end{Verbatim}
\end{Schunk}

L'inversion des deux colonnes du fichier est simple à réaliser avec
\icode{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $2, $1 }' 100metres.data
\end{Verbatim}
\end{Schunk}

Les colonnes du fichier \code{100metres.data} sont séparées par une
espace. Remplaçons ces espaces par des virgules pour convertir le
fichier en format CSV. Je fournis deux solutions, avec \icode{awk} et avec
\icode{sed}.
\begin{Schunk}
\begin{Verbatim}
$ awk '{ print $1","$2 }' 100metres.data
$ sed 's/ /,/' 100metres.data
\end{Verbatim}
\end{Schunk}

Changeons maintenant le format de la date du format
\link{https://fr.wikipedia.org/wiki/ISO_8601}{ISO~8601} aaaa-mm-qq
vers le format américain qq/mm/aa. D'abord une solution avec
\icode{awk}. En premier lieu, nous devons changer le séparateur de
champs de \code{awk} (l'espace par défaut) pour l'espace et le tiret.
Ainsi, \code{awk} va non seulement séparer les deux colonnes du
fichier, mais aussi les champs de la date. Ensuite, nous replaçons les
champs dans l'ordre voulu avec les bons séparateurs. La fonction
\index{substr@\code{substr} (awk)}\code{substr} de \code{awk} permet
de sélectionner une partie d'une chaine de caractères
\citep[section~9.1.3]{awk}.
\begin{Schunk}
\begin{Verbatim}
$ awk 'BEGIN { FS = "[ -]" } \
       { print $2"/"$3"/"substr($1, 3), $4 }' \
       100metres.data
\end{Verbatim}
\end{Schunk}

La solution avec \icode{sed} maintenant, qui repose non pas sur des
champs détectés automatiquement, mais plutôt sur la recherche et le
remplacement d'expressions régulières. Nous recherchons l'expression
régulière suivante en capturant chaque élément trouvé (sauf les
tirets): les nombres 19 ou 20; deux chiffres; un tiret; deux chiffres;
un tiret; deux chiffres; tout le reste de la ligne. Nous replaçons
ensuite les éléments capturés dans l'ordre souhaité avec des barres
obliques \code{/} entre les éléments de dates. Comme le symbole
\code{/} est utilisé dans la chaine de sortie, il faut utiliser un
autre symbole pour séparer les champs de la commande \code{sed}. J'ai
utilisé le symbole «\verb|~|» ici.
\begin{Schunk}
\begin{Verbatim}
$ sed -E 's~(19|20)([0-9]{2})-([0-9]{2})-([0-9]{2})(.*)~'\
'\3/\4/\2\5~' 100metres.data
\end{Verbatim}
\end{Schunk}

Amusons-nous maintenant avec le fichier \code{NEWS} qui contient
l'historique des versions du document. La commande suivante dresse la
liste des numéros de versions.
\begin{Schunk}
\begin{Verbatim}
$ grep '^# [[:digit:]]' NEWS
$ grep -E '^# [[:digit:]]' NEWS
\end{Verbatim}
\end{Schunk}

Un dernier exemple plus avancé. Nous souhaitons extraire du fichier
\code{NEWS} les notes de mise à jour de la plus récente version. Si
vous examinez le fichier, vous constaterez que les notes de mise à
jour relatives à une version donnée débutent toujours à une ligne
marqué par %
\verb*|# |. %
Le meilleur outil pour effectuer des opérations sur plusieurs lignes
d'un fichier est \icode{awk}, tel que mentionné à la
\autoref{sec:texte:outils}.

L'idée, ici, consiste à avoir recours à une variable dite d'«état».
Avant qu'elle ne soit explicitement définie, la valeur de cette
variable est $0$ (faux). Lorsque la chaine marquant le début des notes
d'une version est trouvée, on donne une valeur de $1$ (vrai) à la
variable, puis l'on affiche les lignes jusqu'à ce que l'on rencontre
une nouvelle ligne débutant par %
\verb*|# |, %
moment où cesse le traitement du fichier.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state == 1 { print }' NEWS
\end{Verbatim}
\end{Schunk}

Nous pouvons écrire la commande ci-dessus de manière légèrement plus
compacte. En effet, écrire \code{state == 1} pour tester que la
variable \code{state} est vraie n'est pas nécessaire dans la mesure où
il est sous-entendu que l'expression qui précède l'action dans une
commande \icode{awk} est un test conditionnel et que \code{awk} traite
la valeur
$1$ comme vraie. De plus, la commande \code{print} est implicite avec
\code{awk}. Il n'est donc pas nécessaire de la demander explicitement.
\begin{Schunk}
\begin{Verbatim}
$ awk '(state == 0) && /^# / { state = 1; next } \
       (state == 1) && /^# / { exit } \
       state' NEWS
\end{Verbatim}
\end{Schunk}

\notebox{Les opérations de composition du présent document, de
  publication dans GitLab et de mise à jour de la page web sont
  entièrement automatisées à l'aide de
  \link{https://fr.wikipedia.org/wiki/Make}{\code{make}}, un autre de
  ces outils standards sur les systèmes Unix. Vous pouvez retrouver
  une variante un peu plus élaborée de la commande \code{awk}
  ci-dessus dans la règle \code{create-release} du fichier de
  configuration \code{Makefile} qui se trouve dans le
  \link{\reposurl}{code source} du document. Jetez-y un coup d'œil!}


\section{Exercices}
\label{sec:texte:exercices}

\Opensolutionfile{solutions}[solutions-texte]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:texte}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:texte}}

\end{Filesave}

\begin{exercice}
  Données BIXI:
  - déterminer si une station sur rue Unetelle
  - déterminer comment identifier ligne des titres de colonnes
  - sélectionner seulement certaines locations
\end{exercice}

\begin{exercice}
  Dans chacun des cas ci-dessous, déterminer à laquelle ou auxquelles
  des chaines de caractères correspond l'expression régulière donnée.
  Les symboles \verb=/= ne servent qu'à délimiter le début et la fin
  des expressions régulières. Ne pas tenir compte des espaces avant ou
  après les chaines.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/extra_regexps.html}.}
  \begin{enumerate}
    \setlength{\multicolsep}{2pt}
  \item \verb~/a(ab)*a/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abababa~
      \item \verb~aaba~
      \item \verb~aabbaa~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~aba~
      \item \verb~aabababa~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/ab+c?/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~ac~
      \item \verb~abbb~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~bbc~
      \item \verb~abcc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/a.[bc]+/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~abbbbbbbb~
      \item \verb~azc~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~abcbcbcbc~
      \item \verb~ac~
      \item \verb~asccbbbbcbcccc~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/abc|xyz/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~abc~
      \item \verb~xyz~
      \item \verb~abc|xyz~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z]+[\.\?!]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~battle!~
      \item \verb~Hot~
      \item \verb~green~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~swamping.~
      \item \verb~jump up.~
      \item \verb~undulate?~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~is.?~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-zA-Z]*[^,]=/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~Butt=~
      \item \verb~BotHEr,=~
      \item \verb~Ample~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~FIdDlE7h=~
      \item \verb~Brittle =~
      \item \verb~Other.=~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/[a-z][\.\?!]\s+[A-Z]/~
    \begin{enumerate}[1)]
      \begin{multicols}{3}
      \item \verb~A. B~
      \item \verb~c! d~
      \item \verb~e f~
      \end{multicols}
      \begin{multicols}{3}
      \item \verb~g. H~
      \item \verb~i? J~
      \item \verb~k L~
      \end{multicols}
    \end{enumerate}
    \pagebreak[1]
  \item \verb~/<[^>]+>/~
    \begin{enumerate}[1)]
      \begin{multicols}{2}
      \item \verb~<an xml tag>~
      \item \verb~<opentag> <closetag>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~</closetag>~
      \item \verb~<>~
      \end{multicols}
      \begin{multicols}{2}
      \item \verb~<with attribute=”77”>~
      \end{multicols}
    \end{enumerate}
  \end{enumerate}

  \begin{sol}
    \begin{enumerate}
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de zéro, une ou plusieurs occurrences des
      lettres minuscules «\verb=ab=», suivies de la lettre minuscule
      «\verb=b=». Les choix 2 et 5 satisfont ces conditions.
    \item L'expression régulière identifie la lettre
      «\verb=a=», suivie d'au moins une occurrence de la lettre
      minuscule «\verb=b=», suivie de zéro ou une occurrence de la
      lettre minuscule «\verb=c=». Les choix 1 et 3 satisfont ces
      conditions.
    \item L'expression régulière identifie la lettre minuscule
      «\verb=a=», suivie de n'importe quel caractère (incluant les
      lettres «\verb=b=» et «\verb=c=»), suivi d'au moins une
      occurrence des lettres minuscules «\verb=b=» ou «\verb=c=». Les
      choix 1, 2, 3, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie les suites de lettres
      minuscules «\verb=abc=» ou «\verb=xyz=». Les choix 1 et 2
      satisfont la condition. Le troisième choix n'est pas valide
      puisque l'expression n'identifie pas le symbole «\verb=|=».
    \item L'expression régulière identifie au moins une lettre
      minuscule (à l'exclusion de tout autre symbole), suivie de l'un
      ou l'autre des symboles «\verb=.=», «\verb=?=», «\verb=!=» (sans
      répétition). Les choix 1, 4 et 6 satisfont ces conditions.
    \item L'expression régulière identifie zéro, une ou plusieurs
      lettres minuscules ou majuscule (mais aucun autre symbole),
      suivies de tout caractère autre qu'une virgule, suivi du symbole
      «\verb|=|». Les choix 1, 5 et 6 satisfont ces conditions.
    \item L'expression régulière identifie une lettre minuscule,
      suivie de l'un ou l'autre des symboles «\verb=.=», «\verb=?=»,
      «\verb=!=» (sans répétition), suivi d'au moins une espace,
      suivie d'une lettre majuscule. Les choix 4 et 5 satisfont ces
      conditions.
    \item L'expression régulière identifie le symbole «\verb=<=»,
      suivi d'au moins un symbole autre que «\verb=>=», suivi du symbole
      «\verb=>=». Les choix 1, 3 et 5 satisfont ces conditions. Dans
      le choix 2, tant \verb~<opentag>~ que \verb~<closetag>~
      satisfont la condition, mais pas les deux ensemble.
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui correspond à tous les mots de
  la liste de gauche, ci-dessous, mais à aucun des mots de la liste de
  droite.\footnote{%
    Exercice adapté de
    \url{https://regex.sketchengine.co.uk/cgi/ex1.cgi}.}
  \begin{center}
    \begin{minipage}[t]{0.3\linewidth}
      pit \\
      spot \\
      spate \\
      slap two \\
      respite
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      pt \\
      Pot \\
      peat \\
      part
    \end{minipage}
  \end{center}
  \begin{sol}
    L'expression doit identifier la lettre minuscule «\verb=p=»
    précédée ou non d'une ou de plusieurs lettres (ou symboles, ce n'est
    pas spécifié), suivie d'une (et une seule) lettre ou d'une espace,
    de la lettre «\verb=t=» et, enfin, de zéro ou de plusieurs
    lettres. Il y a assurément plusieurs réponses valides. En voici
    une: \verb=/.*p[a-z ]t.*/=.
  \end{sol}
\end{exercice}

\begin{exercice}
  Composer une expression régulière qui permet de vérifier la validité
  d'un code postal canadien dans un formulaire électronique. Ne pas
  tenir compte des règles précises de composition d'un code postal,
  mais bien seulement qu'il s'agit d'une suite de six caractères
  alternant entre une lettre et un chiffre. Les lettres peuvent être
  fournies en majuscule ou en minuscule et l'espace entre le troisième
  et le quatrième symbole peut être présent ou non.
  \begin{sol}
    L'expression \verb=[a-zA-z][0-9][a-zA-z]\s?[0-9][a-zA-z][0-9]=
    convient si l'on ne permet que zéro ou une espace entre les deux
    blocs. S'il n'y a pas de limite au nombre d'espaces, remplacer
    «\verb=?=» par «\verb=*=».
  \end{sol}
\end{exercice}

\begin{exercice}
  Écrire une commande \code{sed} permettant de changer le séparateur
  décimal dans les temps du fichier \code{100metres.data} pour une
  virgule.
  \begin{sol}
    \code{sed} est l'outil idéal pour de tels traitements simples à
    effectuer ligne par ligne.
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data
\end{Verbatim}
    \end{Schunk}
    Pour placer le fichier modifié dans, disons,
    \code{100metres-dec.data}, utiliser
    \begin{Schunk}
\begin{Verbatim}
$ sed 's/\./,/' 100metres.data > 100metres-dec.data
\end{Verbatim}
    \end{Schunk}
  \end{sol}
\end{exercice}

\begin{exercice}
  \begin{enumerate}
  \item Extraire du fichier \code{100metres.data} les informations des
    temps réalisés au mois d'août.
  \item Extraire les informations des temps de moins de 10~secondes.
  \item Extraire les lignes du fichier satisfaisant les deux
    conditions précédentes. Vous pouvez avoir recours à l'opérateur de
    tuyau Unix \index{{"|}@\code{\textbar} (tuyau Unix)}%
    «\code{\textbar}» pour combiner les commandes des parties a) et
    b).
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item C'est un travail pour \code{grep}. La solution la plus
      simple serait:
      \begin{Schunk}
\begin{Verbatim}
$ grep '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Cependant, \code{grep} n'aime pas cette commande puisque le
      symbole \verb=-= est utilisé pour passer des options. Dans ce
      cas, il vaut mieux utiliser une option \verb=-e= pour déclarer
      explicitement à \code{grep} que ce qui suit est l'expression à
      rechercher:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
      Autrement, simplement ajouter quelque chose à chercher avant le tiret:
      \begin{Schunk}
\begin{Verbatim}
$ grep '.*-08-' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Le plus simple, ici, consiste à utiliser \code{awk} puisque
      les seconds champs --- les temps --- seront automatiquement
      disponibles.
      \begin{Schunk}
\begin{Verbatim}
$ awk '$2 < 10 { print }' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Malheureusement, cette commande risque de ne pas fonctionner sur
      certains systèmes qui traitent la virgule comme le séparateur
      décimal, notamment les Mac en configuration française. Dans ce
      cas, essayer plutôt (j'ai supprimé la commande \verb={ print }=
      ci-dessous puisqu'elle est implicite):
      \begin{Schunk}
\begin{Verbatim}
$ LC_NUMERIC="en_US.UTF-8" awk '$2 < 10' 100metres.data
\end{Verbatim}
      \end{Schunk} %$
      Une solution avec \code{grep} consisterait à rechercher un
      «\verb=9.=» après l'espace sur chaque ligne:
      \begin{Schunk}
\begin{Verbatim}
$ grep ' 9\.' 100metres.data
\end{Verbatim}
      \end{Schunk}
    \item Nous pouvons combiner les deux commandes ainsi:
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | awk '$2 < 10'
\end{Verbatim}
      \end{Schunk} %$
      ou
      \begin{Schunk}
\begin{Verbatim}
$ grep -e '-08-' 100metres.data | grep ' 9\.'
\end{Verbatim}
      \end{Schunk}
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Pour tous les appels à une fonction \code{f} comportant deux
  arguments dans le fichier \code{environnement.R} livré avec le
  présent document, changer le nom de la fonction pour \code{fun} et
  inverser l'ordre des deux arguments.
  \begin{sol}
    Ce traitement s'effectue bien avec \code{sed}:
    \begin{Schunk}
\begin{Verbatim}
$ sed -E 's/( |^)f\((.*), (.*)\)/fun(\3, \2)/' \
  environnement.R
\end{Verbatim}
    \end{Schunk}
    Le premier groupe \verb=( |^)= capture une espace avant \code{f}
    ou le début de la ligne.
  \end{sol}
\end{exercice}

\begin{exercice}
  Résoudre le présent exercice dans R en utilisant le vecteur interne
  de données \icode{state.name}.
  \begin{enumerate}
  \item Déterminer les positions, dans l'ordre alphabétique, des États
    dont le nom comporte deux «s» de suite.
  \item Extraire les États dont le nom comporte au moins trois fois la
    lettre «s», qu'elles soient successives ou non.
  \item Extraire les États dont le nom comporte un double «s» parmi
    les quatre premiers caractères, puis abréger leur nom après ce
    double «s» et faire suivre d'un point. Par exemple:
    «Massachusetts» devient «Mass.».
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item On utilise la fonction \icode{grep}. L'expression régulière
      est très simple dans le cas présent. Avec l'argument
      \code{value} à \code{FALSE} (la valeur par défaut), la fonction
      retourne les positions dans le vecteur des chaines de caractères
      qui correspondent à l'expression régulière. Comme le vecteur de
      noms est trié, il s'agit des valeurs demandées.
<<echo=TRUE,eval=FALSE>>=
grep("ss", state.name)
@
    \item C'est toujours un travail pour \icode{grep}, mais
      l'expression régulière est cette fois un peu plus complexe. Deux
      solutions sont proposées ci-dessous. Il faut utiliser l'argument
      \code{value = TRUE} pour obtenir les noms des États, et non
      seulement leurs positions dans \code{state.name}.
<<echo=TRUE,eval=FALSE>>=
grep("(.*s){3,}", state.name, value = TRUE)
grep(".*s.*s.*s", state.name, value = TRUE)
@
    \item Nous devons extraire les États avec \icode{grep}, puis
      utiliser \icode{sub} pour remplacer les caractères après le
      quatrième par un point. Ceci requiert de sauvegarder les
      caractères jusqu'aux deux «s» successifs pour les réutiliser
      dans la chaine de remplacement.
<<echo=TRUE,eval=FALSE>>=
sub("(^.{0,2}ss).*", "\\1.",
    grep("(^.{0,2}ss)", state.name, value = TRUE))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
