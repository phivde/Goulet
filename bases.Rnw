\chapter{Bases du langage R}
\label{chap:bases}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Écrire et interpréter la syntaxe et la sémantique du langage R.
\item Utiliser l'arithmétique vectorielle du langage R dans les
  calculs.
\item Créer et manipuler des vecteurs simples («atomiques»).
\item Utiliser les divers modes des vecteurs (en particulier
  \code{numeric}, \code{character} et \code{logical}) et la conversion
  automatique de l'un à l'autre.
\item Extraire des données d'un vecteur simple ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Appeler une fonction R; concevoir comment les arguments sont
  passés à la fonction et le traitement des valeurs par défaut.
\item Définir une fonction R, ses divers arguments et, le cas échéant,
  les valeurs par défaut de ceux-ci.
\item Utiliser et définir des fonctions R ayant un nombre variable
  d'arguments.
\end{objectifs}

C'est dans ce chapitre que nous débutons réellement l'apprentissage de
la programmation. Avouons-le d'entrée de jeu: notre présentation a
fortement été influencée par l'ouvrage magistral de
\cite{Sussman:scheme:1996}.

Les humains créent des programmes informatiques pour contrôler, à
l'aide d'un ensemble de règles, les processus de calcul et de
manipulation de données d'un ordinateur. Ces programmes sont rédigés
dans un langage de programmation.

Un langage est toutefois plus qu'une simple manière de transmettre des
instructions à un ordinateur, c'est aussi une façon de conceptualiser
les procédures que l'ordinateur devra effectuer. Autrement dit, le
type de langage de programmation que nous utilisons influence
directement la solution que nous proposerons à un problème --- et vice
versa. Comme nous l'avons déjà fait à la
\autoref{sec:informatique:semantique}, dressons un parallèle avec les
langues parlées et écrites: une langue ne constitue pas seulement un
moyen de transmettre une idée, mais bien une façon de concevoir le
monde. Ce n'est pas pour rien qu'il est parfois impossible de faire
passer une idée d'une langue vers une autre --- ce que l'on appelle
couramment une «expression intraduisible».

Le langage de programmation étudié ici est le R. Sa syntaxe, celle du
langage \index{S}S, s'apparente au \index{C}C. En revanche, la
sémantique de R s'inspire du paradigme de la programmation
fonctionnelle, ce qui lui confère de plus grandes affinités avec le
\index{Lisp}Lisp et \index{APL}l'APL.

Ce chapitre introduit des notions de base du langage R telles que
l'expression, l'affectation, et l'objet. Le concept de vecteur se
trouvant au cœur du langage, nous faisons une large place à la
création et à la manipulation des vecteurs. Le chapitre se termine par
la définition de fonctions.


\section{Données et procédures fondamentales}
\label{sec:bases:fondamentales}

À sa plus simple expression, la programmation est un exercice de
manipulation de \emph{données} à l'aide de \emph{procédures}. Un
langage de programmation fournit au programmeur des données et des
procédures fondamentales (ou \emph{génériques}), des manières de les
combiner pour former des éléments composés, ainsi qu'un mécanisme
d'abstraction permettant de nommer et de manipuler ces éléments
composés.

Les données fondamentales de R sont les suivantes:
\begin{itemize}
\item nombres réels: \code{0, 1, 2, 78.42, -1.39}, \dots;
\item chaines de caractères: \code{"a"}, \code{"abc"}, \dots;
\item valeurs booléennes: \Icode{TRUE}, \Icode{FALSE};
\item donnée manquante: \Icode{NA};
\item infini positif et négatif: \Icode{Inf}, \code{-Inf};
\item valeur indéterminée: \Icode{NaN};
\item «néant»: \Icode{NULL};
\item nombres complexes: \code{1 + 2i}.
\end{itemize}
La grande majorité des langages de programmation offrent les deux
premiers type de données ci-dessus. Les autres types se revèlent très
utiles pour la programmation mathématique et l'analyse de données.
Nous reviendrons sur leurs caractéristiques à la
\autoref{sec:bases:objets}.

Nous pouvons classer les procédures fondamentales en quatre grandes
catégories:
\begin{itemize}
\item arithmétique: \verb|+ - * / ^ < >= ==|, etc.;
\item logique: \verb=& | !=\,;
\item indiçage: \verb=[ ] $=\,;
\item affectation: \verb|<-|\,.
\end{itemize}
Les opérations arithmétiques sont applicables aux nombres réels ou
complexes, alors que les opérations logiques ne sont applicables
qu'aux valeurs booléennes. Nous traitons de l'opération d'affectation
en détail à la section suivante.

Le \autoref{tab:bases:operateurs} présente les opérateurs les plus
fréquemment employés en ordre décroissant de priorité des opérations.
Ils sont accompagnés d'une description succincte. Nous reviendrons sur
certains opérateurs dans les chapitres subséquents.

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.1}
\begin{tabular}{lp{8cm}}
    \toprule
    Opérateur     & Fonction \\
    \midrule
    \icode{\$} & extraction d'une liste \\ %$
    \icode{[}\, \icode{[[} & indiçage \\
    \verb|^|\index{\string^@\verb=^=|bfhyperpage} & puissance \\
    \icode{-}  & changement de signe \\
    {\NoAutoSpacing\verb|:|}\index{:@\NoAutoSpacing\verb=:=}  & génération de suites \\
    \icode{\%*\%}\, \icode{\%\%}\, \icode{\%/\%} & produit
    matriciel, modulo, division entière \\
    \icode{*}\, \icode{/} & multiplication, division \\
    \icode{+}\, \icode{-} & addition, soustraction \\
    \icode{<}\, \icode{<=}\, \icode{==}\, \icode{>=}\,
    \icode{>}\, \verb|!=|\index{"!=@\code{"!=}} & plus petit, plus petit ou égal, égal,
    plus grand ou égal, plus grand, différent de \\
    \verb=!=\index{"!@\code{"!}}  & négation logique \\
    \icode{\&}\, \icode{\&\&} & «et» logique \\
    \code{\textbar}\index{{"|}@\code{\textbar}},
    \code{\textbar\textbar}\index{{"|"|}@\code{\textbar\textbar}}    & «ou» logique \\
    \icode{->}\, \verb|->>|\index{->>@\verb=->>=|bfhyperpage} & affectation \\
    \icode{<-}\, \verb|<<-|\index{<<-@\verb=<<-=|bfhyperpage} & affectation \\
    \bottomrule
  \end{tabular}
  \caption{Principaux opérateurs du langage R, en ordre décroissant
    de priorité}
  \label{tab:bases:operateurs}
\end{table}

\tipbox{Il est utile, voire essentiel, de connaître le niveau de
  priorité des opérateurs dans les expressions R.}


\section{Commandes R}
\label{sec:bases:commandes}

Nous l'avons déjà vu, l'interaction avec l'interpréteur R se fait par
l'intermédiaire de commandes entrées à la ligne de commande. Or, toute
commande R est soit une \emph{expression}\index{expression}, soit une
\emph{affectation}\index{affectation}.

\subsection{Expression}
\label{sec:bases:commandes:expression}

Une \index{expression}expression R est une combinaison de symboles
(noms de variables) et de procedures. Toute expression a une valeur.
Le symbole d'une donnée fondamentale représente cette donnée, comme on
pourrait s'y attendre.

Lorsqu'une expression est entrée à la ligne de commande de
l'interpréteur, elle est immédiatement évaluée et le résultat est
affiché sous l'invite de commande \verb*|> | (le symbole \verb|>|
suivi d'une espace).
<<echo=TRUE>>=
42
3 + 2i
2 + 3
pi
cos(pi/4)
@

Lorsqu'une commande n'est pas syntaxiquement complète, l'invite de
commande se change en \verb*|+ | pour nous inciter à compléter la
commande.
<<echo=TRUE>>=
2 *
3
@

Il est possible de combiner plusieurs expressions ensemble pour en
faire une expression composée. Celle-ci est évaluée de gauche à
droite, à moins que des parenthèses ne viennent changer l'ordre
d'évaluation, comme en mathématiques.
<<echo=TRUE>>=
(2 + ((2 + 4 * 6) * (3 + 5 + 7)))/2
@

\subsection{Affectation}
\label{sec:bases:commandes:affectation}

Dans une affectation, une expression est évaluée, mais le résultat est
stocké dans un \emph{objet} (ou \emph{variable}) dans l'espace de
travail et rien n'est affiché à l'écran. Tel que mentionné
précédemment, le symbole d'affectation est \icode{<-}, c'est-à-dire
les deux caractères \verb|<| et \verb|-| placés obligatoirement l'un à
la suite de l'autre.
<<echo=TRUE>>=
a <- 5
a
b <- a
b
@

Pour affecter le résultat d'un calcul dans un objet et simultanément
afficher ce résultat, il suffit de placer l'affectation entre
parenthèses pour ainsi créer une nouvelle expression\footnote{%
  En fait, cela devient un appel à l'opérateur \code{"("} qui ne fait
  que retourner son argument.}.
<<echo=TRUE>>=
(a <- 2 + 3)
@

Le symbole d'affectation inversé \icode{->} existe aussi, mais il
est rarement utilisé.

\cautionbox{Évitez d'utiliser l'opérateur \,\icode{=}\, pour
  affecter une valeur à une variable. Cette pratique est susceptible
  d'engendrer de la confusion avec les constructions \code{symbole =
    valeur} dans les appels de fonction. Les règles de syntaxe de R
  commandent d'utiliser l'opérateur \code{<-} pour l'affectation,
  point.}

\subsection{Regroupement de commandes}
\label{sec:bases:commandes:regroupement}

Dans les fichiers de script ou à la ligne de commande, on sépare
généralement les commandes R les unes des autres par un retour à la
ligne. Il est également possible de séparer les commandes par un
\index{;@\code{;}}point-virgule. Employer les deux --- placer des
points-virgules à la fin de chaque ligne de code --- est considéré
comme du mauvais style, surtout dans les fichiers de script. Le
point-virgule peut être utile pour séparer deux courtes expressions ou
plus sur une même ligne. C'est le seul emploi que nous faisons du
point-virgule.
<<echo=TRUE>>=
a <- 5; a + 2
@

On peut regrouper plusieurs commandes en une seule expression en les
entourant d'accolades \Icode{\{~\}}. Le résultat du regroupement
est la valeur de la \emph{dernière} commande. Par conséquent, si le
regroupement se termine par une affectation, aucune valeur n'est
retournée ni affichée à l'écran.
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
    b
}
@
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
}
@


\section{Objets R}
\label{sec:bases:objets}

Tout dans le langage R est un objet: les variables contenant des
données, les fonctions, les opérateurs, même le symbole représentant
le nom d'un objet est lui-même un objet. Les objets possèdent au
minimum un \emph{mode} et une \emph{longueur} et certains peuvent
être dotés d'un ou de plusieurs \emph{attributs}.

\subsection{Règles pour les noms d'objets}
\label{sec:bases:objets:noms}

Les caractères permis pour les noms d'objets sont les lettres
minuscules a--z et majuscules A--Z, les chiffres 0--9, le point «.» et
le caractère de soulignement «\_». Selon l'environnement linguistique
de l'ordinateur, il peut être permis d'utiliser des lettres accentuées
dans les noms d'objet, mais nous recommandons fortement d'éviter cette
pratique qui nuit à la portabilité du code. Le nom d'un objet ne peut
débuter par un chiffre. Si le nom débute par un point, alors le second
caractère ne peut être un chiffre.

\warningbox{R est sensible à la casse, ce qui signifie que \code{foo},
  \code{Foo} et \code{FOO} sont trois objets distincts.}

Certains noms sont utilisés par le système R, aussi vaut-il mieux
éviter de les utiliser comme nom de variable ou de fonction. En
particulier, évitez:
\begin{quote}
  \code{c}, \code{q}, \code{t}, \code{C}, \code{D},
  \code{I}, \code{diff}, \code{length}, \code{mean},
  \code{pi}, \code{range}, \code{var}.
\end{quote}
De plus, certains mots sont réservés et il est interdit de les
utiliser comme nom d'objet. Les mots réservés pour le système sont:
\begin{quote}
  \code{break}, \code{else}, \code{for}, \code{function}, \code{if},
  \code{in}, \code{next}, \code{repeat}, \code{return}, \code{while}, \\
  \code{TRUE}, \code{FALSE}, \\
  \code{Inf}, \code{NA}, \code{NaN}, \code{NULL}, \\
  \verb|NA_integer_|, \verb|NA_real_|, \verb|NA_complex_|,
  \verb|NA_character_|, \\
  \code{...}, \code{..1}, \code{..2}, etc.
\end{quote}
Oui, `\code{...}' (\emph{point-point-point}) est véritablement un nom
d'objet dans R! Son usage est expliqué à la
\autoref{sec:bases:fonctions:definition}.

Les variables \code{T}\index{T@\code{T}|see{\code{TRUE}}} et
\code{F}\index{F@\code{F}|see{\code{FALSE}}} prennent par défaut les
valeurs \icode{TRUE} et \icode{FALSE}, respectivement, mais peuvent
être réaffectées.
<<echo=TRUE>>=
T
F
@
\begin{Schunk}
\begin{Sinput}
> TRUE <- 3
\end{Sinput}
\begin{Soutput}
Error in TRUE <- 3 : membre gauche de l'assignation
(do_set) incorrect
\end{Soutput}
\end{Schunk}
<<echo=TRUE>>=
(T <- 3)
@
<<echo=FALSE>>=
rm(T)
@

\tipbox{Écrivez toujour les valeurs booléennes \code{TRUE} et
  \code{FALSE} au long pour éviter des bogues difficiles à détecter.}


\subsection{Modes et types de données}
\label{sec:bases:objets:mode}

Le mode\Index{mode} prescrit ce qu'un objet peut contenir. À ce titre,
un objet ne peut avoir qu'un seul mode. Le \autoref{tab:bases:modes}
contient la liste des principaux modes disponibles en R. À chacun de
ces modes correspond une fonction du même nom servant à créer un objet
de ce mode. Le mode d'un objet est obtenu avec la fonction
\Icode{mode}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
mode(v)
@

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Mode              & Contenu de l'objet \\
    \midrule
    \icode{numeric}    & nombres réels \\
    \icode{complex}    & nombres complexes \\
    \icode{logical}    & valeurs booléennes \\
    \icode{character}  & chaines de caractères \\
    \icode{function}   & fonction \\
    \icode{list}       & liste \\
    \icode{expression} & expressions non évaluées \\
    \bottomrule
  \end{tabular}
  \caption{Modes disponibles et contenus correspondants}
  \label{tab:bases:modes}
\end{table}

Les objets de mode \code{numeric}, \code{complex},
\code{logical} et \code{character} sont des objets \emph{simples}
(\emph{atomic}) qui contiennent des données d'un seul type. En
revanche, les objets de mode \code{list} ou \code{expression} sont
des objets \emph{récursifs} qui peuvent contenir d'autres objets. Par
exemple, une liste peut contenir une ou plusieurs autres listes; nous
y reviendrons au \autoref{chap:donnees}.

\tipbox{La fonction \Icode{typeof} permet d'obtenir une description
  plus précise de la représentation interne d'un objet (c'est-à-dire
  au niveau de la mise en {\oe}uvre en C). Le mode et le type d'un
  objet sont souvent identiques.}

Plusieurs opérations --- notamment la création de vecteurs ou les
opérations arithmétiques et logiques --- entrainent ce que l'on
appelle la \emph{conversion forcée} (\emph{coercion}) d'un mode vers
un autre. Nous y revenons plus loin.


\subsection{Longueur}
\label{sec:bases:objets:longueur}

La longueur\Index{longueur} d'un objet est égale au nombre d'éléments
qu'il contient. La longueur d'un objet est obtenue avec la fonction
\Icode{length}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
length(v)
@

\tipbox{Il est permis --- et parfois utile --- de créer un objet de
  longueur nulle, c'est-à-dire un objet qui existe, mais qui est
  vide.}

Au sens R du terme, la longueur d'une chaine de caractères est
toujours $1$. Un objet de mode \code{character} doit contenir
plusieurs chaines de caractères pour que sa longueur soit supérieure à
$1$. Il faut utiliser la fonction \Icode{nchar} pour obtenir le
nombre de caractères dans une chaine.
<<echo=TRUE>>=
v1 <- "actuariat"
length(v1)
nchar(v1)
@
<<echo=TRUE>>=
v2 <- c("a", "c", "t", "u", "a", "r", "i", "a", "t")
length(v2)
nchar(v2)
@

\subsection{Valeurs spéciales}
\label{sec:bases:objets:NA_et_al}

Les objets valeur manquante (\code{NA}), infini (\code{Inf},
\code{-Inf}), valeur indéterminée (\code{NaN}) et néant (\code{NULL})
permettent de représenter de manière intuitive des quantitées souvent
utilisées dans les applications statistiques et en analyse de données.
Pour pleinement tirer profit de ces objets, il faut connaitre leurs
caractéristiques spéciales.

L'objet \code{NA} sert à représenter une donnée manquante. Chose
quelque peu surprenante, c'est un objet de mode \icode{logical}. Cependant,
\code{NA} ne peut être considéré ni \code{TRUE}, ni \code{FALSE}.
<<echo=TRUE>>=
mode(NA)
length(NA)
NA == TRUE
NA == FALSE
@
Toute opération, y compris la comparaison, impliquant la valeur
\code{NA} a comme résultat \code{NA}. Par conséquent, la valeur
\code{NA} n'est égale à aucune autre, pas même elle-même! Pour tester
si une valeur est manquante, il faut avoir recours à la fonction
\Icode{is.na}.
<<echo=TRUE>>=
x <- NA
x == NA
is.na(NA)
@

Les objets \code{Inf}, \code{-Inf} et \code{NaN} permettent de
représenter les valeurs mathématiques spéciales prévues dans la norme
IEEE~754 régissant la représentation interne des nombres dans un
ordinateur \citep{IEEE:754}. De manière intuitive, l'objet \icode{Inf}
représente $+\infty$, \code{-Inf} représente $-\infty$ et \icode{NaN}
(\emph{Not a Number}) représente une forme indéterminée du type
$\frac{0}{0}$ ou $\infty - \infty$. Les fonctions
\Icode{is.infinite}, \Icode{is.finite} et \Icode{is.nan}
fournissent des manières robuste de tester ces valeurs.
<<echo=TRUE>>=
is.infinite(1/0)
is.finite(-1/0)
is.nan(0/0)
is.nan(Inf - Inf)
@

Enfin, l'objet spécial \icode{NULL} représente «rien», ou le vide. Son
mode est \code{NULL} et sa longueur est $0$. Il est toutefois
différent d'un objet vide: un objet de longueur $0$ est un contenant
vide, alors que \code{NULL} est «pas de contenant».
<<echo=TRUE>>=
mode(NULL)
length(NULL)
1 + NULL
@
Ajouter \code{NULL} à un objet n'ajoute rien. Par ailleurs, la seule
façon de tester si un objet est \code{NULL} est avec la fonction
\Icode{is.null}.
<<echo=TRUE>>=
c(3, NULL)
x <- NULL
x == NULL
is.null(NULL)
@


\subsection{Attributs}
\label{sec:bases:objets:attributs}

Les attributs\Index{attribut} d'un objet sont des éléments
d'information additionnels attachés à cet objet. Le
\autoref{tab:attributs} fournit la liste des attributs les plus
fréquemment utilisés. À chacun des attributs du tableau correspond une
fonction du même nom servant à extraire l'attribut d'un objet.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Attribut            & Utilisation \\
    \midrule
    \icode{class}    &
    affecte le comportement d'un objet \\
    \icode{dim}      &
    dimensions\index{dimension} des matrices et tableaux \\
    \icode{dimnames} &
    étiquettes\index{etiquette@étiquette} des dimensions des matrices
    et tableaux \\
    \icode{names}    &
    étiquettes des éléments d'un objet \\
    \bottomrule
  \end{tabular}
  \caption{Attributs les plus usuels d'un objet}
  \label{tab:attributs}
\end{table}

La fonction \Icode{attributes} permet d'extraire ou de modifier la
liste des attributs d'un objet, alors que la fonction \Icode{attr}
permet de travailler sur un seul attribut à la fois. Les programmeurs
peuvent ajouter à peu près n'importe quoi à la liste des attributs
d'un objet. Par exemple, nous pourrions vouloir attacher au résultat
d'un calcul la méthode de calcul utilisée.
<<echo=TRUE>>=
x <- 3
attr(x, "methode") <- "au pif"
attributes(x)
@

L'extraction d'un attribut qui n'existe pas retourne \icode{NULL},
alors qu'à l'inverse, affecter à un attribut la valeur \code{NULL}
efface cet attribut.
<<echo=TRUE>>=
attributes(x)
dim(x)
attr(x, "methode") <- NULL
attributes(x)
@


\section{Vecteurs}
\label{sec:bases:vecteurs}

En R, à toutes fins pratiques, \emph{tout} est un
vecteur\index{vecteur}. C'est aussi l'unité de base dans les calculs.
Nous nous restreignons pour le moment aux vecteurs simples (atomiques)
dans lesquels tous les éléments sont du même mode.

\subsection{Création de vecteurs}
\label{sec:bases:vecteurs:creation}

La fonction de base pour créer un vecteur est la fonction de
concaténation \Icode{c}.
<<echo=TRUE>>=
(x <- c(2, 5.1, 42))
@

Les fonctions \Icode{numeric}, \Icode{logical} et
\Icode{character} permettent également de créer des vecteurs du
mode correspondant. Les fonctions prennent en argument la longueur du
vecteur à créer. Celui-ci contiendra des valeurs initiales
prédéterminées.
<<echo=TRUE>>=
numeric(5)
logical(7)
character(10)
@

Il est possible --- et souvent souhaitable --- de nommer les éléments
d'un vecteur; on dit qu'on leur attribue une \emph{étiquette}. Les
étiquettes sont enregistrées dans l'attribut \icode{names} du
vecteur. Il y a deux grandes façons de procéder: en spécificant les
noms dès la création du vecteur, ou à posteriori en ajoutant
l'attribut au vecteur.
<<echo=TRUE>>=
(v <- c(a = 1, b = 2, c = 5))
names(v)
@
<<echo=TRUE>>=
(v <- c(1, 2, 5))
names(v) <- c("a", "b", "c")
v
@

Si l'on tente de créer un vecteur simple avec des objets de modes
différents, R effectuera une \index{conversion forcée}conversion
forcée vers un \index{mode}mode unique. Celui-ci est choisi pour
minimiser la perte d'information sur les objets originaux.
<<echo=TRUE>>=
c(2, TRUE, FALSE)
c(2, FALSE, "a")
@


\subsection{Indiçage}
\label{sec:bases:vecteurs:indicage}

L'indiçage\Index{indiçage!vecteur} des vecteurs est une procédure
beaucoup utilisée dans le langage R, aussi est-il important d'en
maitriser toutes les subtilités. L'opération sert principalement à
deux choses: extraire des éléments d'un objet avec la construction
\verb|x[i]|\icode{[}, ou remplacer des éléments avec la
construction \verb|x[i] <- y|\Icode{[<-}.

Dans un cas comme dans l'autre, il faut d'abord indicer le vecteur. Il
existe cinq façons de le faire, toujours à l'intérieur de crochets
\code{[~]}.
\begin{enumerate}
\item Avec un vecteur d'entiers positifs (extraction par position).
  Les éléments se trouvant aux positions correspondant aux entiers
  sont extraits du vecteur, dans l'ordre. C'est la technique la plus
  courante.
<<echo=TRUE>>=
x <- c(A = 2, B = 4, C = -1, D = -5, E = 8)
x[c(1, 3)]
@
\item Avec un vecteur d'entiers négatifs (suppression par position).
  Les éléments se trouvant aux positions correspondant aux entiers
  négatifs sont \emph{éliminés} du vecteur.
<<echo=TRUE>>=
x[c(-2, -3)]
@
\item Avec un vecteur booléen (extraction par critère). Le vecteur
  d'indiçage doit alors être de la même longueur que le vecteur
  indicé. Les éléments correspondant à une valeur \code{TRUE} sont
  extraits du vecteur, alors que ceux correspondant à \code{FALSE}
  sont éliminés.
<<echo=TRUE>>=
x > 0
x[x > 0]
@
\item Avec un vecteur de chaines de caractères (extraction par nom).
  Les éléments dont l'étiquette correspond à l'une des chaines sont
  extraits du vecteur. Ce mode d'indiçage par le nom a comme principal
  avantage de permettre l'extraction d'éléments d'un vecteur
  indépendemment de leur position dans celui-ci.
<<echo=TRUE>>=
x[c("B", "D")]
@
\item L'indice est laissé vide. Tous les éléments du vecteur sont
  alors sélectionnés.
<<echo=TRUE>>=
x[]
@
  Cette méthode est essentiellement utilisée avec les matrices et
  tableaux pour sélectionner tous les éléments d'une dimension; nous y
  reviendrons au \autoref{chap:donnees}. Laisser l'indice vide est
  différent d'indicer avec un vecteur vide. Cette dernière opération
  retourne un vecteur vide.
\end{enumerate}

\tipbox{Il n'est pas inutile de savoir que les opérations d'extraction
  et de remplacement sont en fait traduites par l'interpréteur R en
  des appels à des fonctions nommées \icode{[} et \icode{[<-},
  dans l'ordre.}

\subsection{Arithmétique vectorielle}
\label{sec:bases:vecteurs:arithmetique}

L'arithmétique vectorielle de R constitue l'une des grandes forces du
langage. Elle permet de réaliser une grande variété de calculs sans
avoir recours à des procédures itératives (boucles).

Les procédures fondamentales de la \autoref{sec:bases:fondamentales}
peuvent toutes opérer sur les vecteurs en effectuant les opérations
\emph{élément par élément}. C'est la première règle de base de
l'arithmétique vectorielle dans R.
<<echo=TRUE>>=
c(1, 2, 3) + c(4, 5, 6)
1:3 * 4:6
@

La seconde règle de base se rapporte aux opérations entre des vecteurs
de longueurs différentes. Dans de tels cas, les vecteurs les plus
courts sont \emph{recyclés} autant de fois que nécessaire pour
correspondre au plus long vecteur. Cette règle est particulièrement
apparente avec les vecteurs de longueur $1$.
<<echo=TRUE>>=
1:10 + 2
@

Si la longueur du plus long vecteur est un multiple de celle du ou des
autres vecteurs, ces derniers sont recyclés un nombre entier de fois.
<<echo=TRUE>>=
1:10 + 1:5 + c(2, 4)
@

Autrement, le plus court vecteur est recyclé un nombre fractionnaire
de fois, mais comme ce résultat est rarement celui souhaité et qu'il
provient généralement d'une erreur de programmation, un avertissement
est affiché.
\begin{Schunk}
\begin{Sinput}
> 1:10 + c(2, 4, 6)
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9  6  9 12  9 12 15 12
Message d'avis :
In 1:10 + c(2, 4, 6) :
la taille d'un objet plus long n'est pas un multiple de la
taille d'un objet plus court
\end{Soutput}
\end{Schunk}

\cautionbox{La régle de recyclage des vecteurs fait en sorte qu'il y a
  très peu d'erreurs de longueur dans R. Qu'une expression soit
  valide ne signifie donc pas qu'elle effectue le bon calcul!}

Il tombe sous le sens que les opérations arithmétiques sont conçues
pour des arguments de \index{mode}mode \icode{numeric} et les
opérations logiques, pour des arguments de mode \icode{logical}. Si un
argument n'est pas du bon mode, R effectuera une \index{conversion
  forcée}conversion forcée vers le mode approprié. En particulier, les
valeurs booléennes \code{TRUE} et \code{FALSE} se verront converties
en $1$ et $0$, respectivement, dans les opérations arithmétiques. À
l'inverse, dans les opérations logiques, $0$ est converti en
\code{FALSE} et \emph{tout} autre nombre est converti en
\code{TRUE}.
<<echo=TRUE>>=
2 + c(TRUE, FALSE)
c(0, 5, -1) & TRUE
@

\section{Fonctions}
\label{sec:bases:fonctions}

Nous avons mentionné au début de la \autoref{sec:bases:fondamentales}
qu'un langage de programmation doit fournir un mécanisme d'abstraction
pour utiliser les éléments composés. La possibilité que nous offre R
de définir des objets contenant des valeurs constitue une première
technique. La définition de \emph{fonctions} (le nom que nous
donnerons dorénavant au concept de procédure) est une technique
d'abstration encore plus puissante, puisqu'elle permet de faire
référence par un seul nom à toute une suite d'opérations.

\subsection{Programmation fonctionnelle}
\label{sec:bases:fonctions:paradigme}

Nous adoptons en bonne partie avec le langage R le paradigme de la
programmation fonctionnelle. Tel qu'expliqué sommairement à la
\autoref{sec:informatique:paradigmes}, dans ce paradigme un programme
est constitué d'une suite d'appels de fonctions.

L'approche de programmation fonctionnelle dans R fait aussi en sorte
qu'une fonction est traitée comme n'importe quel autre objet. Entre
autres choses, cela signifie que:
\begin{itemize}
\item le contenu d'une fonction (son code source) est toujours
  accessible;
\item une fonction peut accepter en argument une autre fonction;
\item une fonction peut retourner une fonction comme résultat;
\item l'utilisateur peut définir de nouvelles fonctions.
\end{itemize}

Étudions un exemple très simple, pas véritablement utile en pratique
au-delà de ses vertus pédagogiques. Nous voulons élever un
nombre au carré. Pour faire ce calcul à répétition et de manière
abstraite --- c'est-à-dire, sans avoir à se demander à chaque fois
comment le calcul est fait ---, nous définissons une nouvelle
fonction \code{square}.
<<echo=TRUE>>=
square <- function(x) x * x
@

L'expression ci-dessus peut se lire ainsi:

\begin{center}
  \setlength{\unitlength}{7mm}
  \begin{picture}(18,4.2)
    \linethickness{1pt}

    \put(0,1){\code{square}}     \put(0,3.5){\code{square}}
    \put(2.2,1){est}             \put(2.3,3.5){\code{<-}}
    \put(3.2,1){une fonction}    \put(3.5,3.5){\code{function}}
    \put(6.6,1){
      \begin{minipage}[t]{5.714\unitlength} % ~= 40mm
        \centering
        qui prend en argument
        une valeur \code{x}
      \end{minipage}}           \put(8.9,3.5){\code{( x )}}
    \put(12.8,1){%
      \begin{minipage}[t]{4.571\unitlength} % ~= 32mm
        \centering
        et la multiplie par elle-même.
      \end{minipage}}           \put(14.4,3.5){\code{x * x}}

    \put(0.9,3.2){\vector(0,-1){1.6}}
    \put(2.6,3.2){\vector(0,-1){1.6}}
    \put(4.6,3.2){\vector(0,-1){1.6}}
    \put(9.7,3.2){\vector(0,-1){1.6}}
    \put(15.2,3.2){\vector(0,-1){1.6}}
  \end{picture}
\end{center}

Nous pouvons ensuite utiliser la fonction \code{square} de manière
intuitive comme n'importe quelle autre fonction dans R (nous
reviendrons sur les règles d'appel d'une fonction un peu plus loin).
<<echo=TRUE>>=
square(5)
@

L'approche de programmation fonctionnelle fait en sorte que les appels
de fonctions peuvent être placés les uns à la suite des autres, comme
la composition de fonctions $g \circ f$ en mathématiques. Pour élever
un nombre à la puissance $4$, nous pouvons appliquer deux fois la
fonction \code{square} à un argument.
<<echo=TRUE>>=
square(square(5))
@

\subsection{Définition d'une fonction}
\label{sec:bases:fonctions:definition}

Comme nous l'avons vu dans l'exemple ci-dessus, on définit une
nouvelle \index{fonction!définition}fonction dans R à l'aide de la
fonction \Icode{function}. La syntaxe exacte de la définition d'une
fonction est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
\meta{nom} <- function(\meta{arguments}) \meta{corps}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \meta{nom} est le nom de la fonction (les règles pour les noms
  de fonctions sont les mêmes que celles présentées à la
  \autoref{sec:bases:objets:noms} pour tout autre objet).

  Nous souhaitons généralement attribuer un nom à une fonction, ne
  serait-ce que pour pouvoir la réutiliser. Cela dit, c'est tout à
  fait optionnel. En effet, l'appel à \icode{function} retourne déjà
  une fonction et si aucun nom n'est attribué à cet objet, on obtient
  ce qui est appelé une \index{fonction!anonyme}\emph{fonction
    anonyme}. Les fonctions anonymes sont particulièrement utiles avec
  les fonctions d'application qui seront étudiées au
  \autoref{chap:application}.

\item \meta{arguments} est la liste des arguments formels de la
  fonction, séparés par des virgules.

  Une fonction peut n'avoir aucun \index{fonction!argument
    formel}argument formel ou plusieurs. Il n'y a pas de limite
  pratique au nombre d'arguments formels que peut avoir une fonction.
  Les arguments peuvent être des symboles, des constructions de la
  forme \code{symbole = défaut}, ou encore l'argument formel spécial
  `\code{...}'.

  Lorsqu'un symbole seul est utilisé comme argument, il indique le nom
  de celui-ci. L'objet de ce nom sera disponible à l'intérieur de la
  fonction.
<<echo=TRUE>>=
f <- function(x) 2 * x + 1
f(2)
@

  La construction \code{symbole = défaut} indique la valeur par défaut
  de l'argument \code{symbole}, c'est-à-dire la valeur de l'argument si
  aucune n'est spécifiée dans l'appel de la fonction.
<<echo=TRUE>>=
f <- function(x = 0) 2 * x + 1
f(2)
f()
@

  Enfin, l'argument spécial `\code{...}' peut contenir un nombre
  arbitraire d'arguments. La fonction y ayant recours se trouve donc à
  accepter un nombre variable d'arguments. On utilise généralement
  `\code{...}' pour passer des arguments tels quels à une autre fonction
  qui, elle, saura quoi faire de ces arguments. On trouvera un meilleur
  exemple à la \autoref{sec:bases:exemples} que ce que nous pourrions faire
  ici en quelques lignes.

\item \meta{corps} est une expression ou un groupe d'expressions
  réunies par des accolades, tel qu'expliqué à la
  \autoref{sec:bases:commandes:regroupement}.
\end{itemize}



\subsection{Appel d'une fonction}
\label{sec:bases:fonctions:appel}

Nous avons déjà évoqué certaines des règles qui régissent les
\index{fonction!appel}appels de fonctions dans R. Regardons maintenant
cela de plus près. Aux fins d'illustrations, nous définissons une
petite fonction comptant trois arguments, dont seul le premier n'a pas
de valeur par défaut.
<<echo=TRUE>>=
f <- function(x, y = 0, p = 2) sum(abs(x - y)^p)
@

L'ordre des arguments dans la définition de la fonction est important.
Nous avons deux choix au moment d'appeler une fonction:
\begin{enumerate}
\item spécifier les valeurs des arguments dans le bon ordre; ou
\item nommer explicitement les arguments avec une construction de la
  forme \code{symbole = expression}, auquel cas l'ordre n'importe
  plus.
\end{enumerate}
Si certains arguments sont nommés et d'autre pas, ces derniers
reçoivent des valeurs selon leur ordre dans la définition de la
fonction, et non en fonction de leur position dans l'appel.

Il est beaucoup plus prudent et \emph{fortement recommandé} de
spécifier les arguments par leur nom, surtout après les deux ou trois
premiers arguments.
<<echo=TRUE>>=
f(c(3, 2), c(1, 1), 2)
f(y = c(1, 1), c(3, 2), 2)
f(y = c(1, 1), p = 2, c(3, 2))
@

Il n'est pas nécessaire de spécifier une valeur pour un argument
disposant d'une valeur par défaut. Cependant, si l'on omet un tel
argument, il faudra nommer les arguments qui suivent, le cas échéant.
<<echo=TRUE>>=
f(c(3, 2))
f(c(3, 2), p = 3)
@

\citet[section~4.3.2]{R-lang} fournit les détails sur le mécanisme de
pairage entre les arguments d'une fonction et des valeurs qui lui sont
passées.

\tipbox{L'interpréteur R reconnait un appel de fonction au fait que le
  nom de l'objet est suivi de parenthèses \code{(~)}.}

\subsection{Retourner des résultats}
\label{sec:bases:fonctions:resultats}

La plupart des fonctions sont écrites dans le but de retourner un
\index{fonction!résultat}résultat. Or, les règles d'interprétation
d'un regroupement d'expressions présentées à la
\autoref{sec:bases:commandes:regroupement} s'appliquent ici au corps
de la fonction: une fonction retourne tout simplement le résultat de
sa \emph{dernière expression}.

On évitera donc que la dernière expression soit une affectation, car
la fonction ne retournera alors rien et on ne pourra utiliser une
construction de la forme \code{x <- f()} pour affecter le résultat de
la fonction à un objet.

\cautionbox{Il existe une fonction \icode{return} pour terminer
  immédiatement l'exécution d'une fonction et retourner un résultat;
  nous la présenterons avec les structures de contrôle au
  \autoref{chap:application}. Cependant, l'utilisation de
  \code{return} à la toute fin d'une fonction est tout à fait inutile
  et c'est considéré comme du mauvais style en R.}

\newpage

\section{Exemples}
\label{sec:bases:exemples}

\def\scriptfilename{bases.R}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=13]{\scriptfilename}


\section{Exercices}
\label{sec:bases:exercices}

\Opensolutionfile{solutions}[solutions-bases]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:bases}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:bases}}

\end{Filesave}

Il est possible de compléter tous les exercices ci-dessous sans avoir
recours à R, sinon pour vérifier vos réponses. (En fait, les exercices
sont de peu d'intérêt autrement.)

\begin{exercice}
  Évaluer les expressions suivantes comme le ferait l'interpréteur R.
  \begin{enumerate}
  \item \verb|1:5 * c(0, 1, 0, 1, 0)|
  \item \verb|c(2, 7, 1, 4) > 3|
  \item \verb|c(2, 7, 1, 4) <= c(10, 4)|
  \item \verb|c(-1, 2, 4)^(3:-2)|
  \item \verb|c(TRUE, FALSE, FALSE) & c(TRUE, TRUE, FALSE)|
  \item \verb=c(TRUE, FALSE, FALSE) | !2 < 3=
  \item \verb|-1:1/0|
  \item \verb|length(c("a", "abc", "ab"))|
  \item \verb|x <- c(-1, -2, -3); length(x)|
  \item \verb|mode(c(45.44, pi, TRUE))|
  \item \verb|mode(c(5, "5", "cinq"))|
  \item \verb|length(c(c(1, 3, 6, 7), NULL))|
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item Produit élément par élément entre deux vecteurs.
<<echo=FALSE>>=
1:5 * c(0, 1, 0, 1, 0)
@
     \item Comparaison élément par élément, le second vecteur étant
       utilisé quatre fois.
<<echo=FALSE>>=
c(2, 7, 1, 4) > 3
@
     \item Comparaison élément par élément, le second vecteur étant
       utilisé deux fois.
<<echo=FALSE>>=
c(2, 7, 1, 4) <= c(10, 4)
@
     \item Élévation à une puissance élément par élément, le premier
       vecteur étant utilisé deux fois.
<<echo=FALSE>>=
c(-1, 2, 4)^(3:-2)
@
     \item «Et» logique élément par élément.
<<echo=FALSE>>=
c(TRUE, FALSE, FALSE) & c(TRUE, TRUE, FALSE)
@
     \item Attention à la priorité des opérations! En vertu des
       priorités énoncées au \autoref{tab:bases:operateurs}, les
       opérations sont effectuées dans cet ordre: inégalité
       (\verb=<=), négation logique (\verb=!=) , «ou» logique
       (\verb=|=).
<<echo=FALSE>>=
c(TRUE, FALSE, FALSE) | !2 < 3
@
     \item Encore ici, la génération d'une suite a priorité sur la
       division.
<<echo=FALSE>>=
-1:1/0
@
     \item Vecteur de trois chaines de caractères, peu importe leur
       longueur.
<<echo=FALSE>>=
length(c("a", "abc", "ab"))
@
     \item
<<echo=FALSE>>=
x <- c(-1, -2, -3); length(x)
@
     \item La valeur booléenne est convertie en nombre réel.
<<echo=FALSE>>=
mode(c(45.44, pi, TRUE))
@
     \item Le nombre réel est converti en chaine de caractères.
<<echo=FALSE>>=
mode(c(5, "5", "cinq"))
@
     \item Concaténer \code{NULL} à un vecteur n'ajoute rien (ou du
       vide, qui n'a pas de longueur).
<<echo=FALSE>>=
length(c(c(1, 3, 6, 7), NULL))
@
     \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \index{indiçage!vecteur}
  Soit \code{x} un vecteur contenant les valeurs d'un échantillon:
  \begin{center}
<<echo=FALSE>>=
x <- c(18, 11, 10, 2, 19, 9, 12, 15, 13, 12, 1, 6)
@
<<echo=TRUE>>=
x
@
  \end{center}
  Écrire des expressions R pour créer ce vecteur dans l'espace de
  travail et pour extraire les éléments suivants.
  \begin{enumerate}
  \item Le deuxième élément de l'échantillon.
  \item Les cinq premiers éléments de l'échantillon.
  \item Les éléments strictement supérieurs à $14$.
  \item Tous les éléments sauf ceux en positions $6$, $7$ et $12$.
  \end{enumerate}
  \begin{sol}
    On crée d'abord le vecteur avec
<<echo=TRUE>>=
x <- c(18, 11, 10, 2, 19, 9, 12, 15, 13, 12, 1, 6)
@
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[2]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[1:5]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x > 14]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[-c(6, 7, 12)]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit $\mat{x} = (x_1, \dots, x_n)$ et $\mat{y} = y_1, \dots, y_n$
  deux vecteurs de nombres réels. Composer des expressions R pour
  effectuer les calculs mathématiques ci-dessous. Vous pouvez utiliser
  les fonctions R suivantes:
  \begin{itemize}
  \item \icode{sum} pour calculer la somme des éléments d'un
    vecteur;
  \item \icode{prod} pour calculer le produit des éléments d'un
    vecteur;
  \item \icode{max} pour calculer le maximum d'un vecteur;
  \item \icode{abs} pour calculer la valeur absolue de chacun des
    éléments d'un vecteur.
  \end{itemize}
  \begin{enumerate}
  \item $3 (\mat{x} + \mat{y})$
  \item $n^{-1} \sum_{i = 1}^n x_i$ (moyenne arithmétique de $\mat{x}$)
  \item $(\prod_{i = 1}^n x_i)^{1/n}$ (moyenne géométrique de $\mat{x}$)
  \item $1/(\prod_{i = 1}^n x_i^{-1})$ (moyenne harmonique de
    $\mat{x}$)
  \item $\langle \mat{x}, \mat{y} \rangle = \sum_{i = 1}^n x_i y_i$
    (produit scalaire entre $\mat{x}$ et $\mat{y}$)
  \item $\|\mat{x} - \mat{y}\|_1 = \sum_{i = 1}^n |x_i -
    y_i|$ (norme $1$ entre $\mat{x}$ et $\mat{y}$)
  \item $\|\mat{x} - \mat{y}\|_\infty = \max_{i = 1, \dots, n}(|x_i -
    y_i|)$ (norme «infini» entre $\mat{x}$ et $\mat{y}$)
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item
<<echo=TRUE,eval=FALSE>>=
3 * (x + y)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(x)/length(x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
prod(x)^(1/length(x))
@
    \item
<<echo=TRUE,eval=FALSE>>=
1/prod(1/x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(x * y)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(abs(x - y))
@
    \item
<<echo=TRUE,eval=FALSE>>=
max(abs(x - y))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Pour chacun des exercices b)--g) de l'exercice précédent, composer
  une fonction R pour effectuer le calcul demandé. Nommer les
  fonctions %
  \code{amean}, %
  \code{gmean}, %
  \code{hmean}, %
  \code{pscal}, %
  \code{norm1} et %
  \code{normINF}, %
  dans l'ordre.
  \begin{sol}
    \begin{enumerate}
      \stepcounter{enumi}
    \item
<<echo=TRUE, eval=FALSE>>=
amean <- function(x) sum(x)/length(x)
@
    \item
<<echo=TRUE, eval=FALSE>>=
gmean <- function(x) prod(x)^(1/length(x))
@
    \item
<<echo=TRUE, eval=FALSE>>=
hmean <- function(x) 1/prod(1/x)
@
    \item
<<echo=TRUE, eval=FALSE>>=
pscal <- function(x, y) sum(x * y)
@
    \item
<<echo=TRUE, eval=FALSE>>=
norm1 <- function(x, y) sum(abs(x - y))
@
    \item
<<echo=TRUE, eval=FALSE>>=
normINF <- function(x, y) max(abs(x - y))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit la fonction \code{f} suivante:
<<echo=FALSE>>=
f <- function(x, y)
{
    g <- function(a)
        (x - y) * a + a * x
    g(1 + x * y)
}
@
<<echo=TRUE>>=
f
@
  Évaluer les résultats des appels suivants.
  \begin{enumerate}
  \item \code{f(1, 1)}
  \item \code{f(f(1, 1), 1)}
  \item \code{f(1, f(f(1, 1), 1))}
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item
<<echo=FALSE>>=
f(1, 1)
@
    \item
<<echo=FALSE>>=
f(f(1, 1), 1)
@
    \item
<<echo=FALSE>>=
f(1, f(f(1, 1), 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Une fonction R est définie ainsi:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
f <- function(x = 0, y = NULL, z) \meta{corps}
\end{Verbatim}
\end{Schunk}
  Déterminer la valeur des arguments \code{x}, \code{y} et \code{z}
  dans les appels de fonction ci-dessous.
  \begin{enumerate}
  \item \code{f(2, 3, 4)}
  \item \code{f(2, z = 3, y = 4)}
  \item \code{f(x = 2, z = 3)}
  \item \code{f(z = 2, 3, x = 4)}
  \item \code{f(z = 2)}
  \item \code{f(z = 2, 3, 4)}
  \item \code{f(2, 3)}
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item \code{x = 2}, \code{y = 3}, \code{z = 4}
    \item \code{x = 2}, \code{y = 4}, \code{z = 3}
    \item \code{x = 2}, \code{y = NULL}, \code{z = 3}
    \item \code{x = 4}, \code{y = 3}, \code{z = 2}
    \item \code{x = 0}, \code{y = NULL}, \code{z = 2}
    \item \code{x = 3}, \code{y = 4}, \code{z = 2}
    \item \link{http://i0.kym-cdn.com/entries/icons/original/000/000/157/itsatrap.jpg}{C'est un piège!} %
      Cet appel n'est pas valide puisque l'argument \code{z} est
      manquant.
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
