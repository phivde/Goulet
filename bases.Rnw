%%% Copyright (C) 2019 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet
%%% «Programmer avec R»
%%% https://gitlab.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition sous licence
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% https://creativecommons.org/licenses/by-sa/4.0/

\chapter{Bases de la programmation}
\label{chap:bases}

\def\scriptfilename{\currfilebase.R}
\SweaveOpts{echo=FALSE}

<<echo=FALSE, results=hide>>=
source(".Sweaveprofile")   # configuration
source("Stangle.R")        # lancement de Stangle
@
<<script>>=
## Copyright (C) 2019 Vincent Goulet
##
## Ce fichier fait partie du projet
## «Programmer avec R»
## https://gitlab.com/vigou3/programmer-avec-r
##
## Cette création est mise à disposition sous licence
## Attribution-Partage dans les mêmes conditions 4.0
## International de Creative Commons.
## https://creativecommons.org/licenses/by-sa/4.0/
@

\begin{objectifs}
\item Écrire et interpréter la syntaxe et la sémantique du langage R.
\item Utiliser l'arithmétique vectorielle du langage R dans les
  calculs.
\item Créer et manipuler des vecteurs simples («atomiques»).
\item Utiliser les divers modes des vecteurs (en particulier
  \code{numeric}, \code{character} et \code{logical}) et la conversion
  automatique de l'un à l'autre.
\item Extraire des données d'un vecteur simple ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Appeler une fonction R; concevoir comment les arguments sont
  passés à la fonction et le traitement des valeurs par défaut.
\end{objectifs}

C'est dans ce chapitre que nous débutons réellement l'apprentissage de
la programmation. Je l'avoue d'entrée de jeu: la présentation a
fortement été influencée par l'ouvrage magistral de
\cite{Sussman:scheme:1996}.

Les humains créent des programmes informatiques pour contrôler, à
l'aide d'un ensemble de règles, les processus de calcul et de
manipulation de données d'un ordinateur. Ces programmes sont rédigés
dans un langage de programmation.

Un langage est toutefois plus qu'une simple manière de transmettre des
instructions à un ordinateur, c'est aussi une façon de conceptualiser
les procédures que l'ordinateur devra effectuer. Autrement dit, le
type de langage de programmation que nous utilisons influence
directement la solution que nous proposerons à un problème --- et vice
versa. Comme nous l'avons déjà fait à la
\autoref{sec:informatique:concepts:semantique}, dressons un parallèle
avec les langues parlées et écrites: une langue ne constitue pas
seulement un moyen de transmettre une idée, mais bien une façon de
concevoir le monde. Ce n'est pas pour rien qu'il est parfois
impossible de faire passer une idée d'une langue vers une autre --- ce
que l'on appelle couramment une «expression intraduisible».

Le langage de programmation étudié ici est le R. Sa syntaxe, celle du
langage \index{S}S, s'apparente au \index{C}C. En revanche, la
sémantique de R s'inspire du paradigme de la programmation
fonctionnelle, ce qui lui confère de plus grandes affinités avec le
\index{Lisp}Lisp et \index{APL}l'APL.

Ce chapitre introduit des notions de base du langage R telles que
l'expression, l'affectation, et l'objet. Le concept de vecteur se
trouvant au cœur du langage, nous faisons une large place à la
création et à la manipulation des vecteurs. Après avoir présenté les
règles d'appels d'une fonction, le chapitre se termine par
l'introduction de fonctions internes utiles à ce stade de vos
apprentissages.


\section{Données et procédures fondamentales}
\label{sec:bases:fondamentales}

À sa plus simple expression, la programmation est un exercice de
manipulation de \emph{données} à l'aide de \emph{procédures}. Un
langage de programmation fournit au programmeur des données et des
procédures fondamentales (ou \emph{génériques}), des manières de les
combiner pour former des éléments composés, ainsi qu'un mécanisme
d'abstraction permettant de nommer et de manipuler ces éléments
composés.

Les données fondamentales de R sont les suivantes:
\begin{itemize}
\item nombres réels: \code{0, 1, 2, 78.42, -1.39}, \dots;
\item chaines de caractères: \code{"a"}, \code{"abc"}, \dots;
\item valeurs booléennes: \Icode{TRUE}, \Icode{FALSE};
\item donnée manquante: \Icode{NA};
\item infini positif et négatif: \Icode{Inf}, \code{-Inf};
\item valeur indéterminée: \Icode{NaN};
\item «néant»: \Icode{NULL};
\item nombres complexes: \code{1 + 2i}.
\end{itemize}
La grande majorité des langages de programmation offrent les deux
premiers types de données ci-dessus. Les autres types se révèlent très
utiles pour la programmation mathématique et l'analyse de données.
Nous reviendrons sur leurs caractéristiques à la
\autoref{sec:bases:objets}.

Nous pouvons classer les procédures fondamentales --- ou
\index{opérateurs}\emph{opérateurs} --- en quatre grandes catégories:
\begin{itemize}
\item arithmétique: \verb|+ - * / ^ < >= ==|, etc.;
\item logique: \verb=& | !=\,;
\item indiçage: \verb=[ ] $=\,;
\item affectation: \verb|<-|\,.
\end{itemize}
Les opérations arithmétiques sont applicables aux nombres réels ou
complexes, alors que les opérations logiques ne sont applicables
qu'aux valeurs booléennes. Nous traitons de l'opération d'affectation
en détail à la section suivante.

Le \autoref{tab:bases:operateurs} présente les opérateurs les plus
fréquemment employés en ordre décroissant de priorité des opérations.
Ils sont accompagnés d'une description succincte.

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.1}
  \caption[Principaux opérateurs du langage R]{Principaux opérateurs
    du langage R, en ordre décroissant de priorité}
  \label{tab:bases:operateurs}
  \begin{tabular}{lp{8cm}}
    \toprule
    Opérateur  & Fonction \\
    \midrule
    \icode{\$} & extraction d'une liste \\ %$
    \icode{[}\, \icode{[[} & indiçage \\
    \verb|^|\index{\string^@\verb=^=} & puissance \\
    \icode{-} & changement de signe \\
    {\NoAutoSpacing\verb|:|}\index{:@\NoAutoSpacing\verb=:=} & génération de suites \\
    \icode{\%*\%}\, \icode{\%\%}\, \icode{\%/\%} & produit matriciel,
                                                   modulo,
                                                   division entière \\
    \icode{*}\, \icode{/} & multiplication, division \\
    \icode{+}\, \icode{-} & addition, soustraction \\
    \icode{<}\, \icode{<=}\, \icode{==}\, \icode{>=}\,
    \icode{>}\, \verb|!=|\index{"!=@\code{"!=}} & plus petit,
                                                  plus petit ou égal,
                                                  égal,
                                                  plus grand ou égal,
                                                  plus grand,
                                                  différent de \\
    \verb=!=\index{"!@\code{"!}}  & négation logique \\
    \icode{\&}\, \icode{\&\&} & «et» logique \\
    \code{\textbar}\index{{"|}@\code{\textbar}}\,
    \code{\textbar\textbar}\index{{"|"|}@\code{\textbar\textbar}} & «ou» logique \\
    \icode{->}\, \verb|->>|\index{->>@\verb=->>=} & affectation \\
    \icode{<-}\, \verb|<<-|\index{<<-@\verb=<<-=} & affectation \\
    \bottomrule
  \end{tabular}
\end{table}

\tipbox{Les opérateurs de puissance \code{\string^} et d'affectation
  \icode{<-} sont évalués de droite à gauche; tous les autres le sont
  de gauche à droite. Ainsi, \code{2\string^2\string^3} est \code{2\string^8}, et non
  \code{4\string^3}, alors que \code{1 - 1 - 1} vaut \code{-1}, et non
  \code{1}.}

Comme la définition de la grande majorité des opérateurs coule de
source, illustrons ici uniquement les opérateurs de modulo et de
division entière.

\begin{ttscript}{\%/\%}
\item[\code{\%\%}] modulo (reste d'une division)
<<echo=TRUE>>=
5 %% 3
@
\item[\code{\%/\%}] division entière (partie entière d'une division)
<<echo=TRUE>>=
5 %/% 3
@
\end{ttscript}

<<script, results=hide>>=
###
### DONNÉES ET PROCÉDURES FONDAMENTALES  `\labelline{bases:fondamentales}`
###

## Nombres. Tous les nombres réels sont stockés en double
## précision dans R, entiers comme fractionnaires.
486                        # nombre réel entier
0.3324                     # nombre réel fractionnaire
2e-3                       # notation scientifique
1 + 2i                     # nombre complexe

## Tout objet en R comporte au minimum un mode et une
## longueur.
mode(486)                  # pas de différence entre entier...
mode(0.3324)               # ... et nombre réel
length(486)                # vecteur de longueur 1
mode(1 + 2i)               # nombre complexe

## Valeurs booléennes. 'TRUE' et 'FALSE' sont des noms
## réservés pour identifier les valeurs booléennes
## correspondantes.
TRUE                       # vrai
FALSE                      # faux
mode(TRUE)                 # mode "logical"
! c(TRUE, FALSE)           # négation logique
TRUE & FALSE               # ET logique
TRUE | FALSE               # OU logique

## [Détails additionnels sur les expressions logiques. Les
## expressions suivantes construisent un «tableau de vérité»
## entre deux énoncés 'p' et 'q' qui peuvent chacun être
## «vrai» ou «faux». Le ET logique est vrai seulement lorsque
## les deux énoncés sont vrais, alors que le OU logique est
## faux seulement lorsque les deux énoncés sont faux.]
p <- c(TRUE, TRUE, FALSE, FALSE)
q <- c(TRUE, FALSE, TRUE, FALSE)
cbind("p" = p, "q" = q, "p ET q" = p & q, "p OU q" = p | q)

## Donnée manquante. 'NA' est un nom réservé pour représenter
## une donnée manquante.
c(65, NA, 72, 88)          # traité comme une valeur
NA + 2                     # tout calcul avec 'NA' donne NA
is.na(c(65, NA))           # test si les données sont NA

## Valeurs infinies et indéterminée. 'Inf', '-Inf' et 'NaN'
## sont des noms réservés.
1/0                        # +infini
-1/0                       # -infini
0/0                        # indétermination
x <- c(65, Inf, NaN, 88)   # s'utilisent comme des valeurs
is.finite(x)               # quels sont les nombres réels?
is.nan(x)                  # lesquels sont indéterminés?

## Valeur "néant". 'NULL' est un nom réservé pour représenter
## le néant, rien.
mode(NULL)                 # le mode de 'NULL' est NULL
length(NULL)               # longueur nulle
c(NULL, NULL)              # du néant ne résulte que le néant

## Chaines de caractères. On crée une chaine de caractères en
## l'entourant de guillemets doubles " ".
"foobar"                   # *une* chaine de 6 caractères
length("foobar")           # longueur de 1
c("foo", "bar")            # *deux* chaines de 3 caractères
length(c("foo", "bar"))    # longueur de 2

## L'opérateur modulo retourne le reste d'une division.
5 %% 2                     # 5/2 = 2 reste 1
5 %% 1:5                   # remarquer la périodicité
10 %% 1:15                 # x %% y = x si x < y

## Un nombre 'x' est pair si 'x mod 2 = 0' et il est impair si
## 'x mod 2 = 1'.
a <- c("Impair", "Pair")
x <- c(2, 3, 6, 8, 9, 11, 12)
x %% 2                     # pair ou impair?
2 - x %% 2                 # observer priorité des opérations
a[2 - x %% 2]              # indiçage à répétition

## La division entière retourne la partie entière de la
## division d'un nombre par un autre.
5 %/% 1:5
10 %/% 1:15

## Attention à cette erreur commune --- et parfois difficile à
## détecter: '=' n'est PAS l'opérateur de comparaison entre
## deux valeurs.
##-!- 5 = 2                      # erreur de syntaxe

## L'opérateur de comparaison est plutôt '=='.
5 == 2                     # comparaison
y = 2                      # pas un test...
y                          # ... plutôt une affectation

## L'opérateur '==' vérifie l'égalité bit pour bit dans la
## représentation interne des nombres dans l'ordinateur. Ça
## fonctionne bien pour les entiers ou les valeurs booléennes,
## mais pas pour les nombres réels ou, plus insidieux, pour
## les nombres entiers provenant d'un calcul et qui ne sont
## entiers qu'en apparence.
##
## [Pour en savoir (un peu) plus:
##  https://floating-point-gui.de/formats/fp/]
1.2 + 1.4 + 2.8            # 5.4 en apparence
1.2 + 1.4 + 2.8 == 5.4     # non?!?
0.3/0.1 == 3               # à gauche: faux entier `\labelline{bases:fondamentales:fin}`
@

\gotorbox{Étudiez les lignes \reflines{bases:fondamentales}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:bases:exemples}.}


\section{Commandes R}
\label{sec:bases:commandes}

Nous l'avons déjà vu, l'interaction avec l'interpréteur R se fait par
l'intermédiaire de commandes entrées à la ligne de commande. Or, toute
commande R est soit une \emph{expression}\index{expression}, soit une
\emph{affectation}\index{affectation}.

\subsection{Expression}
\label{sec:bases:commandes:expression}

Une \index{expression}expression R est une combinaison de symboles
(noms de variables) et de procédures. Toute expression a une valeur.
Le symbole d'une donnée fondamentale représente cette donnée, comme on
pourrait s'y attendre.

Lorsqu'une expression est entrée à la ligne de commande de
l'interpréteur, elle est immédiatement évaluée et le résultat est
affiché sous l'invite de commande \verb*|> | (le symbole \verb|>|
suivi d'une espace).
<<echo=TRUE>>=
42
3 + 2i
2 + 3
pi
cos(pi/4)
@

Lorsqu'une commande n'est pas syntaxiquement complète, l'invite de
commande se change en \verb*|+ | pour nous inciter à compléter la
commande.
<<echo=TRUE>>=
2 *
3
@

Il est possible de combiner plusieurs expressions ensemble pour en
faire une expression composée. Celle-ci est évaluée de gauche à
droite, à moins que des parenthèses ne viennent changer l'ordre
d'évaluation, comme en mathématiques.
<<echo=TRUE>>=
(2 + ((2 + 4 * 6) * (3 + 5 + 7)))/2
@

\subsection{Affectation}
\label{sec:bases:commandes:affectation}

Dans une \index{affectation}affectation, une expression est évaluée,
mais le résultat est stocké dans un \emph{objet} (ou \emph{variable})
dans %
l'\index{espace de travail}espace de travail %
et rien n'est affiché à l'écran. Tel que mentionné précédemment, le
symbole d'affectation est \icode{<-} --- c'est-à-dire les deux
caractères \verb|<| et \verb|-| placés obligatoirement l'un à la suite
de l'autre --- et le symbole est évalué de droite à gauche. Ainsi,
toute expression est évaluée avant que son résultat ne soit placé dans
l'objet.
<<echo=TRUE>>=
a <- 5
a
b <- a
b
x <- 2 + 3
x
@

Pour affecter le résultat d'un calcul dans un objet et simultanément
afficher ce résultat, il suffit de placer l'affectation entre
parenthèses pour ainsi créer une nouvelle expression\footnote{%
  En fait, cela devient un appel à l'opérateur \code{"("} qui ne fait
  que retourner son argument.}.
<<echo=TRUE>>=
(a <- 2 + 3)
@

Le symbole d'affectation inversé \icode{->} existe aussi, mais il
est rarement utilisé.

\cautionbox{Évitez d'utiliser l'opérateur \,\icode{=}\, pour
  affecter une valeur à une variable. Cette pratique est susceptible
  d'engendrer de la confusion avec les constructions \code{symbole =
    valeur} dans les appels de fonction. Les règles de syntaxe de R
  commandent d'utiliser l'opérateur \code{<-} pour l'affectation,
  point.}

\subsection{Regroupement de commandes}
\label{sec:bases:commandes:regroupement}

Dans les fichiers de script ou à la ligne de commande, on sépare
généralement les commandes R les unes des autres par un retour à la
ligne. Il est également possible de séparer les commandes par un
\index{;@\code{;}}point-virgule. Employer les deux --- placer des
points-virgules à la fin de chaque ligne de code --- est considéré
comme du mauvais style, surtout dans les fichiers de script. Le
point-virgule peut être utile pour séparer deux courtes expressions ou
plus sur une même ligne. C'est le seul emploi que je fais du
point-virgule.
<<echo=TRUE>>=
a <- 5; a + 2
@

On peut regrouper plusieurs commandes en une seule expression en les
entourant d'accolades \Icode{\{~\}}. Le résultat du regroupement
est la valeur de la \emph{dernière} commande. Par conséquent, si le
regroupement se termine par une affectation, aucune valeur n'est
retournée ni affichée à l'écran.
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
    b
}
@
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
}
@

<<script, results=hide>>=
###
### COMMANDES R            `\labelline{bases:commandes}`
###

## Les expressions entrées à la ligne de commande sont
## immédiatement évaluées et le résultat est affiché à
## l'écran, comme avec une grosse calculatrice.
1                          # une constante
(2 + 3 * 5)/7              # priorité des opérations
3^5                        # puissance
exp(3)                     # fonction exponentielle
sin(pi/2) + cos(pi/2)      # fonctions trigonométriques
gamma(5)                   # fonction gamma

## Lorsqu'une expression est syntaxiquement incomplète,
## l'invite de commande change de '> ' à '+ '.
2 -                        # expression incomplète
5 *                        # toujours incomplète
3                          # complétée

## Entrer le nom d'un objet affiche son contenu. Pour une
## fonction, c'est son code source qui est affiché.
pi                         # constante numérique intégrée
letters                    # chaîne de caractères intégrée
LETTERS                    # version en majuscules
matrix                     # fonction

## On crée des nouveaux objets en leur affectant une valeur
## avec l'opérateur '<-'. *Ne pas* utiliser '=' pour
## l'affectation.
x <- 5                     # affectation de 5 à l'objet 'x'
5 -> x                     # idem, mais peu utilisé
x                          # voir le contenu
(x <- 5)                   # affectation et affichage
y <- x                     # affecter la valeur de 'x' à 'y'
x <- y <- 5                # idem, en une seule expression
y                          # 5
x <- 0                     # changer la valeur de 'x'...
y                          # ... ne change pas celle de 'y'

## Pour regrouper plusieurs expressions en une seule commande,
## il faut soit les séparer par un point-virgule ';', soit les
## regrouper à l'intérieur d'accolades { } et les séparer par
## des retours à la ligne.
x <- 5; y <- 2; x + y      # compact; éviter dans les scripts
x <- 5;                    # éviter les ';' superflus
{                          # début d'un groupe
    x <- 5                 # première expression du groupe
    y <- 2                 # seconde expression du groupe
    x + y                  # dernière expression du groupe
}                          # fin du groupe et résultat
{x <- 5; y <- 2; x + y}    # valide, mais redondant `\labelline{bases:commandes:fin}`
@

\gotorbox{Étudiez les lignes \reflines{bases:commandes}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:bases:exemples}.}


\section{Vecteurs}
\label{sec:bases:vecteurs}

En R, pratiquement, \emph{tout} est un
vecteur\index{vecteur}. C'est aussi l'unité de base dans les calculs.
Nous nous restreignons pour le moment aux vecteurs simples (atomiques)
dans lesquels tous les éléments sont du même mode.

\subsection{Création de vecteurs}
\label{sec:bases:vecteurs:creation}

La fonction de base pour créer un vecteur est la fonction de
concaténation \Icode{c}.
<<echo=TRUE>>=
(x <- c(2, 5.1, 42))
@

Les fonctions \Icode{numeric}, \Icode{logical} et
\Icode{character} permettent également de créer des vecteurs du
mode correspondant. Les fonctions prennent en argument la longueur du
vecteur à créer. Celui-ci contiendra des valeurs initiales
prédéterminées.
<<echo=TRUE>>=
numeric(5)
logical(7)
character(10)
@

Il est possible --- et souvent souhaitable --- de nommer les éléments
d'un vecteur; on dit qu'on leur attribue une \emph{étiquette}. Les
étiquettes sont enregistrées dans l'attribut \icode{names} du
vecteur. Il y a deux grandes façons de procéder: en spécificant les
noms dès la création du vecteur, ou à posteriori en ajoutant
l'attribut au vecteur.
<<echo=TRUE>>=
(v <- c(a = 1, b = 2, c = 5))
names(v)
@
<<echo=TRUE>>=
(v <- c(1, 2, 5))
names(v) <- c("a", "b", "c")
v
@

Si l'on tente de créer un vecteur simple avec des objets de modes
différents, R effectuera une \index{conversion forcée}conversion
forcée vers un \index{mode}mode unique. Celui-ci est choisi pour
minimiser la perte d'information sur les objets originaux.
<<echo=TRUE>>=
c(2, TRUE, FALSE)
c(2, FALSE, "a")
@

\subsection{Indiçage}
\label{sec:bases:vecteurs:indicage}

L'indiçage\Index{indiçage!vecteur} des vecteurs est une procédure
beaucoup utilisée dans le langage R, aussi est-il important d'en
maitriser toutes les subtilités. L'opération sert principalement à
deux choses: extraire des éléments d'un objet avec la construction
\verb|x[i]|\indexcode{[}, ou remplacer des éléments avec la
construction \verb|x[i] <- y|\Indexcode{[<-}.

Dans un cas comme dans l'autre, il faut d'abord indicer le vecteur. Il
existe cinq façons de le faire, toujours à l'intérieur de crochets
\code{[~]}.
\begin{enumerate}
\item Avec un vecteur d'entiers positifs (extraction par position).
  Les éléments se trouvant aux positions correspondant aux entiers
  sont extraits du vecteur, dans l'ordre. C'est la technique la plus
  courante.
<<echo=TRUE>>=
x <- c(A = 2, B = 4, C = -1, D = -5, E = 8)
x[c(1, 3)]
@
\item Avec un vecteur d'entiers négatifs (suppression par position).
  Les éléments se trouvant aux positions correspondant aux entiers
  négatifs sont \emph{éliminés} du vecteur.
<<echo=TRUE>>=
x[c(-2, -3)]
@
\item Avec un vecteur booléen (extraction par critère). Le vecteur
  d'indiçage doit alors être de la même longueur que le vecteur
  indicé. Les éléments correspondant à une valeur \code{TRUE} sont
  extraits du vecteur, alors que ceux correspondant à \code{FALSE}
  sont éliminés.
<<echo=TRUE>>=
x > 0
x[x > 0]
@
\item Avec un vecteur de chaines de caractères (extraction par nom).
  Les éléments dont l'étiquette correspond à l'une des chaines sont
  extraits du vecteur. Ce mode d'indiçage par le nom a comme principal
  avantage de permettre l'extraction d'éléments d'un vecteur
  indépendamment de leur position dans celui-ci.
<<echo=TRUE>>=
x[c("B", "D")]
@
\item L'indice est laissé vide. Tous les éléments du vecteur sont
  alors sélectionnés.
<<echo=TRUE>>=
x[]
@
  Cette méthode est essentiellement utilisée avec les matrices et
  tableaux pour sélectionner tous les éléments d'une dimension; nous y
  reviendrons au \autoref{chap:donnees}. Laisser l'indice vide est
  différent d'indicer avec un vecteur vide. Cette dernière opération
  retourne un vecteur vide.
\end{enumerate}

\tipbox{Il n'est pas inutile de savoir que les opérations d'extraction
  et de remplacement sont en fait traduites par l'interpréteur R en
  des appels à des fonctions nommées \icode{[} et \icode{[<-},
  dans l'ordre.}

\subsection{Arithmétique vectorielle}
\label{sec:bases:vecteurs:arithmetique}

L'arithmétique vectorielle de R constitue l'une des grandes forces du
langage. Elle permet de réaliser une grande variété de calculs sans
avoir recours à des procédures itératives (boucles).

Les procédures fondamentales de la \autoref{sec:bases:fondamentales}
peuvent toutes opérer sur les vecteurs en effectuant les opérations
\emph{élément par élément}. C'est la première règle de base de
l'arithmétique vectorielle dans R.
<<echo=TRUE>>=
c(1, 2, 3) + c(4, 5, 6)
1:3 * 4:6
@

La seconde règle de base se rapporte aux opérations entre des vecteurs
de longueurs différentes. Dans de tels cas, les vecteurs les plus
courts sont \emph{recyclés} autant de fois que nécessaire pour
correspondre au plus long vecteur. Cette règle est particulièrement
apparente avec les vecteurs de longueur $1$.
<<echo=TRUE>>=
1:10 + 2
@

Si la longueur du plus long vecteur est un multiple de celle du ou des
autres vecteurs, ces derniers sont recyclés un nombre entier de fois.
<<echo=TRUE>>=
1:10 + 1:5 + c(2, 4)
@

Autrement, le plus court vecteur est recyclé un nombre fractionnaire
de fois, mais comme ce résultat est rarement celui souhaité et qu'il
provient généralement d'une erreur de programmation, un avertissement
est affiché.
\begin{Schunk}
\begin{Sinput}
> 1:10 + c(2, 4, 6)
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9  6  9 12  9 12 15 12
Message d'avis :
In 1:10 + c(2, 4, 6) :
la taille d'un objet plus long n'est pas un multiple de la
taille d'un objet plus court
\end{Soutput}
\end{Schunk}

\cautionbox{La règle de recyclage des vecteurs fait en sorte qu'il y a
  très peu d'erreurs de longueur dans R. Qu'une expression soit
  valide ne signifie donc pas qu'elle effectue le bon calcul!}

Il tombe sous le sens que les opérations arithmétiques sont conçues
pour des arguments de \index{mode}mode \icode{numeric} et les
opérations logiques, pour des arguments de mode \icode{logical}. Si un
argument n'est pas du bon mode, R effectuera une \index{conversion
  forcée}conversion forcée vers le mode approprié. En particulier, les
valeurs booléennes \code{TRUE} et \code{FALSE} se verront converties
en $1$ et $0$, respectivement, dans les opérations arithmétiques. À
l'inverse, dans les opérations logiques, $0$ est converti en
\code{FALSE} et \emph{tout} autre nombre est converti en
\code{TRUE}.
<<echo=TRUE>>=
2 + c(TRUE, FALSE)
c(0, 5, -1) & TRUE
@

<<script, results=hide>>=
###
### VECTEURS               `\labelline{bases:vecteurs}`
###

## La fonction de base pour créer des vecteurs est 'c'. Il
## peut s'avérer utile de nommer les éléments d'un vecteur.
x <- c(A = -1, B = 2, C = 8, D = 10) # création d'un vecteur
names(x)                             # extraire les noms
names(x) <- letters[1:length(x)]     # changer les noms
x                                    # nouveau vecteur

## La fonction 'vector' sert à initialiser des vecteurs avec
## des valeurs prédéterminées. Elle compte deux arguments: le
## mode du vecteur et sa longueur. Les fonctions 'numeric',
## 'logical', 'complex' et 'character' constituent des
## raccourcis pour des appels à 'vector'.
vector("numeric", 5)       # vecteur initialisé avec des 0
numeric(5)                 # équivalent
numeric                    # en effet, voici la fonction
logical(5)                 # initialisé avec FALSE
complex(5)                 # initialisé avec 0 + 0i
character(5)               # initialisé avec chaînes vides

## Si l'on mélange dans un même vecteur des objets de mode
## différents, il y a conversion forcée vers le mode pour
## lequel il y a le moins de perte d'information, c'est-à-dire
## vers le mode qui permet le mieux de retrouver la valeur
## originale des éléments.
c(5, TRUE, FALSE)          # conversion en mode 'numeric'
c(5, "z")                  # conversion en mode 'character'
c(TRUE, "z")               # conversion en mode 'character'
c(5, TRUE, "z")            # conversion en mode 'character'

### INDIÇAGE

## L'indiçage est une opération importante et beaucoup
## utilisée. Elle sert à extraire des éléments d'un vecteur
## avec la construction 'x[i]', ou à les remplacer avec la
## construction 'x[i] <- y'. Les fonctions sous-jacentes sont
## '[' et '[<-'.
##
## Les expressions suivantes illustrent les cinq méthodes
## d'indiçage.
x                          # le vecteur
x[1]                       # extraction par position
"["(x, 1)                  # idem avec la fonction '['
x[-2]                      # suppression par position
x[x > 5]                   # extraction par critère
x["c"]                     # extraction par nom
x[]                        # tous les éléments
x[numeric(0)]              # différent d'indice vide

## Pour le prochain bloc d'exemples, nous remplaçons deux
## données du vecteur 'x' par NA avec la construction 'x[i] <-
## y'.
x[c(1, 4)] <- NA           # manière usuelle
"[<-"(x, c(1, 4), NA)      # idem, mais très peu usité

## Il arrive souvent de vouloir indicer spécifiquement les
## données manquantes d'un vecteur (pour les éliminer ou pour
## les remplacer par une autre valeur, par exemple).
##
## Pour ce faire, on utilise la fonction 'is.na' et l'indiçage
## par un vecteur booléen.
is.na(x)                   # positions des données manquantes
x[!is.na(x)]               # suppression des données manquantes
x[is.na(x)] <- 0; x        # remplacement des NA par des 0

## Laissons tomber les noms de l'objet.
names(x) <- NULL           # suppression de l'attribut 'names'

## Quelques cas spéciaux d'indiçage.
length(x)                  # rappel de la longueur
x[1:8]                     # vecteur allongé avec des NA
x[0]                       # extraction de rien
x[0] <- 1; x               # affectation de rien
x[c(0, 1, 2)]              # indice 0 ignoré
x[c(1, NA, 5)]             # indice NA retourne NA
x[2.6]                     # fractions tronquées vers 0

## ARITHMÉTIQUE VECTORIELLE

## L'unité de base de l'arithmétique en R est le vecteur. Cela
## rend très simple et intuitif de faire des opérations
## mathématiques courantes.
##
## Là où plusieurs langages de programmation exigent des
## boucles, R fait le calcul directement.
##
## En effet, les règles de l'arithmétique en R sont
## globalement les mêmes qu'en algèbre vectorielle et
## matricielle.
5 * c(2, 3, 8, 10)         # multiplication par une constante
c(2, 6, 8) + c(1, 4, 9)    # addition de deux vecteurs
c(0, 3, -1, 4)^2           # élévation à une puissance

## Dans les règles de l'arithmétique vectorielle, les
## longueurs des vecteurs doivent toujours concorder.
##
## R permet plus de flexibilité en recyclant les vecteurs les
## plus courts dans une opération.
##
## Il n'y a donc à peu près jamais d'erreurs de longueur en R!
## C'est une arme à deux tranchants: le recyclage des vecteurs
## facilite le codage, mais peut aussi résulter en des
## réponses complètement erronées sans que le système ne
## détecte d'erreur.
8 + 1:10                   # 8 est recyclé 10 fois
c(2, 5) * 1:10             # c(2, 5) est recyclé 5 fois
c(-2, 3, -1, 4)^(1:4)      # quatre puissances différentes

## Dans les opérations arithmétiques (ou, plus généralement,
## les opérations conçues pour travailler avec des nombres),
## les valeurs booléennes TRUE et FALSE sont automatiquement
## converties en 1 et 0, respectivement. Conséquence: il est
## possible de faire des calculs avec des valeurs booléennes!
c(5, 3) + c(TRUE, FALSE)   # équivalent à c(5, 3) + c(1, 0)
5 + (3 < 4)                # (3 < 4) vaut TRUE
5 + 3 < 4                  # priorité des opérations!

## Dans les opérations logiques, ce sont les nombres qui sont
## convertis en valeurs booléennes. Dans ce cas, zéro est
## traité comme FALSE et tous les autres nombres comme TRUE.
0:5 & 5:0
0:5 | 5:0
!0:5                       #-*- `\labelline{bases:vecteurs:fin}`
@

\gotorbox{La présente section est très importante pour la suite.
  Étudiez donc en y portant une attention toute particulière les
  lignes \reflines{bases:vecteurs} du fichier de script
  \code{\scriptfilename} reproduit à la
  \autoref{sec:bases:exemples}.}


\section{Appel d'une fonction}
\label{sec:bases:appel}

Au-delà des opérateurs de base, le langage R compte un très grand
nombre (des milliers!) de fonctions internes. Cette section passe en
revue les règles d'appel d'une fonction. Nous étudierons au
\autoref{chap:fonctions} comment composer vos propres fonctions.
Celles-ci obéiront aux mêmes règles d'appel.

Un \index{fonction!appel}appel de fonction est constitué du nom de
l'objet suivi obligatoirement de parenthèses \code{(~)} et, le cas
échéant, d'arguments entre ces parenthèses.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
\meta{nom\_fonction}(\meta{arguments})
\end{Verbatim}
\end{Schunk}

Regardons cela de plus près. À des fins d'illustration, j'ai défini
une petite fonction \code{foo} qui calcule la quantité
\begin{equation*}
  d = \sum_{i = 1}^n |x_i - y_i|^p
\end{equation*}
pour deux vecteurs $\mat{x} = (x_1, \dots, x_n)$ et
$\mat{y} = (y_1, \dots, y_n)$ et une valeur $p$. La définition de la
fonction apparait ci-dessous.
<<echo=FALSE>>=
foo <- function(x, y = 0, p = 2) sum(abs(x - y)^p)
@
<<echo=TRUE>>=
foo
@

Vous remarquerez que la fonction fait elle-même appel à deux fonctions
internes (\icode{sum} et \icode{abs}) ainsi qu'à deux opérateurs de base
(\code{-} et \verb|^|).

La fonction compte trois arguments nommés \code{x}, \code{y} et
\code{p}. La construction \code{symbole = défaut} indique la valeur
par défaut de l'argument \code{symbole}, c'est-à-dire la valeur de
l'argument si aucune n'est spécifiée dans l'appel de la fonction.
Ainsi, seul le premier argument de \code{foo} n'a pas de valeur par
défaut. La valeur par défaut de l'argument \code{y} est $0$ et celle
de l'argument \code{p} est $2$.

L'ordre des arguments dans la définition de la fonction est important.
Nous avons deux choix au moment d'appeler une fonction:
\begin{enumerate}
\item spécifier les valeurs des arguments dans le bon ordre; ou
\item nommer explicitement les arguments avec une construction de la
  forme \code{symbole = expression}, auquel cas l'ordre n'importe
  plus.
\end{enumerate}
Si certains arguments sont nommés et d'autre pas, ces derniers
reçoivent des valeurs selon leur ordre dans la définition de la
fonction, et non selon leur position dans l'appel.

Il est beaucoup plus prudent et \emph{fortement recommandé} de
spécifier les arguments par leur nom, surtout après les deux ou trois
premiers arguments.
<<echo=TRUE>>=
foo(c(3, 2), c(1, 1), 2)
foo(y = c(1, 1), c(3, 2), 2)
foo(y = c(1, 1), p = 2, c(3, 2))
@

Il n'est pas nécessaire de spécifier une valeur pour un argument
disposant d'une valeur par défaut. Cependant, si l'on omet un tel
argument, il faudra nommer les arguments qui suivent, le cas échéant.
<<echo=TRUE>>=
foo(c(3, 2))
foo(c(3, 2), p = 3)
@

\citet[section~4.3.2]{R-lang} fournit les détails sur le mécanisme de
pairage entre les arguments d'une fonction et des valeurs qui lui sont
passées.

<<script, results=hide>>=
###
### APPEL D'UNE FONCTION   `\labelline{bases:appel}`
###

## L'interpréteur R reconnait un appel de fonction au fait que
## le nom de l'objet est suivi de parenthèses ( ).
##
## Une fonction peut n'avoir aucun argument ou plusieurs. Il
## n'y a pas de limite pratique au nombre d'arguments.
##
## Les arguments d'une fonction peuvent être spécifiés selon
## l'ordre établi dans la définition de la fonction.
##
## Cependant, il est beaucoup plus prudent et *fortement
## recommandé* de spécifier les arguments par leur nom avec
## une construction de la forme 'nom = valeur', surtout après
## les deux ou trois premiers arguments.
##
## L'ordre des arguments est important; il est donc nécessaire
## de les nommer s'ils ne sont pas appelés dans l'ordre.
##
## Certains arguments ont une valeur par défaut qui sera
## utilisée si l'argument n'est pas spécifié dans l'appel de
## la fonction.
##
## Examinons la définition de la fonction 'matrix', qui sert à
## créer une matrice à partir d'un vecteur de valeurs.
args(matrix)

## La fonction compte cinq arguments et chacun a une valeur
## par défaut (ce n'est pas toujours le cas).
##
## Quel sera le résultat de l'appel ci-dessous?
matrix()

## Les invocations de la fonction 'matrix' ci-dessous sont
## toutes équivalentes.
##
## Portez attention si les arguments sont spécifiés par nom ou
## par position.
matrix(1:12, 3, 4)
matrix(1:12, ncol = 4, nrow = 3)
matrix(nrow = 3, ncol = 4, data = 1:12)
matrix(nrow = 3, ncol = 4, byrow = FALSE, 1:12)
matrix(nrow = 3, ncol = 4, 1:12, FALSE) #-*- `\labelline{bases:appel:fin}`
@

\gotorbox{Étudiez les lignes \reflines{bases:appel}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:bases:exemples}.}


\section{Fonctions internes utiles}
\label{sec:bases:internes}

Cette section présente quelques fonctions internes souvent utilisées
pour programmer en R et pour manipuler des données. Elle reviendra à
intervalles réguliers dans le document au fur et à mesure que nous
découvrirons de nouvelles fonctionnalités du langage.

La liste de fonctions ci-dessous est évidemment loin d'être
exhaustive. Un des meilleurs endroits pour découvrir de nouvelles
fonctions demeure la section \code{See Also} des rubriques d'aide, qui
offre des hyperliens vers des fonctions apparentées au sujet de la
rubrique.

Pour chaque fonction présentée dans cette section, je fournis un ou
deux exemples d'utilisation. Ces exemples sont loin de couvrir toutes
les utilisations possibles d'une fonction. La
\autoref{sec:bases:exemples} fournit des exemples additionnels.
Consultez les rubriques d'aide des fonctions pour connaître toutes
leurs options.

\tipbox{Vraiment, consultez les rubriques d'aide.}

\subsection{Fonctions mathématiques et trigonométriques}
\label{sec:bases:internes:math}

\begin{ttscript}{factorial}
\item[\Icode{exp}] fonction \index{exponentielle}exponentielle $e^x$
<<echo=TRUE>>=
exp(1)
@
\item[\Icode{log}] \index{logarithme}logarithme naturel ou dans une
  base quelconque
<<echo=TRUE>>=
log(exp(1))
log(9, base = 3)
@
\item[\Icode{sqrt}] \index{racine@racine carrée}racine carrée
<<echo=TRUE>>=
sqrt(9)
@
\item[\Icode{abs}] \index{valeur absolue}valeur absolue
<<echo=TRUE>>=
abs(c(-1, 0, 2))
@
\item[\Icode{gamma}] fonction \index{gamma}gamma $\Gamma(x) =
  \int_0^\infty t^{x - 1} e^{-t}\, dt$ (et les fonctions apparentées
  \icode{lgamma}, \icode{digamma}, \icode{trigamma})
<<echo=TRUE>>=
gamma(5)
@
\item[\Icode{factorial}] \index{factorielle}factorielle $x!$ (et la
  fonction apparentée \icode{lfactorial})
<<echo=TRUE>>=
factorial(4)
@
\item[\Icode{cos}] \index{trigonometrie@trigonométrie}cosinus en radians
  (et les autres fonctions trigonométriques: \icode{sin},
  \icode{tan}, \icode{acos}, etc.)
<<echo=TRUE>>=
cos(pi/4)
@
\end{ttscript}

\subsection{Suites et répétition}
\label{sec:bases:internes:seq}

\begin{ttscript}{seqmalong}
\item[\Icode{seq}] suite de nombres générale
<<echo=TRUE>>=
seq(1, 9, by = 2)
@
\item[\Icode{\protect seq\_len}] \index{suite}suite de nombres de la
  longueur donnée en argument à partir de $1$ (plus rapide que
  \code{seq})
<<echo=TRUE>>=
seq_len(10)
@
\item[\Icode{\protect seq\_along}] suite de nombres de la longueur du
  vecteur en argument à partir de $1$ (plus rapide que \code{seq})
<<echo=TRUE>>=
seq_along(10)
@
\item[\Icode{rep}] \index{repetition@répétition}répétition de
  vecteurs, de chaque élément d'un vecteur ou d'une combinaison des
  deux
<<echo=TRUE>>=
rep(2, 10)
rep(c(1, 3), each = 4)
rep(c(1, 3), times = 2, each = 4)
@
\item[\Icode{rep.int}] répétition de vecteurs complets uniquement
  (plus rapide que \code{rep})
<<echo=TRUE>>=
rep.int(2, 10)
@
\item[\Icode{rep\_len}] répétition de vecteurs jusqu'à une certaine
  longueur (plus rapide que \code{rep})
<<echo=TRUE>>=
rep_len(1:3, 10)
@
\end{ttscript}

\cautionbox{La fonction \icode{\protect seq\_len} est plus robuste que
  \icode{seq} ou que l'opérateur «\code{:}» pour la programmation.
  L'expression \code{seq\_len(\meta{n})} génère une suite de longueur
  \meta{n}. C'est généralement équivalent à \code{seq(\meta{n})} ou
  \code{1:\meta{n}}, sauf lorsque \meta{n} vaut $0$. En effet,
  \code{seq\_len(0)} résulte en un vecteur de longueur nulle, alors
  que le résultat de \code{seq(0)} et \code{1:0} est
  malencontreusement le vecteur \code{c(1, 0)}.}

\subsection{Extraction du début et de la fin d'un objet}
\label{sec:bases:internes:head}

\begin{ttscript}{head}
\item[\Icode{head}] avec second argument $n > 0$ ($n = 6$ par défaut):
  $n$ premières composantes d'un objet (éléments d'un vecteur, lignes
  d'une matrice ou d'un \emph{data frame})
<<echo=TRUE>>=
head(1:10, 3)
@
  avec second argument
  $n < 0$: objet sans les $|n|$ dernières composantes
<<echo=TRUE>>=
head(1:10, -3)
@
\item[\Icode{tail}] avec second argument $n > 0$ ($n = 6$ par défaut):
  $n$ dernières composantes d'un objet (éléments d'un vecteur, lignes
  d'une matrice ou d'un \emph{data frame});
<<echo=TRUE>>=
tail(1:10, 3)
@
  avec second argument $n < 0$: objet sans les $|n|$ premières
  composantes
<<echo=TRUE>>=
tail(1:10, -3)
@
\end{ttscript}

\subsection{Arrondi}
\label{sec:bases:internes:arrondi}

Les exemples de cette sous-section utilisent le vecteur suivant.
<<echo=FALSE>>=
x <- c(-3.68, -2/3, pi, 1/3, 2.52)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{ceiling}
\item[\Icode{round}] \index{arrondi}arrondi à un nombre défini de
  décimales ($0$ par défaut)
<<echo=TRUE>>=
round(x)
round(x, 3)
@
\item[\Icode{floor}] plus grand entier inférieur ou égal à l'argument
<<echo=TRUE>>=
floor(x)
@
\item[\Icode{ceiling}] plus petit entier supérieur ou égal à
  l'argument
<<echo=TRUE>>=
ceiling(x)
@
\item[\Icode{trunc}] troncature vers zéro; différent de \texttt{floor}
  pour les nombres négatifs
<<echo=TRUE>>=
trunc(x)
@
\end{ttscript}

\subsection{Tests logiques}
\label{sec:bases:internes:tests}

Les exemples de cette sous-section utilisent toujours le vecteur suivant.
<<echo=FALSE>>=
x <- c(4, -1, 2, -3, 6)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{any}
\item[\Icode{any}] \index{any}vrai si au moins une valeur du vecteur
  booléen en argument est vraie
<<echo=TRUE>>=
any(x < 0)
any(x > 10)
@
\item[\Icode{all}] \index{all}vrai si toutes les valeurs du vecteur
  booléen en argument sont vraies
<<echo=TRUE>>=
all(x < 0)
all(x > -5)
@

\end{ttscript}

\subsection{Sommaires et statistiques descriptives}
\label{sec:bases:internes:sommaires}

Les exemples de cette sous-section utilisent le vecteur suivant.
<<echo=FALSE>>=
x <- c(14, 17, 7, 9, 3, 4, 25, 21, 24, 11)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{quantile}
\item[\Icode{sum}] \index{somme}somme des éléments
<<echo=TRUE>>=
sum(x)
@
\item[\Icode{prod}] \index{produit}produit des éléments
<<echo=TRUE>>=
prod(x)
@
\item[\Icode{diff}] \index{différences}différences entre les éléments
  (opérateur mathématique $\nabla$)
<<echo=TRUE>>=
diff(x)
@
\item[\Icode{mean}] \index{moyenne}moyenne arithmétique
<<echo=TRUE>>=
mean(x)
@
\item[\Icode{var}] \index{variance}variance (et \index{ecart
    type@écart type}écart type avec \Icode{sd})
<<echo=TRUE>>=
var(x)
@
\item[\Icode{min}] \index{minimum!valeur}minimum
<<echo=TRUE>>=
min(x)
@
\item[\Icode{max}] \index{maximum!valeur}maximum
<<echo=TRUE>>=
max(x)
@
\item[\Icode{range}] \index{etendue@étendue}étendue (minimum et
  maximum)
<<echo=TRUE>>=
range(x)
@
\item[\Icode{median}] \index{mediane@médiane}médiane empirique
<<echo=TRUE>>=
median(x)
@
\item[\Icode{quantile}] \index{quantile}quantiles empiriques
<<echo=TRUE>>=
quantile(x)
@
\item[\Icode{summary}] principales statistiques descriptives
<<echo=TRUE>>=
summary(x)
@
\end{ttscript}


\subsection{Sommaires cumulatifs et comparaisons élément par élément}
\label{sec:bases:internes:cumulatifs}

Les exemples de cette sous-section utilisent le vecteur suivant.
<<echo=FALSE>>=
x <- c(14, 17, 7, 9, 3)
@
<<echo=TRUE>>=
x
@

\begin{ttscript}{cumprod}
\item[\Icode{cumsum}] \index{somme!cumulative}somme cumulative
<<echo=TRUE>>=
cumsum(x)
@
\item[\Icode{cumprod}] \index{produit!cumulatif}produit cumulatif
<<echo=TRUE>>=
cumprod(x)
@
\item[\Icode{cummin}] \index{minimum!cumulatif}minimum cumulatif
<<echo=TRUE>>=
cummin(x)
@
\item[\Icode{cummax}] \index{maximum!cumulatif}maximum cumulatif
<<echo=TRUE>>=
cummax(x)
@
\item[\Icode{pmin}] \index{minimum!parallèle}minimum élément par
  élément (en parallèle)
<<echo=TRUE>>=
pmin(x, 12)
@
\item[\Icode{pmax}] \index{maximum!parallèle}maximum élément par
  élément (en parallèle)
<<echo=TRUE>>=
pmax(x, c(16, 23,  4, 12,  3))
@
\end{ttscript}

<<script, results=hide>>=
###
### QUELQUES FONCTIONS INTERNES UTILES  `\labelline{bases:internes}`
###

## Pour les exemples qui suivent, on se donne un vecteur non
## ordonné.
x <- c(50, 30, 10, 20, 60, 30, 20, 40)

## FONCTIONS MATHÉMATIQUES ET TRIGONOMÉTRIQUES

## R contient des fonctions pour calculer la plupart des
## fonctions mathématiques et trigonométriques usuelles.
exp(c(1, 2, -1))           # exponentielle
log(exp(c(1, 2, -1)))      # logarithme naturel
log10(c(1, 10, 100))       # logarithme en base 10
log(c(1, 5, 25), base = 5) # logarithme en base quelconque
sqrt(x)                    # racine carrée
abs(x - mean(x))           # valeur absolue
gamma(1:5)                 # fonction gamma
factorial(0:4)             # factorielle
##-!- ?gamma                     # toutes les fonctions apparentées
cos(seq(0, pi, by = pi/4)) # cosinus
sin(seq(0, pi, by = pi/4)) # sinus
tan(seq(0, pi, by = pi/4)) # tangente
##-!- ?Trig                      # toutes les fonctions apparentées

## SUITES ET RÉPÉTITION

## La fonction 'seq' sert à générer des suites générales. Ses
## principaux arguments sont 'from', 'to' et 'by'.
seq(from = 1, to = 10)       # équivalent à 1:10
seq(10)                      # idem
seq(1, 10, by = 2)           # avec incrément autre que 1
seq(-10, 10, length.out = 5) # incrément automatique

## La fonction 'seq_len' génère une suite de longueur 'n' à
## partir de 1. C'est une version simplifiée et plus rapide de
## 'seq(..., length.out = n)'. De plus, elle est plus robuste
## lorsque l'argument est 0.
seq(10)                    # suite 1, 2, ..., 10
seq(1, length.out = 10)    # idem robuste
seq_len(10)                # équivalent et plus rapide
seq(0)                     # pas ce que l'on penserait!
seq(1, length.out = 0)     # plus prudent
seq_len(0)                 # plus simple

## La fonction 'seq_along' génère une suite de la longueur du
## vecteur en argument à partir de 1. C'est une version
## simplifiée et plus rapide de 'seq(..., along = x)' et de
## 'seq_len(length(x))'.
seq(1, along = x)            # suite de la longueur de x
seq_len(length(x))           # idem, mais deux fonctions
seq_along(x)                 # plus rapide, plus simple

## La fonction 'rep' permet de répéter des vecteurs de
## plusieurs manières différentes.
rep(1, 10)                  # utilisation de base
rep(x, 2)                   # répéter un vecteur
rep(x, each = 4)            # répéter chaque élément
rep(x, times = 2, each = 4) # combinaison des arguments
rep(x, length.out = 20)     # résultat de longueur déterminée
rep(x, times = 1:8)         # nombre de répétitions différent
                            # pour chaque élément de 'x'

## Pour les deux types de répétitions les plus usuels, il y a
## les fonctions 'rep.int' et 'rep_len' qui sont plus rapides
## que 'rep'.
rep.int(x, 2)              # seulement répétition 'times'
rep_len(x, 10)             # seulement répétition 'length.out'

## EXTRACTION DU DÉBUT ET DE LA FIN D'UN OBJET

## L'idée des fonctions 'head' et 'tail', c'est que l'on se
## positionne en tête ou en queue d'un objet pour effectuer
## des extractions ou des suppressions de composantes.
##
## Avec un argument positif, les fonctions extraient des
## composantes depuis la tête ou la queue de l'objet. Avec un
## argument négatif, elles suppriment des composantes à
## l'«autre bout» de l'objet.
head(x, 3)                 # trois premiers éléments
head(x, -2)                # tous sauf les deux derniers
tail(x, 3)                 # trois derniers éléments
tail(x, -2)                # tous sauf les deux premiers

## Les fonctions sont aussi valides sur les matrices et les
## data frames. Elles extraient ou suppriment alors des lignes
## entières.
m <- matrix(1:30, 5, 6)    # matrice 5 x 6
head(m, 3)                 # trois premières lignes
tail(m, -2)                # sans les deux premières lignes

## ARRONDI
(x <- c(-21.2, -pi, -1.5, -0.2, 0, 0.2, 1.7823, 315))
round(x)                   # arrondi à l'entier
round(x, 2)                # arrondi à la seconde décimale
round(x, -1)               # arrondi aux dizaines
ceiling(x)                 # plus petit entier supérieur
floor(x)                   # plus grand entier inférieur
trunc(x)                   # troncature des décimales

## TESTS LOGIQUES

## Les fonctions 'any' et 'all' prennent en argument un
## vecteur booléen et elles indiquent, respectivement, si au
## moins une ou si toutes les valeurs sont TRUE.
any(c(TRUE, FALSE, FALSE))  # au moins une valeur TRUE
any(c(FALSE, FALSE, FALSE)) # aucune valeur TRUE
all(c(TRUE, TRUE, TRUE))    # toutes les valeurs TRUE
all(c(TRUE, FALSE, TRUE))   # aucune valeur TRUE

## Les fonctions sont des compléments l'une de l'autre: si
## 'any(x)' est TRUE, alors 'all(!x)' est FALSE, et
## vice-versa.
any(c(TRUE, FALSE, FALSE))   # TRUE
all(!c(TRUE, FALSE, FALSE))  # complément: FALSE
any(c(FALSE, FALSE, FALSE))  # FALSE
all(!c(FALSE, FALSE, FALSE)) # complément: TRUE

## Les fonctions sont habituellement utilisées avec une
## expression logique en argument.
x                          # rappel
x > 50                     # valeurs > 50?
x <= 50                    # valeurs <= 50?
any(x > 50)                # y a-t-il des valeurs > 50?
all(x <= 50)               # complément
all(x > 50)                # toutes les valeurs > 50?
any(x <= 50)               # complément

## SOMMAIRES ET STATISTIQUES DESCRIPTIVES
sum(x)                     # somme des éléments
prod(x)                    # produit des éléments
diff(x)                    # x[2] - x[1], x[3] - x[2], etc.
mean(x)                    # moyenne des éléments
mean(x, trim = 0.125)      # moyenne sans minimum et maximum
var(x)                     # variance (sans biais)
sd(x)                      # écart type
max(x)                     # maximum
min(x)                     # minimum
range(x)                   # c(min(x), max(x))
diff(range(x))             # étendue de 'x'
median(x)                  # médiane (50e quantile) empirique
quantile(x)                # quantiles empiriques
quantile(x, 1:10/10)       # on peut spécifier les quantiles
summary(x)                 # plusieurs des résultats ci-dessus

## SOMMAIRES CUMULATIFS ET COMPARAISONS ÉLÉMENT PAR ÉLÉMENT
(x <- sample(1:20, 6))
(y <- sample(1:20, 6))
cumsum(x)                  # somme cumulative de 'x'
cumprod(y)                 # produit cumulatif de 'y'
rev(cumprod(rev(y)))       # produit cumulatif renversé
cummin(x)                  # minimum cumulatif
cummax(y)                  # maximum cumulatif
pmin(x, y)                 # minimum élément par élément
pmax(x, y)                 # maximum élément par élément `\labelline{bases:internes:fin}`
@

\gotorbox{Vous trouverez plusieurs exemples additionnels d'utilisation des
  fonctions présentées dans cette section dans le code des lignes
  \reflines{bases:internes}
  du fichier de script \code{\scriptfilename}
  reproduit à la \autoref{sec:bases:exemples}.}


\section{Exemples}
\label{sec:bases:exemples}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=\scriptfirstline]{\scriptfilename}


\section{Exercices}
\label{sec:bases:exercices}

\Opensolutionfile{solutions}[solutions-bases]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{chap:bases}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{chap:bases}}

\end{Filesave}

Il est possible de compléter tous les exercices ci-dessous sans avoir
recours à R, sinon pour vérifier vos réponses. (En fait, les exercices
sont de peu d'intérêt autrement.)

\begin{exercice}
  Évaluer les expressions suivantes comme le ferait l'interpréteur R.
  \begin{enumerate}
  \item \verb|1:5 * c(0, 1, 0, 1, 0)|
  \item \verb|c(2, 7, 1, 4) > 3|
  \item \verb|c(2, 7, 1, 4) <= c(10, 4)|
  \item \verb|c(-1, 2, 4)^(3:-2)|
  \item \verb|c(TRUE, FALSE, FALSE) & c(TRUE, TRUE, FALSE)|
  \item \verb=c(TRUE, FALSE, FALSE) | !2 < 3=
  \item \verb|-1:1/0|
  \item \verb|length(c("a", "abc", "ab"))|
  \item \verb|x <- c(-1, -2, -3); length(x)|
  \item \verb|length(c(c(1, 3, 6, 7), NULL))|
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item Produit élément par élément entre deux vecteurs.
<<echo=FALSE>>=
1:5 * c(0, 1, 0, 1, 0)
@
     \item Comparaison élément par élément, le second vecteur étant
       utilisé quatre fois.
<<echo=FALSE>>=
c(2, 7, 1, 4) > 3
@
     \item Comparaison élément par élément, le second vecteur étant
       utilisé deux fois.
<<echo=FALSE>>=
c(2, 7, 1, 4) <= c(10, 4)
@
     \item Élévation à une puissance élément par élément, le premier
       vecteur étant utilisé deux fois.
<<echo=FALSE>>=
c(-1, 2, 4)^(3:-2)
@
     \item «Et» logique élément par élément.
<<echo=FALSE>>=
c(TRUE, FALSE, FALSE) & c(TRUE, TRUE, FALSE)
@
     \item Attention à la priorité des opérations! En vertu des
       priorités énoncées au \autoref{tab:bases:operateurs}, les
       opérations sont effectuées dans cet ordre: inégalité
       (\verb=<=), négation logique (\verb=!=) , «ou» logique
       (\verb=|=).
<<echo=FALSE>>=
c(TRUE, FALSE, FALSE) | !2 < 3
@
     \item Encore ici, la génération d'une suite a priorité sur la
       division.
<<echo=FALSE>>=
-1:1/0
@
     \item Vecteur de trois chaines de caractères, peu importe leur
       longueur.
<<echo=FALSE>>=
length(c("a", "abc", "ab"))
@
     \item
<<echo=FALSE>>=
x <- c(-1, -2, -3); length(x)
@
     \item Concaténer \code{NULL} à un vecteur n'ajoute rien (ou du
       vide, qui n'a pas de longueur).
<<echo=FALSE>>=
length(c(c(1, 3, 6, 7), NULL))
@
     \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \index{indiçage!vecteur}
  Soit \code{x} un vecteur contenant les valeurs d'un échantillon:
  \begin{center}
<<echo=FALSE>>=
x <- c(18, 11, 10, 2, 19, 9, 12, 15, 13, 12, 1, 6)
@
<<echo=TRUE>>=
x
@
  \end{center}
  Écrire des expressions R pour créer ce vecteur dans l'espace de
  travail et pour extraire les éléments suivants.
  \begin{enumerate}
  \item Le deuxième élément de l'échantillon.
  \item Les cinq premiers éléments de l'échantillon.
  \item Les éléments strictement supérieurs à $14$.
  \item Tous les éléments sauf ceux en positions $6$, $7$ et $12$.
  \end{enumerate}
  \begin{sol}
    On crée d'abord le vecteur avec
<<echo=TRUE>>=
x <- c(18, 11, 10, 2, 19, 9, 12, 15, 13, 12, 1, 6)
@
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[2]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[1:5]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x > 14]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[-c(6, 7, 12)]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{ex:bases:moyennes}
  Soit $\mat{x} = (x_1, \dots, x_n)$ et $\mat{y} = y_1, \dots, y_n$
  deux vecteurs de nombres réels. Composer des expressions R pour
  effectuer les calculs mathématiques ci-dessous. Vous pouvez utiliser
  les fonctions R suivantes: \icode{sum}, \icode{prod}, \icode{max},
  \icode{abs}.
  \begin{enumerate}
  \item $3 (\mat{x} + \mat{y})$
  \item $n^{-1} \sum_{i = 1}^n x_i$ (moyenne arithmétique de $\mat{x}$)
  \item $(\prod_{i = 1}^n x_i)^{1/n}$ (moyenne géométrique de $\mat{x}$)
  \item $1/(\prod_{i = 1}^n x_i^{-1})$ (moyenne harmonique de
    $\mat{x}$)
  \item $\langle \mat{x}, \mat{y} \rangle = \sum_{i = 1}^n x_i y_i$
    (produit scalaire entre $\mat{x}$ et $\mat{y}$)
  \item $\|\mat{x} - \mat{y}\|_1 = \sum_{i = 1}^n |x_i -
    y_i|$ (norme $1$ entre $\mat{x}$ et $\mat{y}$)
  \item $\|\mat{x} - \mat{y}\|_\infty = \max_{i = 1, \dots, n}(|x_i -
    y_i|)$ (norme «infini» entre $\mat{x}$ et $\mat{y}$)
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item
<<echo=TRUE,eval=FALSE>>=
3 * (x + y)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(x)/length(x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
prod(x)^(1/length(x))
@
    \item
<<echo=TRUE,eval=FALSE>>=
1/prod(1/x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(x * y)
@
    \item
<<echo=TRUE,eval=FALSE>>=
sum(abs(x - y))
@
    \item
<<echo=TRUE,eval=FALSE>>=
max(abs(x - y))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  On vous donne la définition d'une fonction R:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
> f
function(x = 0, y = NULL, z) \meta{corps}
\end{Verbatim}
\end{Schunk}
  Déterminer la valeur des arguments \code{x}, \code{y} et \code{z}
  dans les appels de fonction ci-dessous.
  \begin{enumerate}
  \item \code{f(2, 3, 4)}
  \item \code{f(2, z = 3, y = 4)}
  \item \code{f(x = 2, z = 3)}
  \item \code{f(z = 2, 3, x = 4)}
  \item \code{f(z = 2)}
  \item \code{f(z = 2, 3, 4)}
  \item \code{f(2, 3)}
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item \code{x = 2}, \code{y = 3}, \code{z = 4}
    \item \code{x = 2}, \code{y = 4}, \code{z = 3}
    \item \code{x = 2}, \code{y = NULL}, \code{z = 3}
    \item \code{x = 4}, \code{y = 3}, \code{z = 2}
    \item \code{x = 0}, \code{y = NULL}, \code{z = 2}
    \item \code{x = 3}, \code{y = 4}, \code{z = 2}
    \item \link{https://i0.kym-cdn.com/entries/icons/original/000/000/157/itsatrap.jpg}{C'est un piège!} %
      Cet appel n'est pas valide puisque l'argument \code{z} est
      manquant.
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit la fonction \code{f} suivante:
<<echo=FALSE>>=
f <- function(x, y)
{
    g <- function(a)
        (x - y) * a + a * x
    g(1 + x * y)
}
@
<<echo=TRUE>>=
f
@
  Vous aurez compris que le corps de la fonction \code{f} contient la
  définition d'une fonction \code{g} (nous étudierons la
  syntaxe de la définition des fonctions au \autoref{chap:fonctions}).
  Évaluer les résultats des appels ci-dessous.
  \begin{enumerate}
  \item \code{f(1, 1)}
  \item \code{f(f(1, 1), 1)}
  \item \code{f(1, f(f(1, 1), 1))}
  \end{enumerate}
  \begin{sol}
    Cet exercice fait quelque peu appel à votre intuition pour
    déterminer les valeurs des objets \code{x} et \code{y} à
    l'intérieur de la fonction \code{g}. Sans doute avez-vous utilisé
    les valeurs déjà définies dans la fonction \code{f}, ce qui est
    juste en vertu des règles de \index{portee lexicale@portée
      lexicale}\emph{portée lexicale} de R. Celles-ci font l'objet de
    la \autoref{sec:implementation:portee}. Dans certains langages de
    programmation, les objets seraient indéfinis et les appels de
    fonction résulteraient tous en une erreur.
    \begin{enumerate}
    \item
<<echo=FALSE>>=
f(1, 1)
@
    \item
<<echo=FALSE>>=
f(f(1, 1), 1)
@
    \item
<<echo=FALSE>>=
f(1, f(f(1, 1), 1))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Générer les suites suivantes à l'aide des fonctions \icode{rep},
  \icode{seq} et \code{c} seulement.
  \begin{enumerate}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(rep(c(0, 6), 3))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(seq(1, 10, by = 3))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(rep(1:3, 4))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(rep(1:3, 1:3))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(rep(1:3, 3:1))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(seq(1, 10, length = 3))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, results=tex, strip.white=false>>=
cat(rep(1:3, rep(4, 3)))
@
\end{verbatim}
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE, eval=FALSE>>=
rep(c(0, 6), 3)
@
\item
<<echo=TRUE, eval=FALSE>>=
seq(1, 10, by = 3)
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(1:3, 4)
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(1:3, 1:3)
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(1:3, 3:1)
@
\item
<<echo=TRUE, eval=FALSE>>=
seq(1, 10, length = 3)
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(1:3, rep(4,3))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Générer les suites de nombres suivantes à l'aide de l'opérateur
  {\NoAutoSpacing\verb=:=}\index{:@\verb=:=} et de la fonction
  \icode{rep} seulement (donc sans utiliser la fonction \icode{seq}).
  \begin{enumerate}
  \item
\begin{verbatim}
<<echo=FALSE, eval=TRUE, results=tex, strip.white=false>>=
cat(11:20 / 10)
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, eval=TRUE, results=tex, strip.white=false>>=
cat(2 * 0:9 + 1)
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, eval=TRUE, results=tex, strip.white=false>>=
cat(rep(-2:2, 2))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, eval=TRUE, results=tex, strip.white=false>>=
cat(rep(-2:2, each = 2))
@
\end{verbatim}
  \item
\begin{verbatim}
<<echo=FALSE, eval=TRUE, results=tex, strip.white=false>>=
cat(10 * 1:10)
@
\end{verbatim}
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE, eval=FALSE>>=
11:20/10
@
\item
<<echo=TRUE, eval=FALSE>>=
2 * 0:9 + 1
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(-2:2, 2)
@
\item
<<echo=TRUE, eval=FALSE>>=
rep(-2:2, each = 2)
@
\item
<<echo=TRUE, eval=FALSE>>=
10 * 1:10
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Sans utiliser les fonctions \icode{factorial}, \icode{lfactorial},
  \icode{gamma} ou \icode{lgamma}, générer la suite
  $1!, 2!, \dots, 10!$.
  \begin{sol}
<<echo=TRUE, eval=FALSE>>=
cumprod(1:10)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Trouver une relation entre \code{x}, \code{y} (\code{y != 0}),
  \code{x \%\% y} (modulo) et \code{x \%/\% y} (division entière).
  \begin{sol}
    \verb|x == (x %% y) + y * (x %/% y)|
  \end{sol}
\end{exercice}

\begin{exercice}
  Soit \code{x} un vecteur de longueur $20$. Écrire des expressions R
  permettant d'obtenir ou de calculer chacun des résultats demandés
  ci-dessous.
  \begin{enumerate}
  \item Les cinq premiers éléments de \code{x}.
  \item La valeur maximale de \code{x}.
  \item La moyenne des cinq premiers éléments de \code{x}.
  \item La moyenne des cinq derniers éléments de \code{x}.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE, eval=FALSE>>=
x[1:5]
head(x, 5)
@
\item
<<echo=TRUE, eval=FALSE>>=
max(x)
@
\item
<<echo=TRUE, eval=FALSE>>=
mean(x[1:5])
mean(head(x, 5))
@
\item
<<echo=TRUE, eval=FALSE>>=
mean(x[16:20])
mean(tail(x, 5))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: noweb
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
